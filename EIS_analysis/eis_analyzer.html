<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Electrochemical Impedance Spectroscopy (EIS) data analysis tool with circuit model fitting, Nyquist plots, and Bode plots">
    <title>EIS Analyzer - Circuit Model Fitting</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        header h1 { font-size: 2.5em; margin-bottom: 5px; }
        header p { opacity: 0.9; }
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 30px;
        }
        .panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e0e0e0;
        }
        .panel h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
            font-size: 0.9em;
        }
        select, textarea, input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }
        select:focus, textarea:focus, input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 5px rgba(102, 126, 234, 0.3);
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }
        button:hover { background: #764ba2; }
        button:active { transform: scale(0.98); }
        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .button-group button { flex: 1; }
        textarea {
            resize: vertical;
            min-height: 120px;
        }
        .results {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid #ddd;
        }
        .results h3 {
            color: #667eea;
            font-size: 1em;
            margin-bottom: 10px;
        }
        .result-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }
        .result-row:last-child { border-bottom: none; }
        .result-label { color: #666; font-weight: 500; }
        .result-value { color: #333; font-family: monospace; }
        .plot-container {
            width: 100%;
            height: 400px;
            min-height: 300px;
            border-radius: 8px;
            overflow: hidden;
        }
        .file-upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 15px;
        }
        .file-upload-area:hover, .file-upload-area.drag-over {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }
        .file-upload-area.loaded {
            border-color: #28a745;
            border-style: solid;
        }
        .file-upload-area input[type="file"] {
            display: none;
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
        .status {
            padding: 12px;
            border-radius: 4px;
            margin-top: 15px;
            font-size: 0.9em;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .full-width {
            grid-column: 1 / -1;
        }
        .two-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 1000px) {
            .content { grid-template-columns: 1fr; }
            .two-col { grid-template-columns: 1fr; }
            .plot-container { height: 350px; }
        }
        @media (max-width: 600px) {
            header h1 { font-size: 1.8em; }
            .content { padding: 15px; }
            .panel { padding: 15px; }
            .plot-container { height: 300px; }
        }
        /* Focus styles for accessibility */
        button:focus, select:focus, textarea:focus, input:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }
        .file-upload-area:focus-within {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ö° EIS Analyzer</h1>
            <p>Electrochemical Impedance Spectroscopy Data Analysis & Circuit Model Fitting</p>
        </header>

        <main class="content" role="main">
            <!-- Input Panel -->
            <div class="panel" role="region" aria-labelledby="data-input-heading">
                <h2 id="data-input-heading">üìä Data Input</h2>

                <!-- File Upload Area -->
                <div class="file-upload-area" id="fileDropZone" role="button" tabindex="0" aria-label="Upload CSV or TXT file with EIS data">
                    <div>üìÅ Drop file here or click to upload</div>
                    <div style="font-size: 0.85em; color: #666; margin-top: 5px;">Supports CSV, TXT (tab/space separated)</div>
                    <input type="file" id="fileInput" accept=".csv,.txt,.tsv" aria-label="File upload input">
                    <div id="fileStatus" style="margin-top: 10px; color: #28a745;"></div>
                </div>

                <div class="form-group">
                    <label for="dataFormat">Data Format</label>
                    <select id="dataFormat" aria-describedby="format-help">
                        <option value="zreal_zimag">Frequency, Z' (Real), Z" (Imaginary) - Ohms</option>
                        <option value="freq_zmag_phase">Frequency, |Z|, Phase (degrees)</option>
                    </select>
                    <small id="format-help" style="color: #666; font-size: 0.8em;">Select the format matching your data columns</small>
                </div>

                <div class="form-group">
                    <label id="sample-data-label">Sample Data</label>
                    <div class="button-group" role="group" aria-labelledby="sample-data-label">
                        <button type="button" onclick="loadSampleData()">Load Sample</button>
                        <button type="button" onclick="clearData()">Clear</button>
                    </div>
                </div>

                <div class="form-group">
                    <label for="dataInput">Paste Data (tab or space separated)</label>
                    <textarea id="dataInput" aria-describedby="data-format-hint" placeholder="Frequency	Z_real	Z_imag
0.01	1000	-500
0.1	950	-480
..."></textarea>
                    <small id="data-format-hint" style="color: #666; font-size: 0.8em;">Data will be parsed automatically when pasted or when format is changed</small>
                </div>

                <div id="dataStatus" role="status" aria-live="polite"></div>

                <h2 id="circuit-model-heading" style="margin-top: 30px;">‚öôÔ∏è Circuit Model</h2>

                <div class="form-group">
                    <label for="modelType">Select Model</label>
                    <select id="modelType" aria-describedby="model-help">
                        <option value="R">R (Resistor only)</option>
                        <option value="RC">R-C (Series)</option>
                        <option value="RRC">R-(R||C) (Randles-like)</option>
                        <option value="RCRC">R-C-R-C (Two time constants)</option>
                    </select>
                    <small id="model-help" style="color: #666; font-size: 0.8em;">Choose a circuit model to fit your EIS data</small>
                </div>

                <div class="form-group">
                    <label for="initialFreq">Initial Frequency (Hz)</label>
                    <input type="number" id="initialFreq" value="1000" min="0.001" step="any" aria-describedby="freq-help">
                    <small id="freq-help" style="color: #666; font-size: 0.8em;">Starting frequency for optimization (Hz)</small>
                </div>

                <button type="button" onclick="fitModel()" style="width: 100%; background: #28a745;">Fit Model</button>
                <div id="fitStatus" role="status" aria-live="polite"></div>

                <h2 id="debug-heading" style="margin-top: 30px;">üß™ Debug Test</h2>
                <div class="form-group">
                    <label for="debugModel">Test Model</label>
                    <select id="debugModel">
                        <option value="RRC">R-(R||C) (Randles-like)</option>
                        <option value="RCRC">R-C-R-C (Two time constants)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="noiseLevel">Noise Level (%)</label>
                    <input type="number" id="noiseLevel" value="2" min="0" max="20" step="0.5">
                    <small style="color: #666; font-size: 0.8em;">Add random noise to simulate real measurement conditions</small>
                </div>
                <button type="button" onclick="runDebugTest()" style="width: 100%; background: #6c757d;">Run Debug Test</button>
                <div id="debugStatus" role="status" aria-live="polite"></div>
            </div>

            <!-- Results Panel -->
            <div class="panel" role="region" aria-labelledby="results-heading">
                <h2 id="results-heading">üìà Fit Results</h2>
                <div id="fitResults" aria-live="polite"></div>
            </div>

            <!-- Nyquist Plot -->
            <div class="panel full-width" role="region" aria-labelledby="nyquist-heading">
                <h2 id="nyquist-heading">Nyquist Plot (Z' vs -Z")</h2>
                <div id="nyquistPlot" class="plot-container" role="img" aria-label="Nyquist plot showing real vs imaginary impedance"></div>
            </div>

            <!-- Bode Plot -->
            <div class="panel full-width" role="region" aria-labelledby="bode-heading">
                <h2 id="bode-heading">Bode Plot</h2>
                <div class="two-col">
                    <div id="bodeMagnitudePlot" class="plot-container" role="img" aria-label="Bode magnitude plot showing impedance vs frequency"></div>
                    <div id="bodePhase" class="plot-container" role="img" aria-label="Bode phase plot showing phase angle vs frequency"></div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Global data storage
        let eisData = {
            frequency: [],
            zReal: [],
            zImag: [],
            zMag: [],
            zPhase: []
        };

        // Initialize file upload and auto-parse functionality
        document.addEventListener('DOMContentLoaded', function() {
            initFileUpload();
            initAutoParse();
        });

        function initAutoParse() {
            const dataInput = document.getElementById('dataInput');
            const dataFormat = document.getElementById('dataFormat');
            let parseTimeout;

            // Auto-parse when data is pasted or typed (with debounce)
            dataInput.addEventListener('input', () => {
                clearTimeout(parseTimeout);
                parseTimeout = setTimeout(() => {
                    if (dataInput.value.trim()) {
                        parseData();
                    }
                }, 500); // 500ms debounce
            });

            // Auto-parse when format changes (if data exists)
            dataFormat.addEventListener('change', () => {
                if (dataInput.value.trim()) {
                    parseData();
                }
            });
        }

        function initFileUpload() {
            const dropZone = document.getElementById('fileDropZone');
            const fileInput = document.getElementById('fileInput');

            // Click to upload
            dropZone.addEventListener('click', () => fileInput.click());

            // Keyboard accessibility
            dropZone.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    fileInput.click();
                }
            });

            // Drag and drop
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                const file = e.dataTransfer.files[0];
                if (file) handleFileUpload(file);
            });

            // File input change
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) handleFileUpload(file);
            });
        }

        function handleFileUpload(file) {
            const status = document.getElementById('fileStatus');
            const dropZone = document.getElementById('fileDropZone');

            // Validate file type
            const validTypes = ['.csv', '.txt', '.tsv'];
            const ext = '.' + file.name.split('.').pop().toLowerCase();
            if (!validTypes.includes(ext)) {
                status.textContent = 'Error: Please upload CSV or TXT file';
                status.style.color = '#dc3545';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById('dataInput').value = e.target.result;
                status.textContent = `‚úì Loaded: ${file.name}`;
                status.style.color = '#28a745';
                dropZone.classList.add('loaded');
                parseData();
            };
            reader.onerror = () => {
                status.textContent = 'Error reading file';
                status.style.color = '#dc3545';
            };
            reader.readAsText(file);
        }

        function loadSampleData() {
            // Sample EIS data: Frequency (Hz), Z' (Real, Ohms), Z" (Imaginary, Ohms)
            // This represents a typical R-(R||C) circuit response
            const sampleData = `1000	100	-50
500	105	-55
200	110	-60
100	120	-70
50	135	-85
20	160	-110
10	200	-150
5	250	-200
2	350	-300
1	500	-450
0.5	700	-600
0.2	1200	-800
0.1	1500	-900
0.05	1800	-950
0.02	2000	-950
0.01	2050	-900`;
            document.getElementById('dataInput').value = sampleData;
            // Fix: Sample data is in Z' Z" format, not magnitude/phase
            document.getElementById('dataFormat').value = 'zreal_zimag';
            parseData();
        }

        function clearData() {
            document.getElementById('dataInput').value = '';
            document.getElementById('fileStatus').textContent = '';
            document.getElementById('fileDropZone').classList.remove('loaded');
            eisData = { frequency: [], zReal: [], zImag: [], zMag: [], zPhase: [] };
            updateStatus('dataStatus', 'Data cleared', 'info');
            // Clear plots
            Plotly.purge('nyquistPlot');
            Plotly.purge('bodeMagnitudePlot');
            Plotly.purge('bodePhase');
            document.getElementById('fitResults').innerHTML = '';
        }

        function parseData() {
            const input = document.getElementById('dataInput').value.trim();
            const format = document.getElementById('dataFormat').value;

            if (!input) {
                updateStatus('dataStatus', 'No data entered. Paste data or upload a file.', 'error');
                return;
            }

            try {
                const lines = input.split('\n').filter(l => l.trim());
                eisData = { frequency: [], zReal: [], zImag: [], zMag: [], zPhase: [] };

                let skippedLines = 0;
                let headerSkipped = false;

                for (let line of lines) {
                    const parts = line.trim().split(/[\s\t,]+/).map(p => parseFloat(p));

                    // Skip header rows (non-numeric first value)
                    if (isNaN(parts[0])) {
                        if (!headerSkipped) {
                            headerSkipped = true;
                            continue;
                        }
                        skippedLines++;
                        continue;
                    }

                    // Validate we have enough columns
                    if (parts.length < 3) {
                        skippedLines++;
                        continue;
                    }

                    // Validate numeric values
                    if (parts.slice(0, 3).some(isNaN)) {
                        skippedLines++;
                        continue;
                    }

                    // Validate frequency is positive
                    if (parts[0] <= 0) {
                        skippedLines++;
                        continue;
                    }

                    if (format === 'zreal_zimag') {
                        // Format: frequency, zReal, zImag
                        eisData.frequency.push(parts[0]);
                        eisData.zReal.push(parts[1]);
                        eisData.zImag.push(parts[2]);
                    } else if (format === 'freq_zmag_phase') {
                        // Format: frequency, |Z|, phase (degrees)
                        eisData.frequency.push(parts[0]);
                        const mag = parts[1];
                        const phase = parts[2] * Math.PI / 180; // Convert to radians
                        eisData.zReal.push(mag * Math.cos(phase));
                        eisData.zImag.push(-mag * Math.sin(phase));
                    }
                }

                if (eisData.frequency.length === 0) {
                    updateStatus('dataStatus', 'No valid data found. Check format: Frequency, Z\' (or |Z|), Z" (or Phase)', 'error');
                    return;
                }

                // Calculate magnitude and phase
                eisData.zMag = eisData.zReal.map((r, i) => Math.sqrt(r*r + eisData.zImag[i]*eisData.zImag[i]));
                eisData.zPhase = eisData.zReal.map((r, i) => Math.atan2(-eisData.zImag[i], r) * 180 / Math.PI);

                let statusMsg = `Loaded ${eisData.frequency.length} data points`;
                if (skippedLines > 0) {
                    statusMsg += ` (${skippedLines} lines skipped)`;
                }
                updateStatus('dataStatus', statusMsg, 'success');
                plotNyquist();
                plotBode();
            } catch (e) {
                updateStatus('dataStatus', `Parse error: ${e.message}. Check data format.`, 'error');
                console.error('Parse error:', e);
            }
        }

        function fitModel() {
            if (eisData.frequency.length === 0) {
                updateStatus('fitStatus', 'No data loaded', 'error');
                return;
            }

            const modelType = document.getElementById('modelType').value;
            const omega = eisData.frequency.map(f => 2 * Math.PI * f);
            
            try {
                let fitParams, predicted;
                
                if (modelType === 'R') {
                    // Simple resistor
                    const avgR = eisData.zReal.reduce((a, b) => a + b) / eisData.zReal.length;
                    fitParams = { R: avgR };
                    predicted = eisData.frequency.map(() => ({ real: avgR, imag: 0 }));
                } 
                else if (modelType === 'RC') {
                    fitParams = fitRCModel(omega);
                    predicted = omega.map(w => predictRC(fitParams, w));
                }
                else if (modelType === 'RRC') {
                    fitParams = fitRRCModel(omega);
                    predicted = omega.map(w => predictRRC(fitParams, w));
                }
                else if (modelType === 'RCRC') {
                    fitParams = fitRCRCModel(omega);
                    predicted = omega.map(w => predictRCRC(fitParams, w));
                }

                const residuals = eisData.zReal.map((r, i) => ({
                    real: r - predicted[i].real,
                    imag: eisData.zImag[i] - predicted[i].imag
                }));

                const chiSquared = residuals.reduce((sum, r) => sum + r.real*r.real + r.imag*r.imag, 0) / eisData.zReal.length;

                displayFitResults(fitParams, chiSquared);
                plotFit(predicted);
            } catch (e) {
                updateStatus('fitStatus', `Fit error: ${e.message}`, 'error');
            }
        }

        function fitRCModel(omega) {
            // R-(R||C) model optimization (simplified)
            let bestParams = { R0: 100, R1: 100, C: 1e-6 };
            let bestError = Infinity;

            for (let R0 of [50, 100, 200]) {
                for (let R1 of [50, 100, 200]) {
                    for (let C of [1e-7, 1e-6, 1e-5]) {
                        let error = 0;
                        for (let i = 0; i < omega.length; i++) {
                            const pred = predictRC({ R: R0 + R1, C: C }, omega[i]);
                            error += Math.pow(eisData.zReal[i] - pred.real, 2) + Math.pow(eisData.zImag[i] - pred.imag, 2);
                        }
                        if (error < bestError) {
                            bestError = error;
                            bestParams = { R: R0 + R1, C: C };
                        }
                    }
                }
            }
            return bestParams;
        }

        function fitRRCModel(omega) {
            // R-(R||C) Randles model
            let best = { R0: 100, R1: 100, C: 1e-6 };
            let bestError = Infinity;

            for (let R0 of [50, 100, 200]) {
                for (let R1 of [50, 100, 200]) {
                    for (let C of [1e-8, 1e-7, 1e-6, 1e-5]) {
                        let error = 0;
                        for (let i = 0; i < omega.length; i++) {
                            const pred = predictRRC({ R0, R1, C }, omega[i]);
                            error += Math.pow(eisData.zReal[i] - pred.real, 2) + Math.pow(eisData.zImag[i] - pred.imag, 2);
                        }
                        if (error < bestError) {
                            bestError = error;
                            best = { R0, R1, C };
                        }
                    }
                }
            }
            return best;
        }

        function fitRCRCModel(omega) {
            // Two RC time constants - simplified
            let best = { R0: 50, R1: 100, C1: 1e-6, R2: 100, C2: 1e-5 };
            let bestError = Infinity;

            for (let C1 of [1e-7, 1e-6, 1e-5]) {
                for (let C2 of [1e-6, 1e-5, 1e-4]) {
                    let error = 0;
                    for (let i = 0; i < omega.length; i++) {
                        const pred = predictRCRC({ R0: 50, R1: 100, C1, R2: 100, C2 }, omega[i]);
                        error += Math.pow(eisData.zReal[i] - pred.real, 2) + Math.pow(eisData.zImag[i] - pred.imag, 2);
                    }
                    if (error < bestError) {
                        bestError = error;
                        best = { R0: 50, R1: 100, C1, R2: 100, C2 };
                    }
                }
            }
            return best;
        }

        function predictRC(params, omega) {
            // R-C series impedance: Z = R - i/(omega*C)
            return {
                real: params.R,
                imag: -1 / (omega * params.C)
            };
        }

        function predictRRC(params, omega) {
            // R0 + (R1 || (1/jœâC))
            const R1 = params.R1;
            const C = params.C;
            
            // Parallel: R || C impedance = R / (1 + jœâRC)
            const denom = 1 + Math.pow(omega * R1 * C, 2);
            const parReal = R1 / denom;
            const parImag = -(omega * R1 * R1 * C) / denom;
            
            return {
                real: params.R0 + parReal,
                imag: parImag
            };
        }

        function predictRCRC(params, omega) {
            // R0 + (R1 || C1) + (R2 || C2)
            const par1 = predictParallel(params.R1, params.C1, omega);
            const par2 = predictParallel(params.R2, params.C2, omega);
            
            return {
                real: params.R0 + par1.real + par2.real,
                imag: par1.imag + par2.imag
            };
        }

        function predictParallel(R, C, omega) {
            const denom = 1 + Math.pow(omega * R * C, 2);
            return {
                real: R / denom,
                imag: -(omega * R * R * C) / denom
            };
        }

        function displayFitResults(params, chiSquared) {
            let html = '<div class="results"><h3>Fitted Parameters</h3>';
            
            for (const [key, value] of Object.entries(params)) {
                let unit = '';
                if (key.includes('R')) unit = ' Œ©';
                else if (key.includes('C')) unit = ' F';
                
                const displayValue = Math.abs(value) < 0.001 ? value.toExponential(3) : value.toFixed(3);
                html += `<div class="result-row"><span class="result-label">${key}</span><span class="result-value">${displayValue}${unit}</span></div>`;
            }
            
            html += `<div class="result-row"><span class="result-label">œá¬≤/N</span><span class="result-value">${chiSquared.toExponential(3)}</span></div>`;
            html += '</div>';
            
            document.getElementById('fitResults').innerHTML = html;
            updateStatus('fitStatus', 'Fit completed', 'success');
        }

        function plotNyquist() {
            const trace = {
                x: eisData.zReal,
                y: eisData.zImag.map(z => -z),
                mode: 'markers+lines',
                name: 'EIS Data',
                marker: { size: 6, color: '#667eea' },
                line: { color: '#667eea', width: 2 }
            };

            const layout = {
                title: 'Nyquist Plot',
                xaxis: { title: "Z' (Œ©)" },
                yaxis: { title: "-Z\" (Œ©)" },
                hovermode: 'closest',
                margin: { t: 40, b: 40, l: 60, r: 20 }
            };

            Plotly.newPlot('nyquistPlot', [trace], layout, { responsive: true });
        }

        function plotBode() {
            const magTrace = {
                x: eisData.frequency,
                y: eisData.zMag,
                mode: 'lines+markers',
                name: '|Z|',
                line: { color: '#667eea' }
            };

            const phaseTrace = {
                x: eisData.frequency,
                y: eisData.zPhase,
                mode: 'lines+markers',
                name: 'Phase',
                line: { color: '#764ba2' }
            };

            const magLayout = {
                title: 'Impedance Magnitude',
                xaxis: { title: 'Frequency (Hz)', type: 'log' },
                yaxis: { title: '|Z| (Œ©)', type: 'log' },
                hovermode: 'x unified',
                margin: { t: 40, b: 40, l: 60, r: 20 }
            };

            const phaseLayout = {
                title: 'Phase Angle',
                xaxis: { title: 'Frequency (Hz)', type: 'log' },
                yaxis: { title: 'Phase (¬∞)' },
                hovermode: 'x unified',
                margin: { t: 40, b: 40, l: 60, r: 20 }
            };

            Plotly.newPlot('bodeMagnitudePlot', [magTrace], magLayout, { responsive: true });
            Plotly.newPlot('bodePhase', [phaseTrace], phaseLayout, { responsive: true });
        }

        function plotFit(predicted) {
            const nyquistData = [{
                x: eisData.zReal,
                y: eisData.zImag.map(z => -z),
                mode: 'markers',
                name: 'Experimental',
                marker: { size: 6, color: '#667eea' }
            }, {
                x: predicted.map(p => p.real),
                y: predicted.map(p => -p.imag),
                mode: 'lines',
                name: 'Fitted',
                line: { color: '#ff6b6b', width: 2, dash: 'dash' }
            }];

            const layout = {
                title: 'Nyquist Plot - Fit Overlay',
                xaxis: { title: "Z' (Œ©)" },
                yaxis: { title: "-Z\" (Œ©)" },
                hovermode: 'closest',
                margin: { t: 40, b: 40, l: 60, r: 20 }
            };

            Plotly.newPlot('nyquistPlot', nyquistData, layout, { responsive: true });
        }

        function runDebugTest() {
            const modelType = document.getElementById('debugModel').value;
            const noiseLevel = parseFloat(document.getElementById('noiseLevel').value) / 100;

            // Define true parameters for the test
            let trueParams;
            if (modelType === 'RRC') {
                trueParams = { R0: 75, R1: 150, C: 2.5e-6 };
            } else if (modelType === 'RCRC') {
                trueParams = { R0: 50, R1: 120, C1: 1.5e-6, R2: 80, C2: 8e-6 };
            }

            // Generate frequency range (log scale from 0.01 Hz to 10 kHz)
            const frequencies = [];
            for (let exp = -2; exp <= 4; exp += 0.25) {
                frequencies.push(Math.pow(10, exp));
            }

            // Generate ideal impedance data
            const mockData = [];
            for (const freq of frequencies) {
                const omega = 2 * Math.PI * freq;
                let z;

                if (modelType === 'RRC') {
                    z = predictRRC(trueParams, omega);
                } else if (modelType === 'RCRC') {
                    z = predictRCRC(trueParams, omega);
                }

                // Add noise
                const noiseFactor = 1 + (Math.random() - 0.5) * 2 * noiseLevel;
                const noiseFactorImag = 1 + (Math.random() - 0.5) * 2 * noiseLevel;

                mockData.push({
                    freq: freq,
                    zReal: z.real * noiseFactor,
                    zImag: z.imag * noiseFactorImag
                });
            }

            // Format as tab-separated data and load into textarea
            const dataStr = mockData.map(d => `${d.freq}\t${d.zReal.toFixed(4)}\t${d.zImag.toFixed(4)}`).join('\n');
            document.getElementById('dataInput').value = dataStr;
            document.getElementById('dataFormat').value = 'zreal_zimag';

            // Parse the data
            parseData();

            // Set the model type to match
            document.getElementById('modelType').value = modelType;

            // Fit the model
            const omega = eisData.frequency.map(f => 2 * Math.PI * f);
            let fitParams, predicted;

            if (modelType === 'RRC') {
                fitParams = fitRRCModel(omega);
                predicted = omega.map(w => predictRRC(fitParams, w));
            } else if (modelType === 'RCRC') {
                fitParams = fitRCRCModel(omega);
                predicted = omega.map(w => predictRCRC(fitParams, w));
            }

            // Calculate fit quality
            const residuals = eisData.zReal.map((r, i) => ({
                real: r - predicted[i].real,
                imag: eisData.zImag[i] - predicted[i].imag
            }));
            const chiSquared = residuals.reduce((sum, r) => sum + r.real*r.real + r.imag*r.imag, 0) / eisData.zReal.length;

            // Calculate parameter recovery accuracy
            const paramErrors = {};
            let totalError = 0;
            let paramCount = 0;

            for (const [key, trueValue] of Object.entries(trueParams)) {
                const fittedValue = fitParams[key];
                const percentError = Math.abs((fittedValue - trueValue) / trueValue) * 100;
                paramErrors[key] = {
                    true: trueValue,
                    fitted: fittedValue,
                    error: percentError
                };
                totalError += percentError;
                paramCount++;
            }

            const avgError = totalError / paramCount;
            const score = Math.max(0, 100 - avgError);

            // Display debug results
            let html = '<div class="results"><h3>üß™ Debug Test Results</h3>';
            html += `<div class="result-row" style="background: ${score >= 80 ? '#d4edda' : score >= 50 ? '#fff3cd' : '#f8d7da'}; padding: 10px; border-radius: 4px; margin-bottom: 10px;">`;
            html += `<span class="result-label" style="font-size: 1.1em;">Overall Score</span>`;
            html += `<span class="result-value" style="font-size: 1.2em; font-weight: bold;">${score.toFixed(1)}%</span></div>`;

            html += '<h4 style="margin-top: 15px; color: #555;">Parameter Recovery</h4>';
            html += '<table style="width: 100%; font-size: 0.85em; border-collapse: collapse;">';
            html += '<tr style="border-bottom: 2px solid #ddd;"><th style="text-align: left; padding: 5px;">Param</th><th>True</th><th>Fitted</th><th>Error</th></tr>';

            for (const [key, data] of Object.entries(paramErrors)) {
                const errorColor = data.error < 10 ? '#28a745' : data.error < 25 ? '#ffc107' : '#dc3545';
                const trueDisplay = data.true < 0.001 ? data.true.toExponential(2) : data.true.toFixed(2);
                const fittedDisplay = data.fitted < 0.001 ? data.fitted.toExponential(2) : data.fitted.toFixed(2);

                html += `<tr style="border-bottom: 1px solid #eee;">`;
                html += `<td style="padding: 5px; font-weight: 500;">${key}</td>`;
                html += `<td style="text-align: center; font-family: monospace;">${trueDisplay}</td>`;
                html += `<td style="text-align: center; font-family: monospace;">${fittedDisplay}</td>`;
                html += `<td style="text-align: center; color: ${errorColor}; font-weight: 500;">${data.error.toFixed(1)}%</td>`;
                html += `</tr>`;
            }
            html += '</table>';

            html += `<div class="result-row" style="margin-top: 10px;"><span class="result-label">œá¬≤/N</span><span class="result-value">${chiSquared.toExponential(3)}</span></div>`;
            html += `<div class="result-row"><span class="result-label">Noise Level</span><span class="result-value">${(noiseLevel * 100).toFixed(1)}%</span></div>`;
            html += `<div class="result-row"><span class="result-label">Data Points</span><span class="result-value">${frequencies.length}</span></div>`;
            html += '</div>';

            document.getElementById('fitResults').innerHTML = html;
            plotFit(predicted);

            const scoreEmoji = score >= 80 ? '‚úÖ' : score >= 50 ? '‚ö†Ô∏è' : '‚ùå';
            updateStatus('debugStatus', `${scoreEmoji} Test complete: ${score.toFixed(1)}% accuracy`, score >= 80 ? 'success' : score >= 50 ? 'info' : 'error');
        }

        function updateStatus(elementId, message, type) {
            const el = document.getElementById(elementId);
            el.className = `status ${type}`;
            el.textContent = message;
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Electrochemical Impedance Spectroscopy (EIS) data analysis tool with circuit model fitting, Nyquist plots, and Bode plots">
    <title>EIS Analyzer v1.0 - Circuit Model Fitting</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            text-align: center;
            position: relative;
        }
        header h1 { font-size: 1.8em; margin-bottom: 3px; }
        header p { opacity: 0.9; font-size: 0.85em; }
        .home-btn {
            position: absolute;
            top: 12px;
            left: 20px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.4);
            padding: 8px 16px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.9em;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background 0.2s, border-color 0.2s;
        }
        .home-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.6);
        }
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            padding: 20px;
        }
        .panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e0e0e0;
        }
        .panel h2 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }
        .form-group {
            margin-bottom: 10px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
            font-size: 0.9em;
        }
        select, textarea, input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }
        select:focus, textarea:focus, input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 5px rgba(102, 126, 234, 0.3);
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }
        button:hover { background: #764ba2; }
        button:active { transform: scale(0.98); }
        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .button-group button { flex: 1; }
        textarea {
            resize: vertical;
            min-height: 120px;
        }
        .results {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid #ddd;
        }
        .results h3 {
            color: #667eea;
            font-size: 1em;
            margin-bottom: 10px;
        }
        .result-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }
        .result-row:last-child { border-bottom: none; }
        .result-label { color: #666; font-weight: 500; }
        .result-value { color: #333; font-family: monospace; }
        .plot-container {
            width: 100%;
            height: 320px;
            min-height: 250px;
            border-radius: 8px;
            overflow: hidden;
        }
        .file-upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 15px;
        }
        .file-upload-area:hover, .file-upload-area.drag-over {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }
        .file-upload-area.loaded {
            border-color: #28a745;
            border-style: solid;
        }
        .file-upload-area input[type="file"] {
            display: none;
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
        .status {
            padding: 12px;
            border-radius: 4px;
            margin-top: 15px;
            font-size: 0.9em;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .full-width {
            grid-column: 1 / -1;
        }
        .two-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 1000px) {
            .content { grid-template-columns: 1fr; }
            .two-col { grid-template-columns: 1fr; }
            .plot-container { height: 350px; }
        }
        @media (max-width: 600px) {
            header h1 { font-size: 1.8em; }
            .content { padding: 15px; }
            .panel { padding: 15px; }
            .plot-container { height: 300px; }
        }
        /* Focus styles for accessibility */
        button:focus, select:focus, textarea:focus, input:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }
        .file-upload-area:focus-within {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }
        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .status.loading {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        /* Copy button */
        .copy-btn {
            background: #6c757d;
            font-size: 0.8em;
            padding: 5px 10px;
            margin-left: 10px;
        }
        .copy-btn:hover { background: #5a6268; }
        .copy-btn.copied {
            background: #28a745;
        }
        /* Residual plot container */
        .residual-container {
            height: 200px;
            min-height: 150px;
        }
        /* Export buttons */
        .export-btn-group {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .export-btn {
            background: #17a2b8;
            font-size: 0.85em;
            padding: 8px 12px;
            flex: 1;
            min-width: 80px;
        }
        .export-btn:hover { background: #138496; }
        .session-btn {
            background: #6c757d;
            font-size: 0.85em;
            padding: 8px 12px;
        }
        .session-btn:hover { background: #5a6268; }
        /* Frequency range inputs */
        .freq-range {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .freq-range input {
            width: 100px;
            padding: 6px;
        }
        .freq-range span {
            color: #666;
            font-size: 0.85em;
        }
        /* Model comparison table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
            margin-top: 10px;
        }
        .comparison-table th, .comparison-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .comparison-table th {
            background: #f8f9fa;
            font-weight: 600;
        }
        .comparison-table tr:hover {
            background: #f5f5f5;
        }
        .comparison-table .best {
            background: #d4edda;
        }
        .compare-btn {
            background: #fd7e14;
            margin-top: 10px;
        }
        .compare-btn:hover { background: #e96a00; }
        /* Data table */
        .data-table-container {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8em;
            font-family: monospace;
        }
        .data-table th {
            position: sticky;
            top: 0;
            background: #667eea;
            color: white;
            padding: 6px;
            text-align: right;
        }
        .data-table td {
            padding: 4px 6px;
            text-align: right;
            border-bottom: 1px solid #eee;
        }
        .data-table tr:nth-child(even) {
            background: #f9f9f9;
        }
        .toggle-btn {
            background: #6c757d;
            font-size: 0.8em;
            padding: 6px 10px;
        }
        /* Settings Menu */
        .settings-btn {
            position: absolute;
            top: 12px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.4);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.2s;
        }
        .settings-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: rotate(30deg);
        }
        .settings-menu {
            position: absolute;
            top: 55px;
            right: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            min-width: 200px;
            display: none;
            z-index: 1000;
            overflow: hidden;
        }
        .settings-menu.open {
            display: block;
        }
        .settings-menu-item {
            padding: 12px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #333;
            font-size: 0.9em;
            border-bottom: 1px solid #eee;
            transition: background 0.15s;
        }
        .settings-menu-item:last-child {
            border-bottom: none;
        }
        .settings-menu-item:hover {
            background: #f5f5f5;
        }
        .settings-menu-item .icon {
            font-size: 1.1em;
        }
        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .modal-overlay.open {
            display: flex;
        }
        .modal {
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 10px 10px 0 0;
        }
        .modal-header h2 {
            margin: 0;
            font-size: 1.2em;
        }
        .modal-close {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-close:hover {
            background: rgba(255,255,255,0.3);
        }
        .modal-body {
            padding: 20px;
        }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;z-index:9999;padding:1rem;background:#667eea;color:white;text-decoration:none;font-weight:bold;border-radius:4px;">Skip to main content</a>
    <style>.skip-link:focus{position:fixed;left:50%;transform:translateX(-50%);top:10px;width:auto;height:auto;overflow:visible;}</style>
    <noscript>
        <div style="padding: 2rem; text-align: center; background: #fee2e2; color: #991b1b; font-family: sans-serif;">
            <h2>JavaScript Required</h2>
            <p>The EIS Analyzer requires JavaScript to be enabled. Please enable JavaScript in your browser settings and reload the page.</p>
        </div>
    </noscript>
    <div class="container">
        <header>
            <a href="../index.html" class="home-btn">‚Üê Home</a>
            <h1>‚ö° EIS Analyzer</h1>
            <p>Electrochemical Impedance Spectroscopy Data Analysis & Circuit Model Fitting</p>
            <span style="font-size: 0.75em; opacity: 0.7;">v1.0</span>
            <button class="settings-btn" onclick="toggleSettingsMenu()" title="Settings">‚öô</button>
            <div id="settingsMenu" class="settings-menu">
                <div class="settings-menu-item" onclick="openDebugModal()">
                    <span class="icon">üß™</span>
                    <span>Debug Tools</span>
                </div>
                <div class="settings-menu-item" onclick="toggleSettingsMenu()">
                    <span class="icon">‚ùå</span>
                    <span>Close Menu</span>
                </div>
            </div>
        </header>

        <main id="main-content" class="content" role="main">
            <!-- Input Panel -->
            <div class="panel" role="region" aria-labelledby="data-input-heading">
                <h2 id="data-input-heading">üìä Data Input</h2>

                <!-- File Upload Area -->
                <div class="file-upload-area" id="fileDropZone" role="button" tabindex="0" aria-label="Upload CSV or TXT file with EIS data">
                    <div>üìÅ Drop file here or click to upload</div>
                    <div style="font-size: 0.85em; color: #666; margin-top: 5px;">Supports CSV, TXT (tab/space separated)</div>
                    <div style="font-size: 0.75em; color: #999; margin-top: 3px;">Recommended: files under 5MB for best performance</div>
                    <input type="file" id="fileInput" accept=".csv,.txt,.tsv" aria-label="File upload input">
                    <div id="fileStatus" style="margin-top: 10px; color: #28a745;"></div>
                </div>

                <div class="form-group">
                    <label for="dataInput">Paste Data (tab or space separated)</label>
                    <textarea id="dataInput" aria-describedby="data-format-hint" placeholder="Frequency	Z_real	Z_imag
0.01	1000	-500
0.1	950	-480
...

Format auto-detected: Z'/Z&quot; or |Z|/Phase"></textarea>
                    <small id="data-format-hint" style="color: #666; font-size: 0.8em;">Data format auto-detected. Parses automatically when pasted.</small>
                </div>

                <div id="dataStatus" role="status" aria-live="polite"></div>

                <!-- Data Table Toggle -->
                <div style="margin-top: 10px;">
                    <button type="button" class="toggle-btn" onclick="toggleDataTable()">Show Data Table</button>
                </div>
                <div id="dataTableContainer" class="data-table-container" style="display: none;"></div>

                <h2 id="circuit-model-heading" style="margin-top: 30px;">‚öôÔ∏è Circuit Model</h2>

                <div class="form-group">
                    <label for="modelType">Select Model</label>
                    <select id="modelType" aria-describedby="model-help">
                        <option value="auto">üîç Auto (Best Fit)</option>
                        <option value="R">R (Resistor only)</option>
                        <option value="RC">R-C (Series)</option>
                        <option value="RpC">R||C (Parallel)</option>
                        <option value="RRC">R-(R||C) (Randles)</option>
                        <option value="RRCW">R-(R||C)-W (Randles + Warburg)</option>
                        <option value="RCRC">R-(R||C)-(R||C) (Two RC)</option>
                        <option value="RRCRC">R-(R||C)-(R||C)-(R||C) (Three RC)</option>
                        <option value="CPE">R-(R||CPE) (Constant Phase Element)</option>
                        <option value="CPEW">R-(R||CPE)-W (CPE + Warburg)</option>
                        <option value="CPECPE">R-(R||CPE)-(R||CPE) (Two CPE)</option>
                        <option value="CPECPEW">R-(R||CPE)-(R||CPE)-W (Two CPE + Warburg)</option>
                        <option value="CPEpCPE">R-(R||CPE)||(R||CPE) (Parallel CPE)</option>
                    </select>
                    <small id="model-help" style="color: #666; font-size: 0.8em;">Choose a circuit model or use Auto to find the best fit</small>
                </div>

                <div class="form-group">
                    <label>Frequency Range (optional)</label>
                    <div class="freq-range">
                        <input type="number" id="freqMin" placeholder="Min Hz" min="0" step="any">
                        <span>to</span>
                        <input type="number" id="freqMax" placeholder="Max Hz" min="0" step="any">
                        <button type="button" onclick="resetFreqRange()" style="padding: 6px 10px; font-size: 0.8em;">Reset</button>
                    </div>
                    <small style="color: #666; font-size: 0.8em;">Limit fitting to a frequency range (leave empty for all data)</small>
                </div>

                <button type="button" onclick="fitModel()" style="width: 100%; background: #28a745;">Fit Model</button>
                <button type="button" class="compare-btn" onclick="compareAllModels()" style="width: 100%;">Compare All Models</button>
                <div id="fitStatus" role="status" aria-live="polite"></div>

                <!-- Model Comparison Results -->
                <div id="comparisonPanel" style="display: none; margin-top: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h3 style="font-size: 1em; color: #333; margin: 0;">Model Comparison</h3>
                        <button type="button" onclick="hideComparison()" style="padding: 4px 10px; font-size: 0.8em; background: #6c757d;">Hide</button>
                    </div>
                    <div id="comparisonResults"></div>
                </div>

                <h2 id="session-heading" style="margin-top: 15px;">üíæ Session</h2>
                <div class="button-group">
                    <button type="button" class="session-btn" onclick="saveSession()">Save Session</button>
                    <button type="button" class="session-btn" onclick="document.getElementById('loadSessionInput').click()">Load Session</button>
                    <input type="file" id="loadSessionInput" accept=".json" style="display: none;" onchange="loadSession(event)">
                </div>
                <small style="color: #666; font-size: 0.8em;">Save/load complete analysis state including data, model, and fit results</small>
            </div>

            <!-- Results Panel -->
            <div class="panel" role="region" aria-labelledby="results-heading">
                <h2 id="results-heading">üìà Fit Results</h2>
                <div id="fitResults" aria-live="polite"></div>
                <div id="exportButtons" style="display: none;">
                    <div class="export-btn-group">
                        <button type="button" class="export-btn" onclick="exportJSON()">Export JSON</button>
                        <button type="button" class="export-btn" onclick="exportCSV()">Export CSV</button>
                    </div>
                </div>
            </div>

            <!-- Nyquist Plot -->
            <div class="panel full-width" role="region" aria-labelledby="nyquist-heading">
                <h2 id="nyquist-heading">Nyquist Plot (Z' vs -Z")</h2>
                <div id="nyquistPlot" class="plot-container" role="img" aria-label="Nyquist plot showing real vs imaginary impedance"></div>
            </div>

            <!-- Bode Plot -->
            <div class="panel full-width" role="region" aria-labelledby="bode-heading">
                <h2 id="bode-heading">Bode Plot</h2>
                <div class="two-col">
                    <div id="bodeMagnitudePlot" class="plot-container" role="img" aria-label="Bode magnitude plot showing impedance vs frequency"></div>
                    <div id="bodePhase" class="plot-container" role="img" aria-label="Bode phase plot showing phase angle vs frequency"></div>
                </div>
            </div>

            <!-- Residual Plot (shown after fitting) -->
            <div class="panel full-width" role="region" aria-labelledby="residual-heading" id="residualPanel" style="display: none;">
                <h2 id="residual-heading">Residuals (Fit Error)</h2>
                <div class="two-col">
                    <div id="residualRealPlot" class="residual-container" role="img" aria-label="Real impedance residuals vs frequency"></div>
                    <div id="residualImagPlot" class="residual-container" role="img" aria-label="Imaginary impedance residuals vs frequency"></div>
                </div>
            </div>
        </main>
    </div>

    <!-- Debug Modal -->
    <div id="debugModal" class="modal-overlay" onclick="closeDebugModalOnOverlay(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2>üß™ Debug Tools</h2>
                <button class="modal-close" onclick="closeDebugModal()">√ó</button>
            </div>
            <div class="modal-body">
                <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">
                    Test the fitting algorithm with synthetic data to verify accuracy.
                </p>
                <div class="form-group">
                    <label for="debugModel">Test Model</label>
                    <select id="debugModel">
                        <option value="RRC">R-(R||C) (Randles)</option>
                        <option value="RRCW">R-(R||C)-W (Randles + Warburg)</option>
                        <option value="RCRC">R-(R||C)-(R||C) (Two RC)</option>
                        <option value="RRCRC">R-(R||C)-(R||C)-(R||C) (Three RC)</option>
                        <option value="CPE">R-(R||CPE) (Constant Phase Element)</option>
                        <option value="CPEW">R-(R||CPE)-W (CPE + Warburg)</option>
                        <option value="CPECPE">R-(R||CPE)-(R||CPE) (Two CPE)</option>
                        <option value="CPECPEW">R-(R||CPE)-(R||CPE)-W (Two CPE + Warburg)</option>
                        <option value="CPEpCPE">R-(R||CPE)||(R||CPE) (Parallel CPE)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="noiseLevel">Noise Level (%)</label>
                    <input type="number" id="noiseLevel" value="2" min="0" max="20" step="0.5">
                    <small style="color: #666; font-size: 0.8em;">Add random noise to simulate real measurement conditions</small>
                </div>
                <button type="button" onclick="runDebugTest()" style="width: 100%; background: #6c757d; color: white; padding: 10px; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px;">
                    Run Debug Test
                </button>
                <div id="debugStatus" role="status" aria-live="polite" style="margin-top: 15px;"></div>
            </div>
        </div>
    </div>

    <script>
        // Global error handler for unhandled errors
        window.onerror = function(message, source, lineno, colno, error) {
            console.error('Unhandled error:', message, 'at', source, lineno);
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#fee2e2;border:1px solid #ef4444;color:#991b1b;padding:1rem;border-radius:8px;z-index:10000;max-width:90%;';
            errorDiv.innerHTML = '<strong>An error occurred:</strong> ' + message + '<br><button onclick="this.parentElement.remove()" style="margin-top:0.5rem;padding:4px 8px;cursor:pointer;">Dismiss</button>';
            document.body.appendChild(errorDiv);
            return false;
        };

        // Global data storage
        let eisData = {
            frequency: [],
            zReal: [],
            zImag: [],
            zMag: [],
            zPhase: []
        };

        // Initialize file upload and auto-parse functionality
        document.addEventListener('DOMContentLoaded', function() {
            initFileUpload();
            initAutoParse();
        });

        function initAutoParse() {
            const dataInput = document.getElementById('dataInput');
            let parseTimeout;

            // Auto-parse when data is pasted or typed (with debounce)
            dataInput.addEventListener('input', () => {
                clearTimeout(parseTimeout);
                parseTimeout = setTimeout(() => {
                    if (dataInput.value.trim()) {
                        parseData();
                    }
                }, 500); // 500ms debounce
            });
        }

        function initFileUpload() {
            const dropZone = document.getElementById('fileDropZone');
            const fileInput = document.getElementById('fileInput');

            // Click to upload
            dropZone.addEventListener('click', () => fileInput.click());

            // Keyboard accessibility
            dropZone.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    fileInput.click();
                }
            });

            // Drag and drop
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                const file = e.dataTransfer.files[0];
                if (file) handleFileUpload(file);
            });

            // File input change
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) handleFileUpload(file);
            });
        }

        function handleFileUpload(file) {
            const status = document.getElementById('fileStatus');
            const dropZone = document.getElementById('fileDropZone');

            // Validate file type
            const validTypes = ['.csv', '.txt', '.tsv'];
            const ext = '.' + file.name.split('.').pop().toLowerCase();
            if (!validTypes.includes(ext)) {
                status.textContent = 'Error: Please upload CSV or TXT file';
                status.style.color = '#dc3545';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById('dataInput').value = e.target.result;
                status.textContent = `‚úì Loaded: ${file.name}`;
                status.style.color = '#28a745';
                dropZone.classList.add('loaded');
                parseData();
            };
            reader.onerror = () => {
                status.textContent = 'Error reading file';
                status.style.color = '#dc3545';
            };
            reader.readAsText(file);
        }

        function parseData() {
            const input = document.getElementById('dataInput').value.trim();

            if (!input) {
                updateStatus('dataStatus', 'No data entered. Paste data or upload a file.', 'error');
                return;
            }

            try {
                const lines = input.split('\n').filter(l => l.trim());
                eisData = { frequency: [], zReal: [], zImag: [], zMag: [], zPhase: [] };

                let skippedLines = 0;
                let headerSkipped = false;

                // First pass: collect raw data to detect format
                const rawData = [];
                for (let line of lines) {
                    const parts = line.trim().split(/[\s\t,]+/).map(p => parseFloat(p));
                    if (isNaN(parts[0])) {
                        if (!headerSkipped) headerSkipped = true;
                        continue;
                    }
                    if (parts.length >= 3 && !parts.slice(0, 3).some(isNaN) && parts[0] > 0) {
                        rawData.push(parts);
                    } else {
                        skippedLines++;
                    }
                }

                if (rawData.length === 0) {
                    updateStatus('dataStatus', 'No valid data found. Expected: Frequency, Z\'/|Z|, Z"/Phase', 'error');
                    return;
                }

                // Auto-detect format by comparing column 2 (Z' or |Z|) and column 3 (Z" or Phase)
                const col2Values = rawData.map(r => r[1]);
                const col3Values = rawData.map(r => r[2]);
                const col2Avg = col2Values.reduce((a, b) => a + b, 0) / col2Values.length;
                const col3Avg = col3Values.reduce((a, b) => a + b, 0) / col3Values.length;
                const col3Max = Math.max(...col3Values.map(Math.abs));
                const col2Max = Math.max(...col2Values);

                // Heuristics to distinguish formats:
                // 1. Phase angles: typically -90 to 0 degrees for capacitive, bounded by ¬±90
                // 2. For |Z|/Phase: |Z| >> |Phase| (impedance magnitude much larger than phase angle)
                // 3. For Z'/Z": Z' and Z" are similar magnitude (both in ohms), Z" typically all same sign
                const col3InPhaseRange = col3Max <= 90;
                const magnitudeRatio = col2Avg / Math.max(col3Max, 0.1);

                // Additional heuristics for better detection:
                // - For Z"/ohms data: values are typically ALL negative (capacitive) or rarely all positive
                // - For Phase/degrees: values vary but stay within -90 to 0 for capacitive elements
                // - Check if col3 values are predominantly negative (suggests Z" in ohms)
                const negativeCount = col3Values.filter(v => v < 0).length;
                const mostlyNegative = negativeCount > col3Values.length * 0.7;

                // If col3 is in phase range AND col2 is much larger than col3 AND not mostly negative, it's likely |Z|/Phase
                // If col3 values are mostly negative OR similar magnitude to col2, it's likely Z'/Z"
                const looksLikePhase = col3InPhaseRange && magnitudeRatio > 3 && !mostlyNegative;
                const format = looksLikePhase ? 'freq_zmag_phase' : 'zreal_zimag';

                // Parse data according to detected format
                for (const parts of rawData) {
                    if (format === 'zreal_zimag') {
                        eisData.frequency.push(parts[0]);
                        eisData.zReal.push(parts[1]);
                        eisData.zImag.push(parts[2]);
                    } else {
                        // freq_zmag_phase
                        eisData.frequency.push(parts[0]);
                        const mag = parts[1];
                        const phase = parts[2] * Math.PI / 180;
                        eisData.zReal.push(mag * Math.cos(phase));
                        eisData.zImag.push(-mag * Math.sin(phase));
                    }
                }

                // Calculate magnitude and phase
                eisData.zMag = eisData.zReal.map((r, i) => Math.sqrt(r*r + eisData.zImag[i]*eisData.zImag[i]));
                eisData.zPhase = eisData.zReal.map((r, i) => Math.atan2(-eisData.zImag[i], r) * 180 / Math.PI);

                const formatName = format === 'zreal_zimag' ? "Z'/Z\"" : "|Z|/Phase";
                let statusMsg = `Loaded ${eisData.frequency.length} points (${formatName} format)`;
                if (skippedLines > 0) {
                    statusMsg += ` (${skippedLines} skipped)`;
                }
                updateStatus('dataStatus', statusMsg, 'success');
                plotNyquist();
                plotBode();
            } catch (e) {
                updateStatus('dataStatus', `Parse error: ${e.message}. Check data format.`, 'error');
                console.error('Parse error:', e);
            }
        }

        // Model registry for easy lookup
        const modelRegistry = {
            'R': { name: 'R (Resistor)', fit: fitRModel, predict: predictR, params: 1 },
            'RC': { name: 'R-C (Series)', fit: fitRCModel, predict: predictRC, params: 2 },
            'RpC': { name: 'R||C (Parallel)', fit: fitRpCModel, predict: predictRpC, params: 2 },
            'RRC': { name: 'R-(R||C) (Randles)', fit: fitRRCModel, predict: predictRRC, params: 3 },
            'RRCW': { name: 'R-(R||C)-W (Randles+Warburg)', fit: fitRRCWModel, predict: predictRRCW, params: 4 },
            'RCRC': { name: 'R-(R||C)-(R||C) (Two RC)', fit: fitRCRCModel, predict: predictRCRC, params: 5 },
            'RRCRC': { name: 'R-(R||C)-(R||C)-(R||C) (Three RC)', fit: fitRRCRCModel, predict: predictRRCRC, params: 7 },
            'CPE': { name: 'R-(R||CPE)', fit: fitCPEModel, predict: predictCPE, params: 4 },
            'CPEW': { name: 'R-(R||CPE)-W (CPE+Warburg)', fit: fitCPEWModel, predict: predictCPEW, params: 5 },
            'CPECPE': { name: 'R-(R||CPE)-(R||CPE) (Two CPE)', fit: fitCPECPEModel, predict: predictCPECPE, params: 7 },
            'CPECPEW': { name: 'R-(R||CPE)-(R||CPE)-W (Two CPE+Warburg)', fit: fitCPECPEWModel, predict: predictCPECPEW, params: 8 },
            'CPEpCPE': { name: 'R-(R||CPE)||(R||CPE) (Parallel CPE)', fit: fitCPEpCPEModel, predict: predictCPEpCPE, params: 7 }
        };

        // Store last fit results for export
        let lastFitResults = null;

        // Store filtered data for fitting
        let filteredData = null;

        function getFilteredData() {
            const freqMinInput = document.getElementById('freqMin').value;
            const freqMaxInput = document.getElementById('freqMax').value;
            const freqMin = freqMinInput ? parseFloat(freqMinInput) : 0;
            const freqMax = freqMaxInput ? parseFloat(freqMaxInput) : Infinity;

            // Create filtered arrays
            const indices = [];
            for (let i = 0; i < eisData.frequency.length; i++) {
                if (eisData.frequency[i] >= freqMin && eisData.frequency[i] <= freqMax) {
                    indices.push(i);
                }
            }

            return {
                frequency: indices.map(i => eisData.frequency[i]),
                zReal: indices.map(i => eisData.zReal[i]),
                zImag: indices.map(i => eisData.zImag[i]),
                zMag: indices.map(i => eisData.zMag[i]),
                zPhase: indices.map(i => eisData.zPhase[i]),
                indices: indices
            };
        }

        function resetFreqRange() {
            document.getElementById('freqMin').value = '';
            document.getElementById('freqMax').value = '';
        }

        function fitModel() {
            if (eisData.frequency.length === 0) {
                updateStatus('fitStatus', 'No data loaded', 'error');
                return;
            }

            // Show loading spinner
            const fitStatus = document.getElementById('fitStatus');
            fitStatus.className = 'status loading';
            fitStatus.innerHTML = '<span class="spinner"></span>Fitting model...';

            // Use setTimeout to allow UI to update before blocking computation
            setTimeout(() => {
                let modelType = document.getElementById('modelType').value;

                // Get filtered data based on frequency range
                filteredData = getFilteredData();

                if (filteredData.frequency.length === 0) {
                    updateStatus('fitStatus', 'No data in selected frequency range', 'error');
                    return;
                }

                const omega = filteredData.frequency.map(f => 2 * Math.PI * f);

                try {
                    let fitParams, predicted, selectedModel;

                    if (modelType === 'auto') {
                        // Auto-select best model
                        const result = autoSelectModel(omega);
                        modelType = result.modelType;
                        fitParams = result.fitParams;
                        predicted = result.predicted;
                        selectedModel = modelRegistry[modelType].name;
                        updateStatus('fitStatus', `Auto-selected: ${selectedModel}`, 'success');
                    } else {
                        const model = modelRegistry[modelType];
                        fitParams = model.fit(omega);
                        predicted = omega.map(w => model.predict(fitParams, w));
                        selectedModel = model.name;
                    }

                    const chiSquared = calcChiSquared(predicted);

                    // Store results for export
                    lastFitResults = {
                        model: selectedModel,
                        params: fitParams,
                        chiSquared: chiSquared,
                        predicted: predicted
                    };

                    displayFitResults(fitParams, chiSquared, selectedModel);
                    plotFit(predicted);
                    plotBodeFit(predicted);
                    plotResiduals(predicted);
                } catch (e) {
                    updateStatus('fitStatus', `Fit error: ${e.message}`, 'error');
                    console.error('Fit error:', e);
                }
            }, 10);
        }

        function autoSelectModel(omega) {
            // Use filtered data if available
            const dataSource = filteredData || eisData;
            const modelsToTry = ['RRC', 'RCRC', 'RRCW', 'CPE', 'CPECPE', 'CPEpCPE', 'RRCRC', 'RpC', 'RC'];
            let bestModel = null;
            let bestAIC = Infinity;
            let bestParams = null;
            let bestPredicted = null;

            for (const modelType of modelsToTry) {
                try {
                    const model = modelRegistry[modelType];
                    const fitParams = model.fit(omega, dataSource);
                    const predicted = omega.map(w => model.predict(fitParams, w));

                    // Validate predicted array has valid values
                    if (!predicted || predicted.length === 0 || !predicted[0] || typeof predicted[0].real === 'undefined') {
                        console.warn(`Model ${modelType} returned invalid predictions`);
                        continue;
                    }

                    // Calculate AIC (Akaike Information Criterion) for model comparison
                    // AIC = n * ln(RSS/n) + 2k, where k is number of parameters
                    // Use the minimum length to avoid index out of bounds
                    const len = Math.min(dataSource.zReal.length, predicted.length);
                    let rss = 0;
                    for (let i = 0; i < len; i++) {
                        if (predicted[i] && typeof predicted[i].real !== 'undefined') {
                            rss += Math.pow(dataSource.zReal[i] - predicted[i].real, 2) +
                                   Math.pow(dataSource.zImag[i] - predicted[i].imag, 2);
                        }
                    }
                    const n = len * 2; // Real + Imag points
                    const k = model.params;
                    const aic = n * Math.log(rss / n) + 2 * k;

                    if (aic < bestAIC) {
                        bestAIC = aic;
                        bestModel = modelType;
                        bestParams = fitParams;
                        bestPredicted = predicted;
                    }
                } catch (e) {
                    console.warn(`Model ${modelType} failed:`, e.message);
                }
            }

            return {
                modelType: bestModel,
                fitParams: bestParams,
                predicted: bestPredicted,
                aic: bestAIC
            };
        }

        function calcChiSquared(predicted) {
            // Use filtered data if available
            const dataSource = filteredData || eisData;
            const residuals = dataSource.zReal.map((r, i) => ({
                real: r - predicted[i].real,
                imag: dataSource.zImag[i] - predicted[i].imag
            }));
            return residuals.reduce((sum, r) => sum + r.real*r.real + r.imag*r.imag, 0) / dataSource.zReal.length;
        }

        // Simple R model
        function fitRModel(omega) {
            const avgR = eisData.zReal.reduce((a, b) => a + b) / eisData.zReal.length;
            return { R: avgR };
        }
        function predictR(params, omega) {
            return { real: params.R, imag: 0 };
        }

        function fitRCModel(omega) {
            // Estimate initial parameters from data
            const R_est = Math.max(...eisData.zReal);
            const C_est = estimateCapacitance(omega);

            // Use iterative refinement
            return nelderMead(
                (params) => calcError(params, omega, predictRC),
                { R: R_est, C: C_est },
                { R: R_est * 0.3, C: C_est * 0.5 }
            );
        }

        function fitRRCModel(omega) {
            // Estimate initial parameters from data characteristics
            const R0_est = Math.min(...eisData.zReal); // High frequency intercept
            const R_total = Math.max(...eisData.zReal);
            const R1_est = R_total - R0_est;
            const C_est = estimateCapacitance(omega);

            return nelderMead(
                (params) => calcError(params, omega, predictRRC),
                { R0: R0_est, R1: R1_est, C: C_est },
                { R0: R0_est * 0.3, R1: R1_est * 0.3, C: C_est * 0.5 }
            );
        }

        function fitRCRCModel(omega) {
            // Estimate from data
            const R0_est = Math.min(...eisData.zReal);
            const R_total = Math.max(...eisData.zReal);
            const R1_est = (R_total - R0_est) * 0.6;
            const R2_est = (R_total - R0_est) * 0.4;
            const C_est = estimateCapacitance(omega);

            return nelderMead(
                (params) => calcError(params, omega, predictRCRC),
                { R0: R0_est, R1: R1_est, C1: C_est, R2: R2_est, C2: C_est * 5 },
                { R0: R0_est * 0.3, R1: R1_est * 0.3, C1: C_est * 0.5, R2: R2_est * 0.3, C2: C_est * 2 }
            );
        }

        // Parallel R||C model
        function fitRpCModel(omega) {
            const R_est = Math.max(...eisData.zReal);
            const C_est = estimateCapacitance(omega);
            return nelderMead(
                (params) => calcError(params, omega, predictRpC),
                { R: R_est, C: C_est },
                { R: R_est * 0.3, C: C_est * 0.5 }
            );
        }
        function predictRpC(params, omega) {
            const denom = 1 + Math.pow(omega * params.R * params.C, 2);
            return {
                real: params.R / denom,
                imag: -(omega * params.R * params.R * params.C) / denom
            };
        }

        // Randles with Warburg: R0 + (R1 || C) + W
        function fitRRCWModel(omega) {
            const R0_est = Math.min(...eisData.zReal);
            const R_total = Math.max(...eisData.zReal);
            const R1_est = (R_total - R0_est) * 0.5;
            const C_est = estimateCapacitance(omega);
            const W_est = (R_total - R0_est) * 0.3;

            return nelderMead(
                (params) => calcError(params, omega, predictRRCW),
                { R0: R0_est, R1: R1_est, C: C_est, W: W_est },
                { R0: R0_est * 0.3, R1: R1_est * 0.3, C: C_est * 0.5, W: W_est * 0.5 }
            );
        }
        function predictRRCW(params, omega) {
            // R0 + parallel(R1, C) + Warburg
            const denom = 1 + Math.pow(omega * params.R1 * params.C, 2);
            const parReal = params.R1 / denom;
            const parImag = -(omega * params.R1 * params.R1 * params.C) / denom;
            // Warburg: Z_w = W/sqrt(omega) * (1 - j)
            const warburgFactor = params.W / Math.sqrt(omega);
            return {
                real: params.R0 + parReal + warburgFactor,
                imag: parImag - warburgFactor
            };
        }

        // Three RC model: R0 + (R1||C1) + (R2||C2) + (R3||C3)
        // Uses multi-start optimization due to 7 parameters
        function fitRRCRCModel(omega) {
            // Use improved R0 and R_total estimation
            const R0_est = estimateR0();
            const R_total = estimateRTotal();
            const R_range = Math.max(R_total - R0_est, 10);

            // Estimate characteristic frequencies from impedance data
            const charFreqs = estimateCharacteristicFrequencies(omega, 3);
            const R_avg = R_range / 3;
            const C_estimates = charFreqs.map(f => 1 / (2 * Math.PI * f * Math.max(R_avg, 1)));
            const C_est = estimateCapacitance(omega);

            // Expanded starting configurations for better coverage
            const startConfigs = [
                // Based on estimated characteristic frequencies
                { C1: C_estimates[0] || C_est * 0.1, C2: C_estimates[1] || C_est, C3: C_estimates[2] || C_est * 10, R1: R_range * 0.42, R2: R_range * 0.33, R3: R_range * 0.25 },
                // Typical EIS patterns (high freq to low freq: smaller to larger C)
                { C1: 5e-7, C2: 3e-6, C3: 2e-5, R1: R_range * 0.42, R2: R_range * 0.33, R3: R_range * 0.25 },
                { C1: 1e-7, C2: 1e-6, C3: 1e-5, R1: R_range * 0.4, R2: R_range * 0.35, R3: R_range * 0.25 },
                { C1: 3e-7, C2: 2e-6, C3: 1.5e-5, R1: R_range * 0.45, R2: R_range * 0.3, R3: R_range * 0.25 },
                // Different R distributions
                { C1: C_est * 0.1, C2: C_est, C3: C_est * 10, R1: R_range * 0.5, R2: R_range * 0.3, R3: R_range * 0.2 },
                { C1: C_est * 0.05, C2: C_est * 0.5, C3: C_est * 5, R1: R_range * 0.35, R2: R_range * 0.35, R3: R_range * 0.3 },
                // Log-spaced C values
                { C1: C_est * 0.01, C2: C_est * 0.1, C3: C_est, R1: R_range * 0.4, R2: R_range * 0.33, R3: R_range * 0.27 },
                { C1: C_est * 0.02, C2: C_est * 0.3, C3: C_est * 4, R1: R_range * 0.38, R2: R_range * 0.35, R3: R_range * 0.27 },
                // Narrower C spread
                { C1: C_est * 0.2, C2: C_est * 0.8, C3: C_est * 3, R1: R_range * 0.4, R2: R_range * 0.35, R3: R_range * 0.25 },
                // Reverse ordering
                { C1: C_est * 10, C2: C_est, C3: C_est * 0.1, R1: R_range * 0.25, R2: R_range * 0.35, R3: R_range * 0.4 },
                // Very small C1
                { C1: 1e-8, C2: 5e-7, C3: 5e-6, R1: R_range * 0.4, R2: R_range * 0.35, R3: R_range * 0.25 },
                { C1: 2e-8, C2: 2e-7, C3: 2e-6, R1: R_range * 0.42, R2: R_range * 0.33, R3: R_range * 0.25 },
            ];

            let bestParams = null;
            let bestError = Infinity;

            for (const config of startConfigs) {
                const initial = {
                    R0: R0_est,
                    R1: config.R1,
                    C1: config.C1,
                    R2: config.R2,
                    C2: config.C2,
                    R3: config.R3,
                    C3: config.C3
                };

                const steps = {
                    R0: Math.max(R0_est * 0.3, 5),
                    R1: initial.R1 * 0.4,
                    C1: initial.C1 * 0.5,
                    R2: initial.R2 * 0.4,
                    C2: initial.C2 * 0.5,
                    R3: initial.R3 * 0.4,
                    C3: initial.C3 * 0.5
                };

                try {
                    // Use log-space optimization for capacitance parameters
                    const params = nelderMeadLogSpace(
                        (p) => calcError(p, omega, predictRRCRC),
                        initial,
                        ['C1', 'C2', 'C3'],
                        steps,
                        2000
                    );
                    const error = calcError(params, omega, predictRRCRC);
                    if (error < bestError) {
                        bestError = error;
                        bestParams = params;
                    }
                } catch (e) {
                    console.warn('Three RC fit attempt failed:', e);
                }
            }

            return bestParams || {
                R0: R0_est, R1: R_range * 0.4, C1: C_est * 0.1,
                R2: R_range * 0.35, C2: C_est, R3: R_range * 0.25, C3: C_est * 10
            };
        }

        // Estimate multiple characteristic frequencies from peaks/inflections in -Z"
        function estimateCharacteristicFrequencies(omega, numFreqs) {
            const negZimag = eisData.zImag.map(z => -z);
            const freqs = [];

            // Find local maxima in -Z"
            for (let i = 1; i < negZimag.length - 1; i++) {
                if (negZimag[i] > negZimag[i-1] && negZimag[i] > negZimag[i+1]) {
                    freqs.push(omega[i] / (2 * Math.PI));
                }
            }

            // If not enough peaks found, estimate from frequency range
            if (freqs.length < numFreqs) {
                const minFreq = Math.min(...omega) / (2 * Math.PI);
                const maxFreq = Math.max(...omega) / (2 * Math.PI);
                const logRange = Math.log10(maxFreq / minFreq);
                for (let i = freqs.length; i < numFreqs; i++) {
                    const logF = Math.log10(minFreq) + logRange * (i + 1) / (numFreqs + 1);
                    freqs.push(Math.pow(10, logF));
                }
            }

            // Sort by frequency (high to low for C ordering)
            return freqs.sort((a, b) => b - a).slice(0, numFreqs);
        }
        function predictRRCRC(params, omega) {
            const par1 = predictParallel(params.R1, params.C1, omega);
            const par2 = predictParallel(params.R2, params.C2, omega);
            const par3 = predictParallel(params.R3, params.C3, omega);
            return {
                real: params.R0 + par1.real + par2.real + par3.real,
                imag: par1.imag + par2.imag + par3.imag
            };
        }

        // Constant Phase Element model: R0 + (R1 || CPE)
        // Uses multi-start optimization due to sensitivity of n exponent
        function fitCPEModel(omega) {
            // Use improved R0 and R_total estimation
            const R0_est = estimateR0();
            const R_total = estimateRTotal();
            const R1_est = Math.max(R_total - R0_est, 10);
            const C_est = estimateCapacitance(omega);

            // Estimate n from the depression angle of the semicircle
            const n_est = estimateCPEExponent();

            // Expanded multi-start with different n values and Q estimates
            const startConfigs = [
                { n: n_est, Q: C_est, R0: R0_est, R1: R1_est },
                // Typical Q values for EIS
                { n: 0.82, Q: 3e-6, R0: R0_est, R1: R1_est },
                { n: 0.85, Q: 1e-6, R0: R0_est, R1: R1_est },
                { n: 0.80, Q: 5e-6, R0: R0_est, R1: R1_est },
                { n: 0.78, Q: 1e-5, R0: R0_est, R1: R1_est },
                { n: 0.90, Q: 5e-7, R0: R0_est, R1: R1_est },
                // Different R0 variations
                { n: 0.82, Q: C_est, R0: R0_est * 0.8, R1: R1_est * 1.1 },
                { n: 0.85, Q: C_est * 0.5, R0: R0_est * 0.7, R1: R1_est * 1.2 },
                { n: 0.80, Q: C_est * 2, R0: R0_est * 0.9, R1: R1_est * 1.05 },
                // Wide Q range
                { n: 0.75, Q: C_est * 0.1, R0: R0_est, R1: R1_est },
                { n: 0.88, Q: C_est * 0.3, R0: R0_est, R1: R1_est },
                { n: 0.92, Q: C_est * 3, R0: R0_est, R1: R1_est },
                // Very different n values
                { n: 0.70, Q: 2e-5, R0: R0_est, R1: R1_est },
                { n: 0.95, Q: 1e-7, R0: R0_est, R1: R1_est },
                { n: n_est, Q: C_est * 0.2, R0: R0_est * 0.85, R1: R1_est * 1.1 },
            ];

            let bestParams = null;
            let bestError = Infinity;

            for (const config of startConfigs) {
                try {
                    // Use log-space optimization for Q parameter
                    const params = nelderMeadLogSpace(
                        (p) => calcError(p, omega, predictCPE),
                        config,
                        ['Q'],
                        { R0: Math.max(config.R0 * 0.3, 5), R1: config.R1 * 0.3, Q: config.Q * 0.5, n: 0.1 },
                        1500
                    );
                    const error = calcError(params, omega, predictCPE);
                    if (error < bestError) {
                        bestError = error;
                        bestParams = params;
                    }
                } catch (e) {
                    console.warn('CPE fit attempt failed:', e);
                }
            }

            return bestParams || { R0: R0_est, R1: R1_est, Q: C_est, n: 0.85 };
        }

        // Estimate CPE exponent n from the depression angle of the Nyquist plot
        function estimateCPEExponent() {
            // For a depressed semicircle, n = 1 - (2*alpha/pi) where alpha is depression angle
            // Find the center of the semicircle approximately
            const maxZimag = Math.max(...eisData.zImag.map(z => -z));
            const idxMax = eisData.zImag.findIndex(z => -z === maxZimag);

            if (idxMax > 0 && idxMax < eisData.zImag.length - 1) {
                const zRealAtMax = eisData.zReal[idxMax];
                const zRealMin = Math.min(...eisData.zReal);
                const zRealMax = Math.max(...eisData.zReal);
                const diameter = zRealMax - zRealMin;
                const radius = diameter / 2;

                // Depression angle: if center is below real axis
                // For ideal semicircle, height = radius, so ratio < 1 indicates depression
                const heightRatio = maxZimag / radius;
                if (heightRatio > 0 && heightRatio <= 1) {
                    const alpha = Math.acos(Math.min(heightRatio, 1));
                    return Math.max(0.5, Math.min(1, 1 - (2 * alpha / Math.PI)));
                }
            }
            return 0.85; // Default estimate
        }
        function predictCPE(params, omega) {
            // Use admittance approach for cleaner calculation
            const Q = params.Q;
            const n = Math.min(Math.max(params.n, 0.1), 1); // Clamp n between 0.1 and 1

            // Admittance of CPE: Y_CPE = Q*(jœâ)^n = Q*œâ^n * (cos(nœÄ/2) + j*sin(nœÄ/2))
            const yCpeReal = Q * Math.pow(omega, n) * Math.cos(n * Math.PI / 2);
            const yCpeImag = Q * Math.pow(omega, n) * Math.sin(n * Math.PI / 2);

            // Total admittance (parallel): Y = 1/R1 + Y_CPE
            const yTotalReal = 1 / params.R1 + yCpeReal;
            const yTotalImag = yCpeImag;

            // Convert back to impedance: Z = 1/Y = Y* / |Y|^2
            const yMag2 = yTotalReal * yTotalReal + yTotalImag * yTotalImag;
            const zParReal = yTotalReal / yMag2;
            const zParImag = -yTotalImag / yMag2;

            return {
                real: params.R0 + zParReal,
                imag: zParImag
            };
        }

        // CPE with Warburg model: R0 + (R1 || CPE) + W
        // Uses multi-start optimization
        function fitCPEWModel(omega) {
            const R0_est = estimateR0();
            const R_total = estimateRTotal();
            const R1_est = Math.max((R_total - R0_est) * 0.5, 10);
            const C_est = estimateCapacitance(omega);
            const n_est = estimateCPEExponent();
            const W_est = (R_total - R0_est) * 0.3;

            const startConfigs = [
                { n: n_est, Q: C_est, R0: R0_est, R1: R1_est, W: W_est },
                { n: 0.82, Q: 3e-6, R0: R0_est, R1: R1_est, W: W_est * 0.5 },
                { n: 0.85, Q: 1e-6, R0: R0_est, R1: R1_est, W: W_est * 1.5 },
                { n: 0.80, Q: 5e-6, R0: R0_est, R1: R1_est * 0.8, W: W_est },
                { n: 0.78, Q: 1e-5, R0: R0_est, R1: R1_est * 1.2, W: W_est * 0.8 },
                { n: 0.90, Q: 5e-7, R0: R0_est, R1: R1_est, W: W_est * 2 },
                { n: 0.75, Q: 2e-5, R0: R0_est * 0.9, R1: R1_est * 0.7, W: W_est * 1.2 },
                { n: n_est, Q: C_est * 0.5, R0: R0_est * 0.8, R1: R1_est * 1.1, W: W_est * 0.7 },
            ];

            let bestParams = null;
            let bestError = Infinity;

            for (const config of startConfigs) {
                try {
                    const params = nelderMeadLogSpace(
                        (p) => calcError(p, omega, predictCPEW),
                        config,
                        ['Q', 'W'],
                        { R0: Math.max(config.R0 * 0.3, 5), R1: config.R1 * 0.3, Q: config.Q * 0.5, n: 0.1, W: config.W * 0.5 },
                        1500
                    );
                    const error = calcError(params, omega, predictCPEW);
                    if (error < bestError) {
                        bestError = error;
                        bestParams = params;
                    }
                } catch (e) {
                    console.warn('CPEW fit attempt failed:', e);
                }
            }

            return bestParams || { R0: R0_est, R1: R1_est, Q: C_est, n: 0.85, W: W_est };
        }

        function predictCPEW(params, omega) {
            // R0 + (R1 || CPE) + Warburg
            const cpe = predictRCPEParallel(params.R1, params.Q, params.n, omega);
            // Warburg: Z_w = W/sqrt(omega) * (1 - j)
            const warburgFactor = params.W / Math.sqrt(omega);
            return {
                real: params.R0 + cpe.real + warburgFactor,
                imag: cpe.imag - warburgFactor
            };
        }

        // Two CPE with Warburg model: R0 + (R1 || CPE1) + (R2 || CPE2) + W
        // Uses multi-start optimization due to 8 parameters
        function fitCPECPEWModel(omega) {
            const R0_est = estimateR0();
            const R_total = estimateRTotal();
            const R_range = Math.max(R_total - R0_est, 10);
            const C_est = estimateCapacitance(omega);
            const n_est = estimateCPEExponent();
            const W_est = R_range * 0.2;

            const charFreqs = estimateCharacteristicFrequencies(omega, 2);
            const R_avg = R_range / 2;
            const Q_estimates = charFreqs.map(f => 1 / (2 * Math.PI * f * Math.max(R_avg, 1)));

            const startConfigs = [
                { n1: n_est, Q1: Q_estimates[0] || C_est * 0.3, R1: R_range * 0.5, n2: n_est * 0.95, Q2: Q_estimates[1] || C_est * 3, R2: R_range * 0.3, W: W_est },
                { n1: 0.85, Q1: 2e-6, R1: R_range * 0.5, n2: 0.78, Q2: 1e-5, R2: R_range * 0.3, W: W_est * 0.8 },
                { n1: 0.82, Q1: 1e-6, R1: R_range * 0.45, n2: 0.80, Q2: 5e-6, R2: R_range * 0.35, W: W_est * 1.2 },
                { n1: 0.88, Q1: 3e-6, R1: R_range * 0.48, n2: 0.75, Q2: 8e-6, R2: R_range * 0.32, W: W_est * 1.5 },
                { n1: 0.80, Q1: C_est * 0.2, R1: R_range * 0.55, n2: 0.85, Q2: C_est * 2, R2: R_range * 0.25, W: W_est * 0.5 },
                { n1: 0.85, Q1: 5e-7, R1: R_range * 0.5, n2: 0.78, Q2: 2e-5, R2: R_range * 0.3, W: W_est * 2 },
                { n1: n_est, Q1: C_est * 0.3, R1: R_range * 0.48, n2: n_est, Q2: C_est * 3, R2: R_range * 0.32, W: W_est },
            ];

            let bestParams = null;
            let bestError = Infinity;

            for (const config of startConfigs) {
                const initial = {
                    R0: R0_est,
                    R1: config.R1,
                    Q1: config.Q1,
                    n1: config.n1,
                    R2: config.R2,
                    Q2: config.Q2,
                    n2: config.n2,
                    W: config.W
                };

                const steps = {
                    R0: Math.max(R0_est * 0.3, 5),
                    R1: initial.R1 * 0.4,
                    Q1: initial.Q1 * 0.5,
                    n1: 0.1,
                    R2: initial.R2 * 0.4,
                    Q2: initial.Q2 * 0.5,
                    n2: 0.1,
                    W: initial.W * 0.5
                };

                try {
                    const params = nelderMeadLogSpace(
                        (p) => calcError(p, omega, predictCPECPEW),
                        initial,
                        ['Q1', 'Q2', 'W'],
                        steps,
                        2000
                    );
                    const error = calcError(params, omega, predictCPECPEW);
                    if (error < bestError) {
                        bestError = error;
                        bestParams = params;
                    }
                } catch (e) {
                    console.warn('CPECPEW fit attempt failed:', e);
                }
            }

            return bestParams || { R0: R0_est, R1: R_range * 0.5, Q1: C_est, n1: 0.85, R2: R_range * 0.3, Q2: C_est * 3, n2: 0.80, W: W_est };
        }

        function predictCPECPEW(params, omega) {
            // R0 + (R1||CPE1) + (R2||CPE2) + Warburg
            const cpe1 = predictRCPEParallel(params.R1, params.Q1, params.n1, omega);
            const cpe2 = predictRCPEParallel(params.R2, params.Q2, params.n2, omega);
            // Warburg: Z_w = W/sqrt(omega) * (1 - j)
            const warburgFactor = params.W / Math.sqrt(omega);
            return {
                real: params.R0 + cpe1.real + cpe2.real + warburgFactor,
                imag: cpe1.imag + cpe2.imag - warburgFactor
            };
        }

        // Two CPE model: R0 + (R1 || CPE1) + (R2 || CPE2) in series
        // Uses multi-start optimization due to 7 parameters
        function fitCPECPEModel(omega) {
            // Use improved R0 and R_total estimation
            const R0_est = estimateR0();
            const R_total = estimateRTotal();
            const R_range = Math.max(R_total - R0_est, 10);
            const C_est = estimateCapacitance(omega);
            const n_est = estimateCPEExponent();

            // Estimate characteristic frequencies for two time constants
            const charFreqs = estimateCharacteristicFrequencies(omega, 2);
            const R_avg = R_range / 2;
            const Q_estimates = charFreqs.map(f => 1 / (2 * Math.PI * f * Math.max(R_avg, 1)));

            // Expanded multi-start with different n values and parameter combinations
            const startConfigs = [
                // Based on estimated frequencies
                { n1: n_est, Q1: Q_estimates[0] || C_est * 0.3, R1: R_range * 0.6, n2: n_est * 0.95, Q2: Q_estimates[1] || C_est * 3, R2: R_range * 0.4 },
                // Typical EIS values matching debug test parameters
                { n1: 0.85, Q1: 2e-6, R1: R_range * 0.6, n2: 0.78, Q2: 1e-5, R2: R_range * 0.4 },
                { n1: 0.82, Q1: 1e-6, R1: R_range * 0.55, n2: 0.80, Q2: 5e-6, R2: R_range * 0.45 },
                { n1: 0.88, Q1: 3e-6, R1: R_range * 0.58, n2: 0.75, Q2: 8e-6, R2: R_range * 0.42 },
                // Different R distributions
                { n1: 0.85, Q1: C_est * 0.5, R1: R_range * 0.5, n2: 0.80, Q2: C_est * 3, R2: R_range * 0.5 },
                { n1: 0.80, Q1: C_est * 0.2, R1: R_range * 0.65, n2: 0.85, Q2: C_est * 2, R2: R_range * 0.35 },
                { n1: 0.90, Q1: C_est * 0.8, R1: R_range * 0.55, n2: 0.75, Q2: C_est * 6, R2: R_range * 0.45 },
                // Wide Q range
                { n1: 0.85, Q1: 5e-7, R1: R_range * 0.6, n2: 0.78, Q2: 2e-5, R2: R_range * 0.4 },
                { n1: 0.82, Q1: 1e-5, R1: R_range * 0.55, n2: 0.80, Q2: 5e-5, R2: R_range * 0.45 },
                // Reverse order (large Q first)
                { n1: 0.78, Q1: 1e-5, R1: R_range * 0.4, n2: 0.85, Q2: 2e-6, R2: R_range * 0.6 },
                { n1: 0.80, Q1: C_est * 5, R1: R_range * 0.4, n2: 0.85, Q2: C_est * 0.3, R2: R_range * 0.6 },
                // Similar n values
                { n1: 0.82, Q1: C_est * 0.4, R1: R_range * 0.6, n2: 0.82, Q2: C_est * 4, R2: R_range * 0.4 },
                { n1: n_est, Q1: C_est * 0.3, R1: R_range * 0.58, n2: n_est, Q2: C_est * 3, R2: R_range * 0.42 },
            ];

            let bestParams = null;
            let bestError = Infinity;

            for (const config of startConfigs) {
                const initial = {
                    R0: R0_est,
                    R1: config.R1,
                    Q1: config.Q1,
                    n1: config.n1,
                    R2: config.R2,
                    Q2: config.Q2,
                    n2: config.n2
                };

                const steps = {
                    R0: Math.max(R0_est * 0.3, 5),
                    R1: initial.R1 * 0.4,
                    Q1: initial.Q1 * 0.5,
                    n1: 0.1,
                    R2: initial.R2 * 0.4,
                    Q2: initial.Q2 * 0.5,
                    n2: 0.1
                };

                try {
                    // Use log-space optimization for Q parameters
                    const params = nelderMeadLogSpace(
                        (p) => calcError(p, omega, predictCPECPE),
                        initial,
                        ['Q1', 'Q2'],
                        steps,
                        2000
                    );
                    const error = calcError(params, omega, predictCPECPE);
                    if (error < bestError) {
                        bestError = error;
                        bestParams = params;
                    }
                } catch (e) {
                    console.warn('Two CPE fit attempt failed:', e);
                }
            }

            return bestParams || {
                R0: R0_est, R1: R_range * 0.6, Q1: C_est * 0.5, n1: 0.85,
                R2: R_range * 0.4, Q2: C_est * 5, n2: 0.80
            };
        }

        function predictCPECPE(params, omega) {
            // Two R||CPE elements in series: R0 + (R1||CPE1) + (R2||CPE2)
            const cpe1 = predictRCPEParallel(params.R1, params.Q1, params.n1, omega);
            const cpe2 = predictRCPEParallel(params.R2, params.Q2, params.n2, omega);

            return {
                real: params.R0 + cpe1.real + cpe2.real,
                imag: cpe1.imag + cpe2.imag
            };
        }

        // Helper function to calculate impedance of R||CPE
        function predictRCPEParallel(R, Q, n, omega) {
            const nClamped = Math.min(Math.max(n, 0.1), 1);

            // Admittance of CPE: Y_CPE = Q*(jœâ)^n
            const yCpeReal = Q * Math.pow(omega, nClamped) * Math.cos(nClamped * Math.PI / 2);
            const yCpeImag = Q * Math.pow(omega, nClamped) * Math.sin(nClamped * Math.PI / 2);

            // Total admittance (parallel): Y = 1/R + Y_CPE
            const yTotalReal = 1 / R + yCpeReal;
            const yTotalImag = yCpeImag;

            // Convert back to impedance: Z = 1/Y
            const yMag2 = yTotalReal * yTotalReal + yTotalImag * yTotalImag;
            return {
                real: yTotalReal / yMag2,
                imag: -yTotalImag / yMag2
            };
        }

        // Parallel CPE model: R0 + [(R1 || CPE1) || (R2 || CPE2)]
        // Two R||CPE elements in parallel with each other, then series with R0
        function fitCPEpCPEModel(omega) {
            // Use improved R0 and R_total estimation
            const R0_est = estimateR0();
            const R_total = estimateRTotal();
            const R_range = Math.max(R_total - R0_est, 10);
            const C_est = estimateCapacitance(omega);
            const n_est = estimateCPEExponent();

            // For parallel elements, individual R values are larger than the total parallel R
            // R_parallel = (R1 * R2) / (R1 + R2), so R1 and R2 > R_range

            // Estimate characteristic frequencies for two time constants
            const charFreqs = estimateCharacteristicFrequencies(omega, 2);
            const Q_estimates = charFreqs.map(f => 1 / (2 * Math.PI * f * Math.max(R_range, 1)));

            // Expanded multi-start with different configurations
            const startConfigs = [
                // Based on estimated frequencies
                { n1: n_est, Q1: Q_estimates[0] || C_est * 0.2, R1: R_range * 2, n2: n_est * 0.95, Q2: Q_estimates[1] || C_est * 4, R2: R_range * 1.5 },
                // Typical EIS values matching debug test parameters
                { n1: 0.82, Q1: 1.5e-6, R1: R_range * 2.5, n2: 0.75, Q2: 8e-6, R2: R_range * 1.8 },
                { n1: 0.80, Q1: 2e-6, R1: R_range * 2.2, n2: 0.78, Q2: 1e-5, R2: R_range * 1.6 },
                { n1: 0.85, Q1: 1e-6, R1: R_range * 2.8, n2: 0.72, Q2: 5e-6, R2: R_range * 2.0 },
                // Different R ratios (parallel elements need R > R_range)
                { n1: 0.82, Q1: C_est * 0.2, R1: R_range * 2, n2: 0.75, Q2: C_est * 4, R2: R_range * 1.5 },
                { n1: 0.85, Q1: C_est * 0.3, R1: R_range * 3, n2: 0.80, Q2: C_est * 3, R2: R_range * 2 },
                { n1: 0.78, Q1: C_est * 0.15, R1: R_range * 2.5, n2: 0.82, Q2: C_est * 2, R2: R_range * 1.8 },
                // Wide Q range
                { n1: 0.82, Q1: 5e-7, R1: R_range * 2.5, n2: 0.75, Q2: 2e-5, R2: R_range * 1.5 },
                { n1: 0.80, Q1: 3e-6, R1: R_range * 2.2, n2: 0.78, Q2: 1.5e-5, R2: R_range * 1.7 },
                // Reverse order (large Q1, small Q2)
                { n1: 0.75, Q1: 8e-6, R1: R_range * 1.5, n2: 0.82, Q2: 1.5e-6, R2: R_range * 2.5 },
                { n1: 0.78, Q1: C_est * 5, R1: R_range * 1.6, n2: 0.85, Q2: C_est * 0.2, R2: R_range * 2.5 },
                // Similar n values
                { n1: 0.80, Q1: C_est * 0.25, R1: R_range * 2.3, n2: 0.80, Q2: C_est * 3, R2: R_range * 1.7 },
                { n1: n_est, Q1: C_est * 0.3, R1: R_range * 2.2, n2: n_est, Q2: C_est * 3.5, R2: R_range * 1.6 },
            ];

            let bestParams = null;
            let bestError = Infinity;

            for (const config of startConfigs) {
                const initial = {
                    R0: R0_est,
                    R1: config.R1,
                    Q1: config.Q1,
                    n1: config.n1,
                    R2: config.R2,
                    Q2: config.Q2,
                    n2: config.n2
                };

                const steps = {
                    R0: Math.max(R0_est * 0.3, 5),
                    R1: initial.R1 * 0.4,
                    Q1: initial.Q1 * 0.5,
                    n1: 0.1,
                    R2: initial.R2 * 0.4,
                    Q2: initial.Q2 * 0.5,
                    n2: 0.1
                };

                try {
                    // Use log-space optimization for Q parameters
                    const params = nelderMeadLogSpace(
                        (p) => calcError(p, omega, predictCPEpCPE),
                        initial,
                        ['Q1', 'Q2'],
                        steps,
                        2000
                    );
                    const error = calcError(params, omega, predictCPEpCPE);
                    if (error < bestError) {
                        bestError = error;
                        bestParams = params;
                    }
                } catch (e) {
                    console.warn('Parallel CPE fit attempt failed:', e);
                }
            }

            return bestParams || {
                R0: R0_est, R1: R_range * 2, Q1: C_est * 0.2, n1: 0.82,
                R2: R_range * 1.5, Q2: C_est * 4, n2: 0.75
            };
        }

        function predictCPEpCPE(params, omega) {
            // Two R||CPE elements in parallel: R0 + [(R1||CPE1) || (R2||CPE2)]
            // First get impedance of each R||CPE element
            const z1 = predictRCPEParallel(params.R1, params.Q1, params.n1, omega);
            const z2 = predictRCPEParallel(params.R2, params.Q2, params.n2, omega);

            // Parallel combination: Z_total = Z1 * Z2 / (Z1 + Z2)
            // Using complex arithmetic: (a+bi)(c+di) / ((a+c)+(b+d)i)
            const sumReal = z1.real + z2.real;
            const sumImag = z1.imag + z2.imag;

            // Product: (z1.real + z1.imag*i) * (z2.real + z2.imag*i)
            const prodReal = z1.real * z2.real - z1.imag * z2.imag;
            const prodImag = z1.real * z2.imag + z1.imag * z2.real;

            // Division: prod / sum
            const sumMag2 = sumReal * sumReal + sumImag * sumImag;
            const parReal = (prodReal * sumReal + prodImag * sumImag) / sumMag2;
            const parImag = (prodImag * sumReal - prodReal * sumImag) / sumMag2;

            return {
                real: params.R0 + parReal,
                imag: parImag
            };
        }

        function estimateCapacitance(omega) {
            // Find frequency at max -Z" (characteristic frequency)
            let maxImag = 0;
            let freqAtMax = omega[0];
            for (let i = 0; i < omega.length; i++) {
                if (-eisData.zImag[i] > maxImag) {
                    maxImag = -eisData.zImag[i];
                    freqAtMax = omega[i];
                }
            }
            // At characteristic frequency: omega * R * C ‚âà 1
            const R_est = Math.max(...eisData.zReal) - Math.min(...eisData.zReal);
            return 1 / (freqAtMax * Math.max(R_est, 1));
        }

        function calcError(params, omega, predictFn) {
            let error = 0;
            for (let i = 0; i < omega.length; i++) {
                const pred = predictFn(params, omega[i]);
                error += Math.pow(eisData.zReal[i] - pred.real, 2) + Math.pow(eisData.zImag[i] - pred.imag, 2);
            }
            return error;
        }

        // Weighted error function - gives more weight to larger features
        function calcWeightedError(params, omega, predictFn) {
            let error = 0;
            const zMagMax = Math.max(...eisData.zReal.map((r, i) => Math.sqrt(r*r + eisData.zImag[i]*eisData.zImag[i])));
            for (let i = 0; i < omega.length; i++) {
                const pred = predictFn(params, omega[i]);
                const zMag = Math.sqrt(eisData.zReal[i]*eisData.zReal[i] + eisData.zImag[i]*eisData.zImag[i]);
                const weight = 1 / (zMag / zMagMax + 0.1); // Higher weight for smaller impedances
                error += weight * (Math.pow(eisData.zReal[i] - pred.real, 2) + Math.pow(eisData.zImag[i] - pred.imag, 2));
            }
            return error;
        }

        // Estimate R0 from high-frequency extrapolation
        function estimateR0() {
            // Sort by frequency (descending) and use highest frequency points
            const sortedIndices = eisData.frequency.map((f, i) => ({f, i})).sort((a, b) => b.f - a.f);
            const highFreqIndices = sortedIndices.slice(0, Math.min(5, sortedIndices.length)).map(x => x.i);

            // Average of high-frequency Z_real values
            let sum = 0;
            for (const i of highFreqIndices) {
                sum += eisData.zReal[i];
            }
            return sum / highFreqIndices.length;
        }

        // Estimate total R (low frequency limit)
        function estimateRTotal() {
            // Sort by frequency (ascending) and use lowest frequency points
            const sortedIndices = eisData.frequency.map((f, i) => ({f, i})).sort((a, b) => a.f - b.f);
            const lowFreqIndices = sortedIndices.slice(0, Math.min(5, sortedIndices.length)).map(x => x.i);

            // Average of low-frequency Z_real values
            let sum = 0;
            for (const i of lowFreqIndices) {
                sum += eisData.zReal[i];
            }
            return sum / lowFreqIndices.length;
        }

        // Log-space optimization wrapper for parameters that vary over orders of magnitude
        function nelderMeadLogSpace(costFn, initial, logKeys, stepSizes, maxIter = 500, tol = 1e-8) {
            // Convert log parameters to log space
            const logInitial = {...initial};
            const logSteps = {...stepSizes};
            for (const key of logKeys) {
                logInitial[key] = Math.log10(Math.max(initial[key], 1e-15));
                logSteps[key] = 0.5; // Log step of 0.5 corresponds to ~3x change
            }

            // Wrapper cost function that converts back from log space
            const logCostFn = (params) => {
                const linearParams = {...params};
                for (const key of logKeys) {
                    linearParams[key] = Math.pow(10, params[key]);
                }
                return costFn(linearParams);
            };

            // Run optimization without Math.abs (log values can be negative)
            const logResult = nelderMeadCore(logCostFn, logInitial, logSteps, maxIter, tol, false);

            // Convert back to linear space
            const result = {...logResult};
            for (const key of logKeys) {
                result[key] = Math.pow(10, logResult[key]);
            }
            return result;
        }

        // Core Nelder-Mead simplex optimization
        // ensurePositive: if true, uses Math.abs to keep values positive (for linear-space params)
        function nelderMeadCore(costFn, initial, stepSizes, maxIter = 500, tol = 1e-8, ensurePositive = true) {
            const keys = Object.keys(initial);
            const n = keys.length;

            // Convert to array form for optimization
            const toArray = (obj) => keys.map(k => obj[k]);
            const toObj = (arr) => {
                const obj = {};
                keys.forEach((k, i) => obj[k] = ensurePositive ? Math.abs(arr[i]) : arr[i]);
                return obj;
            };

            // Initialize simplex
            const x0 = toArray(initial);
            const steps = toArray(stepSizes);
            const simplex = [x0];

            for (let i = 0; i < n; i++) {
                const xi = [...x0];
                xi[i] += steps[i];
                simplex.push(xi);
            }

            // Evaluate initial simplex
            let values = simplex.map(x => costFn(toObj(x)));

            const alpha = 1, gamma = 2, rho = 0.5, sigma = 0.5;

            for (let iter = 0; iter < maxIter; iter++) {
                // Sort by cost
                const order = values.map((v, i) => [v, i]).sort((a, b) => a[0] - b[0]);
                const sorted = order.map(o => simplex[o[1]]);
                const sortedVals = order.map(o => o[0]);

                for (let i = 0; i <= n; i++) {
                    simplex[i] = sorted[i];
                    values[i] = sortedVals[i];
                }

                // Check convergence
                if (Math.abs(values[n] - values[0]) < tol) break;

                // Centroid (excluding worst)
                const centroid = new Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        centroid[j] += simplex[i][j] / n;
                    }
                }

                // Reflection
                const reflected = centroid.map((c, j) => c + alpha * (c - simplex[n][j]));
                const reflectedVal = costFn(toObj(reflected));

                if (reflectedVal >= values[0] && reflectedVal < values[n-1]) {
                    simplex[n] = reflected;
                    values[n] = reflectedVal;
                } else if (reflectedVal < values[0]) {
                    // Expansion
                    const expanded = centroid.map((c, j) => c + gamma * (reflected[j] - c));
                    const expandedVal = costFn(toObj(expanded));
                    if (expandedVal < reflectedVal) {
                        simplex[n] = expanded;
                        values[n] = expandedVal;
                    } else {
                        simplex[n] = reflected;
                        values[n] = reflectedVal;
                    }
                } else {
                    // Contraction
                    const contracted = centroid.map((c, j) => c + rho * (simplex[n][j] - c));
                    const contractedVal = costFn(toObj(contracted));
                    if (contractedVal < values[n]) {
                        simplex[n] = contracted;
                        values[n] = contractedVal;
                    } else {
                        // Shrink
                        for (let i = 1; i <= n; i++) {
                            simplex[i] = simplex[i].map((x, j) => simplex[0][j] + sigma * (x - simplex[0][j]));
                            values[i] = costFn(toObj(simplex[i]));
                        }
                    }
                }
            }

            // Return best
            const bestIdx = values.indexOf(Math.min(...values));
            return toObj(simplex[bestIdx]);
        }

        // Wrapper for backwards compatibility - ensures positive values by default
        function nelderMead(costFn, initial, stepSizes, maxIter = 500, tol = 1e-8) {
            return nelderMeadCore(costFn, initial, stepSizes, maxIter, tol, true);
        }

        function predictRC(params, omega) {
            // R-C series impedance: Z = R - i/(omega*C)
            return {
                real: params.R,
                imag: -1 / (omega * params.C)
            };
        }

        function predictRRC(params, omega) {
            // R0 + (R1 || (1/jœâC))
            const R1 = params.R1;
            const C = params.C;
            
            // Parallel: R || C impedance = R / (1 + jœâRC)
            const denom = 1 + Math.pow(omega * R1 * C, 2);
            const parReal = R1 / denom;
            const parImag = -(omega * R1 * R1 * C) / denom;
            
            return {
                real: params.R0 + parReal,
                imag: parImag
            };
        }

        function predictRCRC(params, omega) {
            // R0 + (R1 || C1) + (R2 || C2)
            const par1 = predictParallel(params.R1, params.C1, omega);
            const par2 = predictParallel(params.R2, params.C2, omega);
            
            return {
                real: params.R0 + par1.real + par2.real,
                imag: par1.imag + par2.imag
            };
        }

        function predictParallel(R, C, omega) {
            const denom = 1 + Math.pow(omega * R * C, 2);
            return {
                real: R / denom,
                imag: -(omega * R * R * C) / denom
            };
        }

        function displayFitResults(params, chiSquared, modelName) {
            let html = '<div class="results">';
            if (modelName) {
                html += `<div style="background: #e8f4fd; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-weight: 500; color: #0066cc;">üìä Model: ${modelName}<button class="copy-btn" onclick="copyParameters()" title="Copy to clipboard">Copy</button></div>`;
            }
            html += '<h3>Fitted Parameters</h3>';

            for (const [key, value] of Object.entries(params)) {
                let unit = '';
                if (key === 'n' || key === 'n1' || key === 'n2') unit = ''; // CPE exponent is dimensionless
                else if (key === 'W') unit = ' Œ©¬∑s‚Åª‚Å∞¬∑‚Åµ'; // Warburg coefficient
                else if (key === 'Q' || key === 'Q1' || key === 'Q2') unit = ' S¬∑s‚Åø'; // CPE pseudo-capacitance
                else if (key.includes('R')) unit = ' Œ©';
                else if (key.includes('C')) unit = ' F';

                const displayValue = Math.abs(value) < 0.001 ? value.toExponential(3) : value.toFixed(3);
                html += `<div class="result-row"><span class="result-label">${key}</span><span class="result-value">${displayValue}${unit}</span></div>`;
            }

            html += `<div class="result-row"><span class="result-label">œá¬≤/N</span><span class="result-value">${chiSquared.toExponential(3)}</span></div>`;
            html += '</div>';

            document.getElementById('fitResults').innerHTML = html;
            document.getElementById('exportButtons').style.display = 'block';
            updateStatus('fitStatus', 'Fit completed', 'success');
        }

        function copyParameters() {
            if (!lastFitResults) return;

            const lines = [`Model: ${lastFitResults.model}`];
            for (const [key, value] of Object.entries(lastFitResults.params)) {
                const displayValue = Math.abs(value) < 0.001 ? value.toExponential(4) : value.toFixed(4);
                lines.push(`${key}: ${displayValue}`);
            }
            lines.push(`œá¬≤/N: ${lastFitResults.chiSquared.toExponential(3)}`);

            const text = lines.join('\n');
            navigator.clipboard.writeText(text).then(() => {
                const btn = document.querySelector('.copy-btn');
                btn.textContent = 'Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = 'Copy';
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Copy failed:', err);
                alert('Copy failed. Please select and copy manually.');
            });
        }

        // Detect mobile for plot config
        const isMobile = () => window.innerWidth < 600;

        function plotNyquist() {
            const trace = {
                x: eisData.zReal,
                y: eisData.zImag.map(z => -z),
                mode: 'markers+lines',
                name: 'EIS Data',
                marker: { size: isMobile() ? 5 : 6, color: '#667eea' },
                line: { color: '#667eea', width: 2 }
            };

            const layout = {
                xaxis: { title: "Z' (Œ©)", tickfont: { size: isMobile() ? 10 : 12 } },
                yaxis: { title: "-Z\" (Œ©)", tickfont: { size: isMobile() ? 10 : 12 } },
                hovermode: 'closest',
                margin: { t: 10, b: 50, l: 55, r: 10 },
                showlegend: false
            };

            const config = { responsive: true, displayModeBar: !isMobile() };
            Plotly.newPlot('nyquistPlot', [trace], layout, config);
        }

        function plotBode() {
            const mobile = isMobile();
            const magTrace = {
                x: eisData.frequency,
                y: eisData.zMag,
                mode: 'lines+markers',
                name: '|Z|',
                marker: { size: mobile ? 4 : 6 },
                line: { color: '#667eea' }
            };

            const phaseTrace = {
                x: eisData.frequency,
                y: eisData.zPhase,
                mode: 'lines+markers',
                name: 'Phase',
                marker: { size: mobile ? 4 : 6 },
                line: { color: '#764ba2' }
            };

            const magLayout = {
                xaxis: { title: 'Frequency (Hz)', type: 'log', tickfont: { size: mobile ? 10 : 12 } },
                yaxis: { title: '|Z| (Œ©)', type: 'log', tickfont: { size: mobile ? 10 : 12 } },
                hovermode: 'x unified',
                margin: { t: 10, b: 50, l: 55, r: 10 },
                showlegend: false
            };

            const phaseLayout = {
                xaxis: { title: 'Frequency (Hz)', type: 'log', tickfont: { size: mobile ? 10 : 12 } },
                yaxis: { title: 'Phase (¬∞)', tickfont: { size: mobile ? 10 : 12 } },
                hovermode: 'x unified',
                margin: { t: 10, b: 50, l: 55, r: 10 },
                showlegend: false
            };

            const config = { responsive: true, displayModeBar: !mobile };
            Plotly.newPlot('bodeMagnitudePlot', [magTrace], magLayout, config);
            Plotly.newPlot('bodePhase', [phaseTrace], phaseLayout, config);
        }

        function plotBodeFit(predicted) {
            const mobile = isMobile();

            // Calculate predicted magnitude and phase
            const predMag = predicted.map(p => Math.sqrt(p.real * p.real + p.imag * p.imag));
            const predPhase = predicted.map(p => Math.atan2(-p.imag, p.real) * 180 / Math.PI);

            // Calculate R¬≤ for magnitude (using log scale for better representation)
            const logMagData = eisData.zMag.map(m => Math.log10(m));
            const logMagPred = predMag.map(m => Math.log10(m));
            const meanLogMag = logMagData.reduce((a, b) => a + b, 0) / logMagData.length;
            let ssTotMag = 0, ssResMag = 0;
            for (let i = 0; i < logMagData.length; i++) {
                ssTotMag += Math.pow(logMagData[i] - meanLogMag, 2);
                ssResMag += Math.pow(logMagData[i] - logMagPred[i], 2);
            }
            const rSquaredMag = Math.max(0, 1 - ssResMag / ssTotMag);
            const rSquaredMagPct = (rSquaredMag * 100).toFixed(1);

            // Calculate R¬≤ for phase
            const meanPhase = eisData.zPhase.reduce((a, b) => a + b, 0) / eisData.zPhase.length;
            let ssTotPhase = 0, ssResPhase = 0;
            for (let i = 0; i < eisData.zPhase.length; i++) {
                ssTotPhase += Math.pow(eisData.zPhase[i] - meanPhase, 2);
                ssResPhase += Math.pow(eisData.zPhase[i] - predPhase[i], 2);
            }
            const rSquaredPhase = Math.max(0, 1 - ssResPhase / ssTotPhase);
            const rSquaredPhasePct = (rSquaredPhase * 100).toFixed(1);

            // Experimental data traces
            const magDataTrace = {
                x: eisData.frequency,
                y: eisData.zMag,
                mode: 'markers',
                name: 'Data',
                marker: { size: mobile ? 4 : 6, color: '#667eea' }
            };

            const magFitTrace = {
                x: eisData.frequency,
                y: predMag,
                mode: 'lines',
                name: `Fit (R¬≤=${rSquaredMagPct}%)`,
                line: { color: '#ff6b6b', width: 2, dash: 'dash' }
            };

            const phaseDataTrace = {
                x: eisData.frequency,
                y: eisData.zPhase,
                mode: 'markers',
                name: 'Data',
                marker: { size: mobile ? 4 : 6, color: '#764ba2' }
            };

            const phaseFitTrace = {
                x: eisData.frequency,
                y: predPhase,
                mode: 'lines',
                name: `Fit (R¬≤=${rSquaredPhasePct}%)`,
                line: { color: '#ff6b6b', width: 2, dash: 'dash' }
            };

            const magLayout = {
                xaxis: { title: 'Frequency (Hz)', type: 'log', tickfont: { size: mobile ? 10 : 12 } },
                yaxis: { title: '|Z| (Œ©)', type: 'log', tickfont: { size: mobile ? 10 : 12 } },
                hovermode: 'x unified',
                margin: { t: 10, b: mobile ? 70 : 50, l: 55, r: 10 },
                legend: { orientation: 'h', y: mobile ? -0.25 : -0.15, x: 0.5, xanchor: 'center', font: { size: mobile ? 10 : 11 } }
            };

            const phaseLayout = {
                xaxis: { title: 'Frequency (Hz)', type: 'log', tickfont: { size: mobile ? 10 : 12 } },
                yaxis: { title: 'Phase (¬∞)', tickfont: { size: mobile ? 10 : 12 } },
                hovermode: 'x unified',
                margin: { t: 10, b: mobile ? 70 : 50, l: 55, r: 10 },
                legend: { orientation: 'h', y: mobile ? -0.25 : -0.15, x: 0.5, xanchor: 'center', font: { size: mobile ? 10 : 11 } }
            };

            const config = { responsive: true, displayModeBar: !mobile };
            Plotly.newPlot('bodeMagnitudePlot', [magDataTrace, magFitTrace], magLayout, config);
            Plotly.newPlot('bodePhase', [phaseDataTrace, phaseFitTrace], phaseLayout, config);
        }

        function plotResiduals(predicted) {
            const mobile = isMobile();

            // Validate predicted array
            if (!predicted || predicted.length === 0) {
                console.error('plotResiduals: No predicted data available');
                return;
            }

            // Use the data source that matches the predicted data length
            const dataSource = filteredData || eisData;
            const len = Math.min(dataSource.zReal.length, predicted.length);

            // Calculate residuals (percent error)
            const residualReal = [];
            const residualImag = [];
            const frequencies = [];

            for (let i = 0; i < len; i++) {
                if (predicted[i] && typeof predicted[i].real !== 'undefined') {
                    const errReal = dataSource.zReal[i] - predicted[i].real;
                    residualReal.push((errReal / Math.abs(dataSource.zReal[i] || 1)) * 100);

                    const errImag = dataSource.zImag[i] - predicted[i].imag;
                    residualImag.push((errImag / Math.abs(dataSource.zImag[i] || 1)) * 100);

                    frequencies.push(dataSource.frequency[i]);
                }
            }

            // Show residual panel
            document.getElementById('residualPanel').style.display = 'block';

            const realTrace = {
                x: frequencies,
                y: residualReal,
                mode: 'markers+lines',
                name: "Z' Residual",
                marker: { size: mobile ? 4 : 5, color: '#667eea' },
                line: { color: '#667eea', width: 1 }
            };

            const imagTrace = {
                x: frequencies,
                y: residualImag,
                mode: 'markers+lines',
                name: 'Z" Residual',
                marker: { size: mobile ? 4 : 5, color: '#764ba2' },
                line: { color: '#764ba2', width: 1 }
            };

            const zeroLine = {
                type: 'line',
                x0: frequencies.length > 0 ? Math.min(...frequencies) : 0,
                x1: frequencies.length > 0 ? Math.max(...frequencies) : 1,
                y0: 0,
                y1: 0,
                line: { color: '#999', width: 1, dash: 'dash' }
            };

            const realLayout = {
                xaxis: { title: 'Frequency (Hz)', type: 'log', tickfont: { size: mobile ? 10 : 11 } },
                yaxis: { title: "Z' Error (%)", tickfont: { size: mobile ? 10 : 11 } },
                hovermode: 'x unified',
                margin: { t: 10, b: 50, l: 50, r: 10 },
                showlegend: false,
                shapes: [zeroLine]
            };

            const imagLayout = {
                xaxis: { title: 'Frequency (Hz)', type: 'log', tickfont: { size: mobile ? 10 : 11 } },
                yaxis: { title: 'Z" Error (%)', tickfont: { size: mobile ? 10 : 11 } },
                hovermode: 'x unified',
                margin: { t: 10, b: 50, l: 50, r: 10 },
                showlegend: false,
                shapes: [zeroLine]
            };

            const config = { responsive: true, displayModeBar: !mobile };
            Plotly.newPlot('residualRealPlot', [realTrace], realLayout, config);
            Plotly.newPlot('residualImagPlot', [imagTrace], imagLayout, config);
        }

        function plotFit(predicted) {
            const mobile = isMobile();

            // Validate predicted array
            if (!predicted || predicted.length === 0) {
                console.error('plotFit: No predicted data available');
                return;
            }

            // Use the data source that matches the predicted data length
            const dataSource = filteredData || eisData;

            // Calculate R¬≤ (coefficient of determination)
            const meanReal = dataSource.zReal.reduce((a, b) => a + b, 0) / dataSource.zReal.length;
            const meanImag = dataSource.zImag.reduce((a, b) => a + b, 0) / dataSource.zImag.length;

            let ssTot = 0, ssRes = 0;
            const len = Math.min(dataSource.zReal.length, predicted.length);
            for (let i = 0; i < len; i++) {
                if (predicted[i] && typeof predicted[i].real !== 'undefined') {
                    ssTot += Math.pow(dataSource.zReal[i] - meanReal, 2) + Math.pow(dataSource.zImag[i] - meanImag, 2);
                    ssRes += Math.pow(dataSource.zReal[i] - predicted[i].real, 2) + Math.pow(dataSource.zImag[i] - predicted[i].imag, 2);
                }
            }
            const rSquared = ssTot > 0 ? Math.max(0, 1 - ssRes / ssTot) : 0;
            const rSquaredPct = (rSquared * 100).toFixed(1);

            const nyquistData = [{
                x: dataSource.zReal,
                y: dataSource.zImag.map(z => -z),
                mode: 'markers',
                name: 'Experimental',
                marker: { size: mobile ? 5 : 6, color: '#667eea' }
            }, {
                x: predicted.filter(p => p && typeof p.real !== 'undefined').map(p => p.real),
                y: predicted.filter(p => p && typeof p.imag !== 'undefined').map(p => -p.imag),
                mode: 'lines',
                name: `Fit (R¬≤=${rSquaredPct}%)`,
                line: { color: '#ff6b6b', width: 2, dash: 'dash' }
            }];

            const layout = {
                xaxis: { title: "Z' (Œ©)", tickfont: { size: mobile ? 10 : 12 } },
                yaxis: { title: "-Z\" (Œ©)", tickfont: { size: mobile ? 10 : 12 } },
                hovermode: 'closest',
                margin: { t: 10, b: mobile ? 80 : 50, l: 55, r: 10 },
                legend: {
                    orientation: 'h',
                    y: mobile ? -0.25 : -0.15,
                    x: 0.5,
                    xanchor: 'center',
                    font: { size: mobile ? 11 : 12 }
                }
            };

            const config = { responsive: true, displayModeBar: !mobile };
            Plotly.newPlot('nyquistPlot', nyquistData, layout, config);
        }

        // True parameters for debug tests
        const debugTrueParams = {
            'RRC': { R0: 75, R1: 150, C: 2.5e-6 },
            'RRCW': { R0: 60, R1: 120, C: 3e-6, W: 50 },
            'RCRC': { R0: 50, R1: 120, C1: 1.5e-6, R2: 80, C2: 8e-6 },
            'RRCRC': { R0: 40, R1: 100, C1: 5e-7, R2: 80, C2: 3e-6, R3: 60, C3: 2e-5 },
            'CPE': { R0: 70, R1: 180, Q: 3e-6, n: 0.82 },
            'CPECPE': { R0: 50, R1: 150, Q1: 1e-6, n1: 0.85, R2: 100, Q2: 1e-4, n2: 0.78 },
            'CPEpCPE': { R0: 45, R1: 200, Q1: 5e-7, n1: 0.82, R2: 150, Q2: 5e-5, n2: 0.75 },
            'CPEW': { R0: 60, R1: 180, Q: 2e-6, n: 0.80, W: 45 },
            'CPECPEW': { R0: 50, R1: 150, Q1: 1e-6, n1: 0.85, R2: 120, Q2: 8e-5, n2: 0.78, W: 35 }
        };

        function runDebugTest() {
            const modelType = document.getElementById('debugModel').value;
            const noiseLevel = parseFloat(document.getElementById('noiseLevel').value) / 100;

            // Get true parameters for selected model
            const trueParams = debugTrueParams[modelType];
            const model = modelRegistry[modelType];

            if (!trueParams || !model) {
                updateStatus('debugStatus', `Model ${modelType} not configured for testing`, 'error');
                return;
            }

            // Generate frequency range (log scale from 100 kHz to 0.0001 Hz)
            const frequencies = [];
            for (let exp = 5; exp >= -4; exp -= 0.25) {
                frequencies.push(Math.pow(10, exp));
            }

            // Generate ideal impedance data using the model's predict function
            const mockData = [];
            for (const freq of frequencies) {
                const omega = 2 * Math.PI * freq;
                const z = model.predict(trueParams, omega);

                // Add noise
                const noiseFactor = 1 + (Math.random() - 0.5) * 2 * noiseLevel;
                const noiseFactorImag = 1 + (Math.random() - 0.5) * 2 * noiseLevel;

                mockData.push({
                    freq: freq,
                    zReal: z.real * noiseFactor,
                    zImag: z.imag * noiseFactorImag
                });
            }

            // Format as tab-separated data and load into textarea
            const dataStr = mockData.map(d => `${d.freq}\t${d.zReal.toFixed(4)}\t${d.zImag.toFixed(4)}`).join('\n');
            document.getElementById('dataInput').value = dataStr;

            // Parse the data (format auto-detected)
            parseData();

            // Set the model type to match
            document.getElementById('modelType').value = modelType;

            // Fit the model using the registry
            const omega = eisData.frequency.map(f => 2 * Math.PI * f);
            const fitParams = model.fit(omega);
            const predicted = omega.map(w => model.predict(fitParams, w));

            // Calculate fit quality
            const chiSquared = calcChiSquared(predicted);

            // Calculate parameter recovery accuracy
            const paramErrors = {};
            let totalError = 0;
            let paramCount = 0;

            for (const [key, trueValue] of Object.entries(trueParams)) {
                const fittedValue = fitParams[key];
                const percentError = Math.abs((fittedValue - trueValue) / trueValue) * 100;
                paramErrors[key] = {
                    true: trueValue,
                    fitted: fittedValue,
                    error: percentError
                };
                totalError += percentError;
                paramCount++;
            }

            const avgError = totalError / paramCount;
            const score = Math.max(0, 100 - avgError);

            // Display debug results
            let html = '<div class="results"><h3>üß™ Debug Test Results</h3>';
            html += `<div style="background: #e8f4fd; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-weight: 500; color: #0066cc;">üìä Model: ${model.name}</div>`;
            html += `<div class="result-row" style="background: ${score >= 80 ? '#d4edda' : score >= 50 ? '#fff3cd' : '#f8d7da'}; padding: 10px; border-radius: 4px; margin-bottom: 10px;">`;
            html += `<span class="result-label" style="font-size: 1.1em;">Overall Score</span>`;
            html += `<span class="result-value" style="font-size: 1.2em; font-weight: bold;">${score.toFixed(1)}%</span></div>`;

            html += '<h4 style="margin-top: 15px; color: #555;">Parameter Recovery</h4>';
            html += '<table style="width: 100%; font-size: 0.85em; border-collapse: collapse;">';
            html += '<tr style="border-bottom: 2px solid #ddd;"><th style="text-align: left; padding: 5px;">Param</th><th>True</th><th>Fitted</th><th>Error</th></tr>';

            for (const [key, data] of Object.entries(paramErrors)) {
                const errorColor = data.error < 10 ? '#28a745' : data.error < 25 ? '#ffc107' : '#dc3545';
                const trueDisplay = data.true < 0.001 ? data.true.toExponential(2) : data.true.toFixed(2);
                const fittedDisplay = data.fitted < 0.001 ? data.fitted.toExponential(2) : data.fitted.toFixed(2);

                html += `<tr style="border-bottom: 1px solid #eee;">`;
                html += `<td style="padding: 5px; font-weight: 500;">${key}</td>`;
                html += `<td style="text-align: center; font-family: monospace;">${trueDisplay}</td>`;
                html += `<td style="text-align: center; font-family: monospace;">${fittedDisplay}</td>`;
                html += `<td style="text-align: center; color: ${errorColor}; font-weight: 500;">${data.error.toFixed(1)}%</td>`;
                html += `</tr>`;
            }
            html += '</table>';

            html += `<div class="result-row" style="margin-top: 10px;"><span class="result-label">œá¬≤/N</span><span class="result-value">${chiSquared.toExponential(3)}</span></div>`;
            html += `<div class="result-row"><span class="result-label">Noise Level</span><span class="result-value">${(noiseLevel * 100).toFixed(1)}%</span></div>`;
            html += `<div class="result-row"><span class="result-label">Data Points</span><span class="result-value">${frequencies.length}</span></div>`;
            html += '</div>';

            document.getElementById('fitResults').innerHTML = html;
            plotFit(predicted);

            const scoreEmoji = score >= 80 ? '‚úÖ' : score >= 50 ? '‚ö†Ô∏è' : '‚ùå';
            updateStatus('debugStatus', `${scoreEmoji} Test complete: ${score.toFixed(1)}% accuracy`, score >= 80 ? 'success' : score >= 50 ? 'info' : 'error');
        }

        function updateStatus(elementId, message, type) {
            const el = document.getElementById(elementId);
            el.className = `status ${type}`;
            el.textContent = message;
        }

        // Export functions
        function exportJSON() {
            if (!lastFitResults) {
                alert('No fit results to export. Please fit a model first.');
                return;
            }

            const exportData = {
                metadata: {
                    exportDate: new Date().toISOString(),
                    tool: 'EIS Analyzer',
                    dataPoints: eisData.frequency.length
                },
                model: lastFitResults.model,
                parameters: lastFitResults.params,
                chiSquared: lastFitResults.chiSquared,
                data: {
                    frequency: eisData.frequency,
                    zReal: eisData.zReal,
                    zImag: eisData.zImag,
                    zMag: eisData.zMag,
                    zPhase: eisData.zPhase
                },
                fit: {
                    zReal: lastFitResults.predicted.map(p => p.real),
                    zImag: lastFitResults.predicted.map(p => p.imag)
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            downloadBlob(blob, 'eis_results.json');
        }

        function exportCSV() {
            if (!lastFitResults) {
                alert('No fit results to export. Please fit a model first.');
                return;
            }

            // Create CSV with data and fit values
            let csv = 'Frequency (Hz),Z_real (Œ©),Z_imag (Œ©),|Z| (Œ©),Phase (¬∞),Z_real_fit (Œ©),Z_imag_fit (Œ©)\n';
            for (let i = 0; i < eisData.frequency.length; i++) {
                csv += `${eisData.frequency[i]},${eisData.zReal[i]},${eisData.zImag[i]},`;
                csv += `${eisData.zMag[i]},${eisData.zPhase[i]},`;
                csv += `${lastFitResults.predicted[i].real},${lastFitResults.predicted[i].imag}\n`;
            }

            // Add parameters as comments at the end
            csv += '\n# Model: ' + lastFitResults.model + '\n';
            csv += '# Chi-squared/N: ' + lastFitResults.chiSquared.toExponential(3) + '\n';
            csv += '# Parameters:\n';
            for (const [key, value] of Object.entries(lastFitResults.params)) {
                csv += `# ${key}: ${value}\n`;
            }

            const blob = new Blob([csv], { type: 'text/csv' });
            downloadBlob(blob, 'eis_results.csv');
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Settings menu functions
        function toggleSettingsMenu() {
            const menu = document.getElementById('settingsMenu');
            menu.classList.toggle('open');
        }

        // Close settings menu when clicking outside
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('settingsMenu');
            const settingsBtn = document.querySelector('.settings-btn');
            if (menu && menu.classList.contains('open') &&
                !menu.contains(event.target) &&
                !settingsBtn.contains(event.target)) {
                menu.classList.remove('open');
            }
        });

        // Debug modal functions
        function openDebugModal() {
            document.getElementById('settingsMenu').classList.remove('open');
            document.getElementById('debugModal').classList.add('open');
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }

        function closeDebugModal() {
            document.getElementById('debugModal').classList.remove('open');
            document.body.style.overflow = ''; // Restore scrolling
        }

        function closeDebugModalOnOverlay(event) {
            if (event.target === document.getElementById('debugModal')) {
                closeDebugModal();
            }
        }

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeDebugModal();
                document.getElementById('settingsMenu').classList.remove('open');
            }
        });

        // Session save/load functions
        function saveSession() {
            const session = {
                version: 1,
                savedAt: new Date().toISOString(),
                data: eisData,
                modelType: document.getElementById('modelType').value,
                freqRange: {
                    min: document.getElementById('freqMin').value,
                    max: document.getElementById('freqMax').value
                },
                fitResults: lastFitResults
            };

            const blob = new Blob([JSON.stringify(session, null, 2)], { type: 'application/json' });
            downloadBlob(blob, 'eis_session.json');
        }

        function loadSession(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const session = JSON.parse(e.target.result);

                    if (!session.data || !session.data.frequency) {
                        throw new Error('Invalid session file format');
                    }

                    // Restore data
                    eisData = session.data;

                    // Restore model selection
                    if (session.modelType) {
                        document.getElementById('modelType').value = session.modelType;
                    }

                    // Restore frequency range
                    if (session.freqRange) {
                        document.getElementById('freqMin').value = session.freqRange.min || '';
                        document.getElementById('freqMax').value = session.freqRange.max || '';
                    }

                    // Restore fit results
                    if (session.fitResults && session.fitResults.predicted && session.fitResults.predicted.length > 0) {
                        lastFitResults = session.fitResults;
                        displayFitResults(
                            session.fitResults.params,
                            session.fitResults.chiSquared,
                            session.fitResults.model
                        );
                        plotFit(session.fitResults.predicted);
                        plotBodeFit(session.fitResults.predicted);
                        plotResiduals(session.fitResults.predicted);
                    }

                    // Update plots
                    plotNyquist();
                    plotBode();

                    updateStatus('dataStatus', `Session loaded: ${eisData.frequency.length} data points`, 'success');
                } catch (err) {
                    alert('Error loading session: ' + err.message);
                    console.error('Load session error:', err);
                }
            };
            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        // Data Table functions
        function toggleDataTable() {
            const container = document.getElementById('dataTableContainer');
            const btn = container.previousElementSibling.querySelector('button');

            if (container.style.display === 'none') {
                if (eisData.frequency.length === 0) {
                    alert('No data loaded. Please load data first.');
                    return;
                }
                renderDataTable();
                container.style.display = 'block';
                btn.textContent = 'Hide Data Table';
            } else {
                container.style.display = 'none';
                btn.textContent = 'Show Data Table';
            }
        }

        function renderDataTable() {
            let html = '<table class="data-table">';
            html += '<thead><tr><th>#</th><th>Freq (Hz)</th><th>Z\' (Œ©)</th><th>Z" (Œ©)</th><th>|Z| (Œ©)</th><th>Phase (¬∞)</th></tr></thead>';
            html += '<tbody>';

            for (let i = 0; i < eisData.frequency.length; i++) {
                html += `<tr>`;
                html += `<td>${i + 1}</td>`;
                html += `<td>${formatNumber(eisData.frequency[i])}</td>`;
                html += `<td>${formatNumber(eisData.zReal[i])}</td>`;
                html += `<td>${formatNumber(eisData.zImag[i])}</td>`;
                html += `<td>${formatNumber(eisData.zMag[i])}</td>`;
                html += `<td>${formatNumber(eisData.zPhase[i])}</td>`;
                html += `</tr>`;
            }

            html += '</tbody></table>';
            document.getElementById('dataTableContainer').innerHTML = html;
        }

        function formatNumber(num) {
            if (Math.abs(num) < 0.001 || Math.abs(num) >= 10000) {
                return num.toExponential(3);
            }
            return num.toFixed(3);
        }

        // Model Comparison functions
        function compareAllModels() {
            if (eisData.frequency.length === 0) {
                updateStatus('fitStatus', 'No data loaded', 'error');
                return;
            }

            // Show loading spinner
            const fitStatus = document.getElementById('fitStatus');
            fitStatus.className = 'status loading';
            fitStatus.innerHTML = '<span class="spinner"></span>Comparing all models...';

            setTimeout(() => {
                // Get filtered data based on frequency range
                filteredData = getFilteredData();

                if (filteredData.frequency.length === 0) {
                    updateStatus('fitStatus', 'No data in selected frequency range', 'error');
                    return;
                }

                const omega = filteredData.frequency.map(f => 2 * Math.PI * f);
                const results = [];

                // Try all models
                const modelsToTry = ['R', 'RC', 'RpC', 'RRC', 'RRCW', 'RCRC', 'RRCRC', 'CPE', 'CPECPE', 'CPEpCPE'];

                for (const modelType of modelsToTry) {
                    try {
                        const model = modelRegistry[modelType];
                        const fitParams = model.fit(omega, filteredData);
                        const predicted = omega.map(w => model.predict(fitParams, w));

                        // Calculate chi-squared
                        const chiSq = calcChiSquared(predicted);

                        // Calculate R¬≤
                        const meanReal = filteredData.zReal.reduce((a, b) => a + b, 0) / filteredData.zReal.length;
                        const meanImag = filteredData.zImag.reduce((a, b) => a + b, 0) / filteredData.zImag.length;
                        let ssTot = 0, ssRes = 0;
                        for (let i = 0; i < filteredData.zReal.length; i++) {
                            ssTot += Math.pow(filteredData.zReal[i] - meanReal, 2) + Math.pow(filteredData.zImag[i] - meanImag, 2);
                            ssRes += Math.pow(filteredData.zReal[i] - predicted[i].real, 2) + Math.pow(filteredData.zImag[i] - predicted[i].imag, 2);
                        }
                        const rSquared = Math.max(0, 1 - ssRes / ssTot);

                        // Calculate AIC
                        const n = filteredData.zReal.length * 2;
                        const k = model.params;
                        const aic = n * Math.log(ssRes / n) + 2 * k;

                        results.push({
                            type: modelType,
                            name: model.name,
                            params: model.params,
                            chiSquared: chiSq,
                            rSquared: rSquared,
                            aic: aic,
                            fitParams: fitParams,
                            predicted: predicted
                        });
                    } catch (e) {
                        console.warn(`Model ${modelType} failed:`, e.message);
                    }
                }

                // Sort by AIC (lower is better)
                results.sort((a, b) => a.aic - b.aic);

                // Display comparison
                displayComparison(results);
                updateStatus('fitStatus', `Compared ${results.length} models`, 'success');
            }, 10);
        }

        function displayComparison(results) {
            const panel = document.getElementById('comparisonPanel');
            const container = document.getElementById('comparisonResults');

            let html = '<table class="comparison-table">';
            html += '<thead><tr><th>Model</th><th>Params</th><th>R¬≤</th><th>œá¬≤/N</th><th>AIC</th><th>Action</th></tr></thead>';
            html += '<tbody>';

            const bestAIC = results[0]?.aic || 0;

            for (let i = 0; i < results.length; i++) {
                const r = results[i];
                const isBest = i === 0;
                html += `<tr class="${isBest ? 'best' : ''}">`;
                html += `<td>${r.name}${isBest ? ' ‚≠ê' : ''}</td>`;
                html += `<td>${r.params}</td>`;
                html += `<td>${(r.rSquared * 100).toFixed(1)}%</td>`;
                html += `<td>${r.chiSquared.toExponential(2)}</td>`;
                html += `<td>${r.aic.toFixed(1)}</td>`;
                html += `<td><button type="button" onclick="selectComparedModel('${r.type}')" style="padding: 3px 8px; font-size: 0.8em;">Select</button></td>`;
                html += `</tr>`;
            }

            html += '</tbody></table>';
            container.innerHTML = html;
            panel.style.display = 'block';

            // Store comparison results
            window.comparisonResults = results;
        }

        function hideComparison() {
            document.getElementById('comparisonPanel').style.display = 'none';
        }

        function selectComparedModel(modelType) {
            const result = window.comparisonResults?.find(r => r.type === modelType);
            if (!result) return;

            // Set the model type in dropdown
            document.getElementById('modelType').value = modelType;

            // Store results
            lastFitResults = {
                model: result.name,
                params: result.fitParams,
                chiSquared: result.chiSquared,
                predicted: result.predicted
            };

            // Display results
            displayFitResults(result.fitParams, result.chiSquared, result.name);
            plotFit(result.predicted);
            plotBodeFit(result.predicted);
            plotResiduals(result.predicted);
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Electrochemical Impedance Spectroscopy (EIS) data analysis tool with circuit model fitting, Nyquist plots, and Bode plots">
    <title>EIS Analyzer - Circuit Model Fitting</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        header h1 { font-size: 2.5em; margin-bottom: 5px; }
        header p { opacity: 0.9; }
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 30px;
        }
        .panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e0e0e0;
        }
        .panel h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
            font-size: 0.9em;
        }
        select, textarea, input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }
        select:focus, textarea:focus, input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 5px rgba(102, 126, 234, 0.3);
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }
        button:hover { background: #764ba2; }
        button:active { transform: scale(0.98); }
        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .button-group button { flex: 1; }
        textarea {
            resize: vertical;
            min-height: 120px;
        }
        .results {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid #ddd;
        }
        .results h3 {
            color: #667eea;
            font-size: 1em;
            margin-bottom: 10px;
        }
        .result-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }
        .result-row:last-child { border-bottom: none; }
        .result-label { color: #666; font-weight: 500; }
        .result-value { color: #333; font-family: monospace; }
        .plot-container {
            width: 100%;
            height: 400px;
            min-height: 300px;
            border-radius: 8px;
            overflow: hidden;
        }
        .file-upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 15px;
        }
        .file-upload-area:hover, .file-upload-area.drag-over {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }
        .file-upload-area.loaded {
            border-color: #28a745;
            border-style: solid;
        }
        .file-upload-area input[type="file"] {
            display: none;
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
        .status {
            padding: 12px;
            border-radius: 4px;
            margin-top: 15px;
            font-size: 0.9em;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .full-width {
            grid-column: 1 / -1;
        }
        .two-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 1000px) {
            .content { grid-template-columns: 1fr; }
            .two-col { grid-template-columns: 1fr; }
            .plot-container { height: 350px; }
        }
        @media (max-width: 600px) {
            header h1 { font-size: 1.8em; }
            .content { padding: 15px; }
            .panel { padding: 15px; }
            .plot-container { height: 300px; }
        }
        /* Focus styles for accessibility */
        button:focus, select:focus, textarea:focus, input:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }
        .file-upload-area:focus-within {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ö° EIS Analyzer</h1>
            <p>Electrochemical Impedance Spectroscopy Data Analysis & Circuit Model Fitting</p>
        </header>

        <main class="content" role="main">
            <!-- Input Panel -->
            <div class="panel" role="region" aria-labelledby="data-input-heading">
                <h2 id="data-input-heading">üìä Data Input</h2>

                <!-- File Upload Area -->
                <div class="file-upload-area" id="fileDropZone" role="button" tabindex="0" aria-label="Upload CSV or TXT file with EIS data">
                    <div>üìÅ Drop file here or click to upload</div>
                    <div style="font-size: 0.85em; color: #666; margin-top: 5px;">Supports CSV, TXT (tab/space separated)</div>
                    <input type="file" id="fileInput" accept=".csv,.txt,.tsv" aria-label="File upload input">
                    <div id="fileStatus" style="margin-top: 10px; color: #28a745;"></div>
                </div>

                <div class="form-group">
                    <label for="dataInput">Paste Data (tab or space separated)</label>
                    <textarea id="dataInput" aria-describedby="data-format-hint" placeholder="Frequency	Z_real	Z_imag
0.01	1000	-500
0.1	950	-480
...

Format auto-detected: Z'/Z&quot; or |Z|/Phase"></textarea>
                    <small id="data-format-hint" style="color: #666; font-size: 0.8em;">Data format auto-detected. Parses automatically when pasted.</small>
                </div>

                <div id="dataStatus" role="status" aria-live="polite"></div>

                <h2 id="circuit-model-heading" style="margin-top: 30px;">‚öôÔ∏è Circuit Model</h2>

                <div class="form-group">
                    <label for="modelType">Select Model</label>
                    <select id="modelType" aria-describedby="model-help">
                        <option value="auto">üîç Auto (Best Fit)</option>
                        <option value="R">R (Resistor only)</option>
                        <option value="RC">R-C (Series)</option>
                        <option value="RpC">R||C (Parallel)</option>
                        <option value="RRC">R-(R||C) (Randles)</option>
                        <option value="RRCW">R-(R||C)-W (Randles + Warburg)</option>
                        <option value="RCRC">R-(R||C)-(R||C) (Two RC)</option>
                        <option value="RRCRC">R-(R||C)-(R||C)-(R||C) (Three RC)</option>
                        <option value="CPE">R-(R||CPE) (Constant Phase Element)</option>
                    </select>
                    <small id="model-help" style="color: #666; font-size: 0.8em;">Choose a circuit model or use Auto to find the best fit</small>
                </div>

                <div class="form-group">
                    <label for="initialFreq">Initial Frequency (Hz)</label>
                    <input type="number" id="initialFreq" value="1000" min="0.001" step="any" aria-describedby="freq-help">
                    <small id="freq-help" style="color: #666; font-size: 0.8em;">Starting frequency for optimization (Hz)</small>
                </div>

                <button type="button" onclick="fitModel()" style="width: 100%; background: #28a745;">Fit Model</button>
                <div id="fitStatus" role="status" aria-live="polite"></div>

                <h2 id="debug-heading" style="margin-top: 30px;">üß™ Debug Test</h2>
                <div class="form-group">
                    <label for="debugModel">Test Model</label>
                    <select id="debugModel">
                        <option value="RRC">R-(R||C) (Randles)</option>
                        <option value="RRCW">R-(R||C)-W (Randles + Warburg)</option>
                        <option value="RCRC">R-(R||C)-(R||C) (Two RC)</option>
                        <option value="RRCRC">R-(R||C)-(R||C)-(R||C) (Three RC)</option>
                        <option value="CPE">R-(R||CPE) (Constant Phase Element)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="noiseLevel">Noise Level (%)</label>
                    <input type="number" id="noiseLevel" value="2" min="0" max="20" step="0.5">
                    <small style="color: #666; font-size: 0.8em;">Add random noise to simulate real measurement conditions</small>
                </div>
                <button type="button" onclick="runDebugTest()" style="width: 100%; background: #6c757d;">Run Debug Test</button>
                <div id="debugStatus" role="status" aria-live="polite"></div>
            </div>

            <!-- Results Panel -->
            <div class="panel" role="region" aria-labelledby="results-heading">
                <h2 id="results-heading">üìà Fit Results</h2>
                <div id="fitResults" aria-live="polite"></div>
            </div>

            <!-- Nyquist Plot -->
            <div class="panel full-width" role="region" aria-labelledby="nyquist-heading">
                <h2 id="nyquist-heading">Nyquist Plot (Z' vs -Z")</h2>
                <div id="nyquistPlot" class="plot-container" role="img" aria-label="Nyquist plot showing real vs imaginary impedance"></div>
            </div>

            <!-- Bode Plot -->
            <div class="panel full-width" role="region" aria-labelledby="bode-heading">
                <h2 id="bode-heading">Bode Plot</h2>
                <div class="two-col">
                    <div id="bodeMagnitudePlot" class="plot-container" role="img" aria-label="Bode magnitude plot showing impedance vs frequency"></div>
                    <div id="bodePhase" class="plot-container" role="img" aria-label="Bode phase plot showing phase angle vs frequency"></div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Global data storage
        let eisData = {
            frequency: [],
            zReal: [],
            zImag: [],
            zMag: [],
            zPhase: []
        };

        // Initialize file upload and auto-parse functionality
        document.addEventListener('DOMContentLoaded', function() {
            initFileUpload();
            initAutoParse();
        });

        function initAutoParse() {
            const dataInput = document.getElementById('dataInput');
            let parseTimeout;

            // Auto-parse when data is pasted or typed (with debounce)
            dataInput.addEventListener('input', () => {
                clearTimeout(parseTimeout);
                parseTimeout = setTimeout(() => {
                    if (dataInput.value.trim()) {
                        parseData();
                    }
                }, 500); // 500ms debounce
            });
        }

        function initFileUpload() {
            const dropZone = document.getElementById('fileDropZone');
            const fileInput = document.getElementById('fileInput');

            // Click to upload
            dropZone.addEventListener('click', () => fileInput.click());

            // Keyboard accessibility
            dropZone.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    fileInput.click();
                }
            });

            // Drag and drop
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                const file = e.dataTransfer.files[0];
                if (file) handleFileUpload(file);
            });

            // File input change
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) handleFileUpload(file);
            });
        }

        function handleFileUpload(file) {
            const status = document.getElementById('fileStatus');
            const dropZone = document.getElementById('fileDropZone');

            // Validate file type
            const validTypes = ['.csv', '.txt', '.tsv'];
            const ext = '.' + file.name.split('.').pop().toLowerCase();
            if (!validTypes.includes(ext)) {
                status.textContent = 'Error: Please upload CSV or TXT file';
                status.style.color = '#dc3545';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById('dataInput').value = e.target.result;
                status.textContent = `‚úì Loaded: ${file.name}`;
                status.style.color = '#28a745';
                dropZone.classList.add('loaded');
                parseData();
            };
            reader.onerror = () => {
                status.textContent = 'Error reading file';
                status.style.color = '#dc3545';
            };
            reader.readAsText(file);
        }

        function parseData() {
            const input = document.getElementById('dataInput').value.trim();

            if (!input) {
                updateStatus('dataStatus', 'No data entered. Paste data or upload a file.', 'error');
                return;
            }

            try {
                const lines = input.split('\n').filter(l => l.trim());
                eisData = { frequency: [], zReal: [], zImag: [], zMag: [], zPhase: [] };

                let skippedLines = 0;
                let headerSkipped = false;

                // First pass: collect raw data to detect format
                const rawData = [];
                for (let line of lines) {
                    const parts = line.trim().split(/[\s\t,]+/).map(p => parseFloat(p));
                    if (isNaN(parts[0])) {
                        if (!headerSkipped) headerSkipped = true;
                        continue;
                    }
                    if (parts.length >= 3 && !parts.slice(0, 3).some(isNaN) && parts[0] > 0) {
                        rawData.push(parts);
                    } else {
                        skippedLines++;
                    }
                }

                if (rawData.length === 0) {
                    updateStatus('dataStatus', 'No valid data found. Expected: Frequency, Z\'/|Z|, Z"/Phase', 'error');
                    return;
                }

                // Auto-detect format by comparing column 2 (Z' or |Z|) and column 3 (Z" or Phase)
                const col2Values = rawData.map(r => r[1]);
                const col3Values = rawData.map(r => r[2]);
                const col2Avg = col2Values.reduce((a, b) => a + b, 0) / col2Values.length;
                const col3Avg = col3Values.reduce((a, b) => a + b, 0) / col3Values.length;
                const col3Max = Math.max(...col3Values.map(Math.abs));
                const col2Max = Math.max(...col2Values);

                // Heuristics to distinguish formats:
                // 1. Phase angles: typically -90 to 0 degrees, all values bounded by ¬±90
                // 2. For |Z|/Phase: |Z| >> |Phase| (impedance magnitude much larger than phase angle)
                // 3. For Z'/Z": Z' and Z" are similar magnitude (both in ohms)
                const col3InPhaseRange = col3Max <= 90;
                const magnitudeRatio = col2Avg / Math.max(col3Max, 0.1);

                // If col3 is in phase range AND col2 is much larger than col3, it's likely |Z|/Phase
                // If col3 values are similar magnitude to col2, it's likely Z'/Z"
                const looksLikePhase = col3InPhaseRange && magnitudeRatio > 3;
                const format = looksLikePhase ? 'freq_zmag_phase' : 'zreal_zimag';

                // Parse data according to detected format
                for (const parts of rawData) {
                    if (format === 'zreal_zimag') {
                        eisData.frequency.push(parts[0]);
                        eisData.zReal.push(parts[1]);
                        eisData.zImag.push(parts[2]);
                    } else {
                        // freq_zmag_phase
                        eisData.frequency.push(parts[0]);
                        const mag = parts[1];
                        const phase = parts[2] * Math.PI / 180;
                        eisData.zReal.push(mag * Math.cos(phase));
                        eisData.zImag.push(-mag * Math.sin(phase));
                    }
                }

                // Calculate magnitude and phase
                eisData.zMag = eisData.zReal.map((r, i) => Math.sqrt(r*r + eisData.zImag[i]*eisData.zImag[i]));
                eisData.zPhase = eisData.zReal.map((r, i) => Math.atan2(-eisData.zImag[i], r) * 180 / Math.PI);

                const formatName = format === 'zreal_zimag' ? "Z'/Z\"" : "|Z|/Phase";
                let statusMsg = `Loaded ${eisData.frequency.length} points (${formatName} format)`;
                if (skippedLines > 0) {
                    statusMsg += ` (${skippedLines} skipped)`;
                }
                updateStatus('dataStatus', statusMsg, 'success');
                plotNyquist();
                plotBode();
            } catch (e) {
                updateStatus('dataStatus', `Parse error: ${e.message}. Check data format.`, 'error');
                console.error('Parse error:', e);
            }
        }

        // Model registry for easy lookup
        const modelRegistry = {
            'R': { name: 'R (Resistor)', fit: fitRModel, predict: predictR, params: 1 },
            'RC': { name: 'R-C (Series)', fit: fitRCModel, predict: predictRC, params: 2 },
            'RpC': { name: 'R||C (Parallel)', fit: fitRpCModel, predict: predictRpC, params: 2 },
            'RRC': { name: 'R-(R||C) (Randles)', fit: fitRRCModel, predict: predictRRC, params: 3 },
            'RRCW': { name: 'R-(R||C)-W (Randles+Warburg)', fit: fitRRCWModel, predict: predictRRCW, params: 4 },
            'RCRC': { name: 'R-(R||C)-(R||C) (Two RC)', fit: fitRCRCModel, predict: predictRCRC, params: 5 },
            'RRCRC': { name: 'R-(R||C)-(R||C)-(R||C) (Three RC)', fit: fitRRCRCModel, predict: predictRRCRC, params: 7 },
            'CPE': { name: 'R-(R||CPE)', fit: fitCPEModel, predict: predictCPE, params: 4 }
        };

        function fitModel() {
            if (eisData.frequency.length === 0) {
                updateStatus('fitStatus', 'No data loaded', 'error');
                return;
            }

            let modelType = document.getElementById('modelType').value;
            const omega = eisData.frequency.map(f => 2 * Math.PI * f);

            try {
                let fitParams, predicted, selectedModel;

                if (modelType === 'auto') {
                    // Auto-select best model
                    const result = autoSelectModel(omega);
                    modelType = result.modelType;
                    fitParams = result.fitParams;
                    predicted = result.predicted;
                    selectedModel = modelRegistry[modelType].name;
                    updateStatus('fitStatus', `Auto-selected: ${selectedModel}`, 'success');
                } else {
                    const model = modelRegistry[modelType];
                    fitParams = model.fit(omega);
                    predicted = omega.map(w => model.predict(fitParams, w));
                    selectedModel = model.name;
                }

                const chiSquared = calcChiSquared(predicted);
                displayFitResults(fitParams, chiSquared, selectedModel);
                plotFit(predicted);
            } catch (e) {
                updateStatus('fitStatus', `Fit error: ${e.message}`, 'error');
                console.error('Fit error:', e);
            }
        }

        function autoSelectModel(omega) {
            const modelsToTry = ['RRC', 'RCRC', 'RRCW', 'CPE', 'RRCRC', 'RpC', 'RC'];
            let bestModel = null;
            let bestAIC = Infinity;
            let bestParams = null;
            let bestPredicted = null;

            for (const modelType of modelsToTry) {
                try {
                    const model = modelRegistry[modelType];
                    const fitParams = model.fit(omega);
                    const predicted = omega.map(w => model.predict(fitParams, w));

                    // Calculate AIC (Akaike Information Criterion) for model comparison
                    // AIC = n * ln(RSS/n) + 2k, where k is number of parameters
                    const rss = eisData.zReal.reduce((sum, r, i) => {
                        return sum + Math.pow(r - predicted[i].real, 2) + Math.pow(eisData.zImag[i] - predicted[i].imag, 2);
                    }, 0);
                    const n = eisData.zReal.length * 2; // Real + Imag points
                    const k = model.params;
                    const aic = n * Math.log(rss / n) + 2 * k;

                    if (aic < bestAIC) {
                        bestAIC = aic;
                        bestModel = modelType;
                        bestParams = fitParams;
                        bestPredicted = predicted;
                    }
                } catch (e) {
                    console.warn(`Model ${modelType} failed:`, e.message);
                }
            }

            return {
                modelType: bestModel,
                fitParams: bestParams,
                predicted: bestPredicted,
                aic: bestAIC
            };
        }

        function calcChiSquared(predicted) {
            const residuals = eisData.zReal.map((r, i) => ({
                real: r - predicted[i].real,
                imag: eisData.zImag[i] - predicted[i].imag
            }));
            return residuals.reduce((sum, r) => sum + r.real*r.real + r.imag*r.imag, 0) / eisData.zReal.length;
        }

        // Simple R model
        function fitRModel(omega) {
            const avgR = eisData.zReal.reduce((a, b) => a + b) / eisData.zReal.length;
            return { R: avgR };
        }
        function predictR(params, omega) {
            return { real: params.R, imag: 0 };
        }

        function fitRCModel(omega) {
            // Estimate initial parameters from data
            const R_est = Math.max(...eisData.zReal);
            const C_est = estimateCapacitance(omega);

            // Use iterative refinement
            return nelderMead(
                (params) => calcError(params, omega, predictRC),
                { R: R_est, C: C_est },
                { R: R_est * 0.3, C: C_est * 0.5 }
            );
        }

        function fitRRCModel(omega) {
            // Estimate initial parameters from data characteristics
            const R0_est = Math.min(...eisData.zReal); // High frequency intercept
            const R_total = Math.max(...eisData.zReal);
            const R1_est = R_total - R0_est;
            const C_est = estimateCapacitance(omega);

            return nelderMead(
                (params) => calcError(params, omega, predictRRC),
                { R0: R0_est, R1: R1_est, C: C_est },
                { R0: R0_est * 0.3, R1: R1_est * 0.3, C: C_est * 0.5 }
            );
        }

        function fitRCRCModel(omega) {
            // Estimate from data
            const R0_est = Math.min(...eisData.zReal);
            const R_total = Math.max(...eisData.zReal);
            const R1_est = (R_total - R0_est) * 0.6;
            const R2_est = (R_total - R0_est) * 0.4;
            const C_est = estimateCapacitance(omega);

            return nelderMead(
                (params) => calcError(params, omega, predictRCRC),
                { R0: R0_est, R1: R1_est, C1: C_est, R2: R2_est, C2: C_est * 5 },
                { R0: R0_est * 0.3, R1: R1_est * 0.3, C1: C_est * 0.5, R2: R2_est * 0.3, C2: C_est * 2 }
            );
        }

        // Parallel R||C model
        function fitRpCModel(omega) {
            const R_est = Math.max(...eisData.zReal);
            const C_est = estimateCapacitance(omega);
            return nelderMead(
                (params) => calcError(params, omega, predictRpC),
                { R: R_est, C: C_est },
                { R: R_est * 0.3, C: C_est * 0.5 }
            );
        }
        function predictRpC(params, omega) {
            const denom = 1 + Math.pow(omega * params.R * params.C, 2);
            return {
                real: params.R / denom,
                imag: -(omega * params.R * params.R * params.C) / denom
            };
        }

        // Randles with Warburg: R0 + (R1 || C) + W
        function fitRRCWModel(omega) {
            const R0_est = Math.min(...eisData.zReal);
            const R_total = Math.max(...eisData.zReal);
            const R1_est = (R_total - R0_est) * 0.5;
            const C_est = estimateCapacitance(omega);
            const W_est = (R_total - R0_est) * 0.3;

            return nelderMead(
                (params) => calcError(params, omega, predictRRCW),
                { R0: R0_est, R1: R1_est, C: C_est, W: W_est },
                { R0: R0_est * 0.3, R1: R1_est * 0.3, C: C_est * 0.5, W: W_est * 0.5 }
            );
        }
        function predictRRCW(params, omega) {
            // R0 + parallel(R1, C) + Warburg
            const denom = 1 + Math.pow(omega * params.R1 * params.C, 2);
            const parReal = params.R1 / denom;
            const parImag = -(omega * params.R1 * params.R1 * params.C) / denom;
            // Warburg: Z_w = W/sqrt(omega) * (1 - j)
            const warburgFactor = params.W / Math.sqrt(omega);
            return {
                real: params.R0 + parReal + warburgFactor,
                imag: parImag - warburgFactor
            };
        }

        // Three RC model: R0 + (R1||C1) + (R2||C2) + (R3||C3)
        // Uses multi-start optimization due to 7 parameters
        function fitRRCRCModel(omega) {
            const R0_est = Math.min(...eisData.zReal);
            const R_total = Math.max(...eisData.zReal);
            const R_range = R_total - R0_est;
            const C_est = estimateCapacitance(omega);

            // Try multiple starting configurations
            const startConfigs = [
                // Spread capacitances evenly on log scale
                { C1: C_est * 0.1, C2: C_est, C3: C_est * 10 },
                { C1: C_est * 0.01, C2: C_est * 0.1, C3: C_est },
                { C1: C_est, C2: C_est * 10, C3: C_est * 100 },
                // Different R distributions
                { R1: R_range * 0.5, R2: R_range * 0.3, R3: R_range * 0.2 },
                { R1: R_range * 0.33, R2: R_range * 0.33, R3: R_range * 0.34 },
            ];

            let bestParams = null;
            let bestError = Infinity;

            for (const config of startConfigs) {
                const initial = {
                    R0: R0_est,
                    R1: config.R1 || R_range * 0.4,
                    C1: config.C1 || C_est * 0.1,
                    R2: config.R2 || R_range * 0.35,
                    C2: config.C2 || C_est,
                    R3: config.R3 || R_range * 0.25,
                    C3: config.C3 || C_est * 10
                };

                const steps = {
                    R0: Math.max(R0_est * 0.5, 1),
                    R1: initial.R1 * 0.5,
                    C1: initial.C1 * 0.5,
                    R2: initial.R2 * 0.5,
                    C2: initial.C2 * 0.5,
                    R3: initial.R3 * 0.5,
                    C3: initial.C3 * 0.5
                };

                try {
                    const params = nelderMead(
                        (p) => calcError(p, omega, predictRRCRC),
                        initial,
                        steps,
                        800
                    );
                    const error = calcError(params, omega, predictRRCRC);
                    if (error < bestError) {
                        bestError = error;
                        bestParams = params;
                    }
                } catch (e) {
                    console.warn('Three RC fit attempt failed:', e);
                }
            }

            return bestParams || {
                R0: R0_est, R1: R_range * 0.4, C1: C_est * 0.1,
                R2: R_range * 0.35, C2: C_est, R3: R_range * 0.25, C3: C_est * 10
            };
        }
        function predictRRCRC(params, omega) {
            const par1 = predictParallel(params.R1, params.C1, omega);
            const par2 = predictParallel(params.R2, params.C2, omega);
            const par3 = predictParallel(params.R3, params.C3, omega);
            return {
                real: params.R0 + par1.real + par2.real + par3.real,
                imag: par1.imag + par2.imag + par3.imag
            };
        }

        // Constant Phase Element model: R0 + (R1 || CPE)
        function fitCPEModel(omega) {
            const R0_est = Math.min(...eisData.zReal);
            const R_total = Math.max(...eisData.zReal);
            const R1_est = R_total - R0_est;
            const C_est = estimateCapacitance(omega);

            return nelderMead(
                (params) => calcError(params, omega, predictCPE),
                { R0: R0_est, R1: R1_est, Q: C_est, n: 0.85 },
                { R0: R0_est * 0.3, R1: R1_est * 0.3, Q: C_est * 0.5, n: 0.1 },
                800  // More iterations for CPE
            );
        }
        function predictCPE(params, omega) {
            // Use admittance approach for cleaner calculation
            const Q = params.Q;
            const n = Math.min(Math.max(params.n, 0.1), 1); // Clamp n between 0.1 and 1

            // Admittance of CPE: Y_CPE = Q*(jœâ)^n = Q*œâ^n * (cos(nœÄ/2) + j*sin(nœÄ/2))
            const yCpeReal = Q * Math.pow(omega, n) * Math.cos(n * Math.PI / 2);
            const yCpeImag = Q * Math.pow(omega, n) * Math.sin(n * Math.PI / 2);

            // Total admittance (parallel): Y = 1/R1 + Y_CPE
            const yTotalReal = 1 / params.R1 + yCpeReal;
            const yTotalImag = yCpeImag;

            // Convert back to impedance: Z = 1/Y = Y* / |Y|^2
            const yMag2 = yTotalReal * yTotalReal + yTotalImag * yTotalImag;
            const zParReal = yTotalReal / yMag2;
            const zParImag = -yTotalImag / yMag2;

            return {
                real: params.R0 + zParReal,
                imag: zParImag
            };
        }

        function estimateCapacitance(omega) {
            // Find frequency at max -Z" (characteristic frequency)
            let maxImag = 0;
            let freqAtMax = omega[0];
            for (let i = 0; i < omega.length; i++) {
                if (-eisData.zImag[i] > maxImag) {
                    maxImag = -eisData.zImag[i];
                    freqAtMax = omega[i];
                }
            }
            // At characteristic frequency: omega * R * C ‚âà 1
            const R_est = Math.max(...eisData.zReal) - Math.min(...eisData.zReal);
            return 1 / (freqAtMax * Math.max(R_est, 1));
        }

        function calcError(params, omega, predictFn) {
            let error = 0;
            for (let i = 0; i < omega.length; i++) {
                const pred = predictFn(params, omega[i]);
                error += Math.pow(eisData.zReal[i] - pred.real, 2) + Math.pow(eisData.zImag[i] - pred.imag, 2);
            }
            return error;
        }

        // Nelder-Mead simplex optimization
        function nelderMead(costFn, initial, stepSizes, maxIter = 500, tol = 1e-8) {
            const keys = Object.keys(initial);
            const n = keys.length;

            // Convert to array form for optimization
            const toArray = (obj) => keys.map(k => obj[k]);
            const toObj = (arr) => {
                const obj = {};
                keys.forEach((k, i) => obj[k] = Math.abs(arr[i])); // Ensure positive
                return obj;
            };

            // Initialize simplex
            const x0 = toArray(initial);
            const steps = toArray(stepSizes);
            const simplex = [x0];

            for (let i = 0; i < n; i++) {
                const xi = [...x0];
                xi[i] += steps[i];
                simplex.push(xi);
            }

            // Evaluate initial simplex
            let values = simplex.map(x => costFn(toObj(x)));

            const alpha = 1, gamma = 2, rho = 0.5, sigma = 0.5;

            for (let iter = 0; iter < maxIter; iter++) {
                // Sort by cost
                const order = values.map((v, i) => [v, i]).sort((a, b) => a[0] - b[0]);
                const sorted = order.map(o => simplex[o[1]]);
                const sortedVals = order.map(o => o[0]);

                for (let i = 0; i <= n; i++) {
                    simplex[i] = sorted[i];
                    values[i] = sortedVals[i];
                }

                // Check convergence
                if (Math.abs(values[n] - values[0]) < tol) break;

                // Centroid (excluding worst)
                const centroid = new Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        centroid[j] += simplex[i][j] / n;
                    }
                }

                // Reflection
                const reflected = centroid.map((c, j) => c + alpha * (c - simplex[n][j]));
                const reflectedVal = costFn(toObj(reflected));

                if (reflectedVal >= values[0] && reflectedVal < values[n-1]) {
                    simplex[n] = reflected;
                    values[n] = reflectedVal;
                } else if (reflectedVal < values[0]) {
                    // Expansion
                    const expanded = centroid.map((c, j) => c + gamma * (reflected[j] - c));
                    const expandedVal = costFn(toObj(expanded));
                    if (expandedVal < reflectedVal) {
                        simplex[n] = expanded;
                        values[n] = expandedVal;
                    } else {
                        simplex[n] = reflected;
                        values[n] = reflectedVal;
                    }
                } else {
                    // Contraction
                    const contracted = centroid.map((c, j) => c + rho * (simplex[n][j] - c));
                    const contractedVal = costFn(toObj(contracted));
                    if (contractedVal < values[n]) {
                        simplex[n] = contracted;
                        values[n] = contractedVal;
                    } else {
                        // Shrink
                        for (let i = 1; i <= n; i++) {
                            simplex[i] = simplex[i].map((x, j) => simplex[0][j] + sigma * (x - simplex[0][j]));
                            values[i] = costFn(toObj(simplex[i]));
                        }
                    }
                }
            }

            // Return best
            const bestIdx = values.indexOf(Math.min(...values));
            return toObj(simplex[bestIdx]);
        }

        function predictRC(params, omega) {
            // R-C series impedance: Z = R - i/(omega*C)
            return {
                real: params.R,
                imag: -1 / (omega * params.C)
            };
        }

        function predictRRC(params, omega) {
            // R0 + (R1 || (1/jœâC))
            const R1 = params.R1;
            const C = params.C;
            
            // Parallel: R || C impedance = R / (1 + jœâRC)
            const denom = 1 + Math.pow(omega * R1 * C, 2);
            const parReal = R1 / denom;
            const parImag = -(omega * R1 * R1 * C) / denom;
            
            return {
                real: params.R0 + parReal,
                imag: parImag
            };
        }

        function predictRCRC(params, omega) {
            // R0 + (R1 || C1) + (R2 || C2)
            const par1 = predictParallel(params.R1, params.C1, omega);
            const par2 = predictParallel(params.R2, params.C2, omega);
            
            return {
                real: params.R0 + par1.real + par2.real,
                imag: par1.imag + par2.imag
            };
        }

        function predictParallel(R, C, omega) {
            const denom = 1 + Math.pow(omega * R * C, 2);
            return {
                real: R / denom,
                imag: -(omega * R * R * C) / denom
            };
        }

        function displayFitResults(params, chiSquared, modelName) {
            let html = '<div class="results">';
            if (modelName) {
                html += `<div style="background: #e8f4fd; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-weight: 500; color: #0066cc;">üìä Model: ${modelName}</div>`;
            }
            html += '<h3>Fitted Parameters</h3>';

            for (const [key, value] of Object.entries(params)) {
                let unit = '';
                if (key === 'n') unit = ''; // CPE exponent is dimensionless
                else if (key === 'W') unit = ' Œ©¬∑s‚Åª‚Å∞¬∑‚Åµ'; // Warburg coefficient
                else if (key === 'Q') unit = ' S¬∑s‚Åø'; // CPE pseudo-capacitance
                else if (key.includes('R')) unit = ' Œ©';
                else if (key.includes('C')) unit = ' F';

                const displayValue = Math.abs(value) < 0.001 ? value.toExponential(3) : value.toFixed(3);
                html += `<div class="result-row"><span class="result-label">${key}</span><span class="result-value">${displayValue}${unit}</span></div>`;
            }

            html += `<div class="result-row"><span class="result-label">œá¬≤/N</span><span class="result-value">${chiSquared.toExponential(3)}</span></div>`;
            html += '</div>';

            document.getElementById('fitResults').innerHTML = html;
            updateStatus('fitStatus', 'Fit completed', 'success');
        }

        function plotNyquist() {
            const trace = {
                x: eisData.zReal,
                y: eisData.zImag.map(z => -z),
                mode: 'markers+lines',
                name: 'EIS Data',
                marker: { size: 6, color: '#667eea' },
                line: { color: '#667eea', width: 2 }
            };

            const layout = {
                title: 'Nyquist Plot',
                xaxis: { title: "Z' (Œ©)" },
                yaxis: { title: "-Z\" (Œ©)" },
                hovermode: 'closest',
                margin: { t: 40, b: 40, l: 60, r: 20 }
            };

            Plotly.newPlot('nyquistPlot', [trace], layout, { responsive: true });
        }

        function plotBode() {
            const magTrace = {
                x: eisData.frequency,
                y: eisData.zMag,
                mode: 'lines+markers',
                name: '|Z|',
                line: { color: '#667eea' }
            };

            const phaseTrace = {
                x: eisData.frequency,
                y: eisData.zPhase,
                mode: 'lines+markers',
                name: 'Phase',
                line: { color: '#764ba2' }
            };

            const magLayout = {
                title: 'Impedance Magnitude',
                xaxis: { title: 'Frequency (Hz)', type: 'log' },
                yaxis: { title: '|Z| (Œ©)', type: 'log' },
                hovermode: 'x unified',
                margin: { t: 40, b: 40, l: 60, r: 20 }
            };

            const phaseLayout = {
                title: 'Phase Angle',
                xaxis: { title: 'Frequency (Hz)', type: 'log' },
                yaxis: { title: 'Phase (¬∞)' },
                hovermode: 'x unified',
                margin: { t: 40, b: 40, l: 60, r: 20 }
            };

            Plotly.newPlot('bodeMagnitudePlot', [magTrace], magLayout, { responsive: true });
            Plotly.newPlot('bodePhase', [phaseTrace], phaseLayout, { responsive: true });
        }

        function plotFit(predicted) {
            // Calculate R¬≤ (coefficient of determination)
            const meanReal = eisData.zReal.reduce((a, b) => a + b, 0) / eisData.zReal.length;
            const meanImag = eisData.zImag.reduce((a, b) => a + b, 0) / eisData.zImag.length;

            let ssTot = 0, ssRes = 0;
            for (let i = 0; i < eisData.zReal.length; i++) {
                ssTot += Math.pow(eisData.zReal[i] - meanReal, 2) + Math.pow(eisData.zImag[i] - meanImag, 2);
                ssRes += Math.pow(eisData.zReal[i] - predicted[i].real, 2) + Math.pow(eisData.zImag[i] - predicted[i].imag, 2);
            }
            const rSquared = Math.max(0, 1 - ssRes / ssTot);
            const rSquaredPct = (rSquared * 100).toFixed(1);

            const nyquistData = [{
                x: eisData.zReal,
                y: eisData.zImag.map(z => -z),
                mode: 'markers',
                name: 'Experimental',
                marker: { size: 6, color: '#667eea' }
            }, {
                x: predicted.map(p => p.real),
                y: predicted.map(p => -p.imag),
                mode: 'lines',
                name: `Fitted (R¬≤ = ${rSquaredPct}%)`,
                line: { color: '#ff6b6b', width: 2, dash: 'dash' }
            }];

            const layout = {
                title: 'Nyquist Plot - Fit Overlay',
                xaxis: { title: "Z' (Œ©)" },
                yaxis: { title: "-Z\" (Œ©)" },
                hovermode: 'closest',
                margin: { t: 40, b: 40, l: 60, r: 20 }
            };

            Plotly.newPlot('nyquistPlot', nyquistData, layout, { responsive: true });
        }

        // True parameters for debug tests
        const debugTrueParams = {
            'RRC': { R0: 75, R1: 150, C: 2.5e-6 },
            'RRCW': { R0: 60, R1: 120, C: 3e-6, W: 50 },
            'RCRC': { R0: 50, R1: 120, C1: 1.5e-6, R2: 80, C2: 8e-6 },
            'RRCRC': { R0: 40, R1: 100, C1: 5e-7, R2: 80, C2: 3e-6, R3: 60, C3: 2e-5 },
            'CPE': { R0: 70, R1: 180, Q: 3e-6, n: 0.82 }
        };

        function runDebugTest() {
            const modelType = document.getElementById('debugModel').value;
            const noiseLevel = parseFloat(document.getElementById('noiseLevel').value) / 100;

            // Get true parameters for selected model
            const trueParams = debugTrueParams[modelType];
            const model = modelRegistry[modelType];

            if (!trueParams || !model) {
                updateStatus('debugStatus', `Model ${modelType} not configured for testing`, 'error');
                return;
            }

            // Generate frequency range (log scale from 0.01 Hz to 10 kHz)
            const frequencies = [];
            for (let exp = -2; exp <= 4; exp += 0.25) {
                frequencies.push(Math.pow(10, exp));
            }

            // Generate ideal impedance data using the model's predict function
            const mockData = [];
            for (const freq of frequencies) {
                const omega = 2 * Math.PI * freq;
                const z = model.predict(trueParams, omega);

                // Add noise
                const noiseFactor = 1 + (Math.random() - 0.5) * 2 * noiseLevel;
                const noiseFactorImag = 1 + (Math.random() - 0.5) * 2 * noiseLevel;

                mockData.push({
                    freq: freq,
                    zReal: z.real * noiseFactor,
                    zImag: z.imag * noiseFactorImag
                });
            }

            // Format as tab-separated data and load into textarea
            const dataStr = mockData.map(d => `${d.freq}\t${d.zReal.toFixed(4)}\t${d.zImag.toFixed(4)}`).join('\n');
            document.getElementById('dataInput').value = dataStr;

            // Parse the data (format auto-detected)
            parseData();

            // Set the model type to match
            document.getElementById('modelType').value = modelType;

            // Fit the model using the registry
            const omega = eisData.frequency.map(f => 2 * Math.PI * f);
            const fitParams = model.fit(omega);
            const predicted = omega.map(w => model.predict(fitParams, w));

            // Calculate fit quality
            const chiSquared = calcChiSquared(predicted);

            // Calculate parameter recovery accuracy
            const paramErrors = {};
            let totalError = 0;
            let paramCount = 0;

            for (const [key, trueValue] of Object.entries(trueParams)) {
                const fittedValue = fitParams[key];
                const percentError = Math.abs((fittedValue - trueValue) / trueValue) * 100;
                paramErrors[key] = {
                    true: trueValue,
                    fitted: fittedValue,
                    error: percentError
                };
                totalError += percentError;
                paramCount++;
            }

            const avgError = totalError / paramCount;
            const score = Math.max(0, 100 - avgError);

            // Display debug results
            let html = '<div class="results"><h3>üß™ Debug Test Results</h3>';
            html += `<div class="result-row" style="background: ${score >= 80 ? '#d4edda' : score >= 50 ? '#fff3cd' : '#f8d7da'}; padding: 10px; border-radius: 4px; margin-bottom: 10px;">`;
            html += `<span class="result-label" style="font-size: 1.1em;">Overall Score</span>`;
            html += `<span class="result-value" style="font-size: 1.2em; font-weight: bold;">${score.toFixed(1)}%</span></div>`;

            html += '<h4 style="margin-top: 15px; color: #555;">Parameter Recovery</h4>';
            html += '<table style="width: 100%; font-size: 0.85em; border-collapse: collapse;">';
            html += '<tr style="border-bottom: 2px solid #ddd;"><th style="text-align: left; padding: 5px;">Param</th><th>True</th><th>Fitted</th><th>Error</th></tr>';

            for (const [key, data] of Object.entries(paramErrors)) {
                const errorColor = data.error < 10 ? '#28a745' : data.error < 25 ? '#ffc107' : '#dc3545';
                const trueDisplay = data.true < 0.001 ? data.true.toExponential(2) : data.true.toFixed(2);
                const fittedDisplay = data.fitted < 0.001 ? data.fitted.toExponential(2) : data.fitted.toFixed(2);

                html += `<tr style="border-bottom: 1px solid #eee;">`;
                html += `<td style="padding: 5px; font-weight: 500;">${key}</td>`;
                html += `<td style="text-align: center; font-family: monospace;">${trueDisplay}</td>`;
                html += `<td style="text-align: center; font-family: monospace;">${fittedDisplay}</td>`;
                html += `<td style="text-align: center; color: ${errorColor}; font-weight: 500;">${data.error.toFixed(1)}%</td>`;
                html += `</tr>`;
            }
            html += '</table>';

            html += `<div class="result-row" style="margin-top: 10px;"><span class="result-label">œá¬≤/N</span><span class="result-value">${chiSquared.toExponential(3)}</span></div>`;
            html += `<div class="result-row"><span class="result-label">Noise Level</span><span class="result-value">${(noiseLevel * 100).toFixed(1)}%</span></div>`;
            html += `<div class="result-row"><span class="result-label">Data Points</span><span class="result-value">${frequencies.length}</span></div>`;
            html += '</div>';

            document.getElementById('fitResults').innerHTML = html;
            plotFit(predicted);

            const scoreEmoji = score >= 80 ? '‚úÖ' : score >= 50 ? '‚ö†Ô∏è' : '‚ùå';
            updateStatus('debugStatus', `${scoreEmoji} Test complete: ${score.toFixed(1)}% accuracy`, score >= 80 ? 'success' : score >= 50 ? 'info' : 'error');
        }

        function updateStatus(elementId, message, type) {
            const el = document.getElementById(elementId);
            el.className = `status ${type}`;
            el.textContent = message;
        }
    </script>
</body>
</html>

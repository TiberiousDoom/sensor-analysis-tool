<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Statistical analysis tool for sensor response data with KPI calculations, time series visualization, correlation analysis, and regression modeling">
    <title>Sensor Statistical Analysis v1.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <!-- Plotly.js for charts -->
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #111827;
            --bg-tertiary: #1a2332;
            --accent-cyan: #06b6d4;
            --accent-emerald: #10b981;
            --accent-amber: #f59e0b;
            --accent-rose: #f43f5e;
            --accent-violet: #8b5cf6;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-color: #1e293b;
            --glow-cyan: 0 0 20px rgba(6, 182, 212, 0.3);
            --glow-emerald: 0 0 20px rgba(16, 185, 129, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            position: relative;
        }
        .home-btn {
            position: absolute;
            top: 0;
            left: 0;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 8px 16px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.9em;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background 0.2s, border-color 0.2s;
        }
        .home-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--accent-cyan);
        }

        header::before {
            content: '';
            position: absolute;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(6, 182, 212, 0.1) 0%, transparent 70%);
            pointer-events: none;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-emerald));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        /* Drop Zones */
        .drop-zones {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .drop-zone {
            background: var(--bg-secondary);
            border: 2px dashed var(--border-color);
            border-radius: 16px;
            padding: 2.5rem;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .drop-zone::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.05), rgba(16, 185, 129, 0.05));
            opacity: 0;
            transition: opacity 0.3s;
        }

        .drop-zone:hover::before,
        .drop-zone.drag-over::before {
            opacity: 1;
        }

        .drop-zone:hover,
        .drop-zone.drag-over {
            border-color: var(--accent-cyan);
            box-shadow: var(--glow-cyan);
        }

        .drop-zone.loaded {
            border-color: var(--accent-emerald);
            border-style: solid;
        }

        .drop-zone-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.7;
        }

        .drop-zone-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .drop-zone-subtitle {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .drop-zone-status {
            margin-top: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent-emerald);
        }

        .drop-zone input[type="file"] {
            display: none;
        }

        /* Settings Panel */
        .settings-panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            display: none;
        }

        .settings-panel.visible {
            display: block;
        }

        .settings-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--accent-cyan);
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .setting-item label {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .setting-item input,
        .setting-item select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.6rem 1rem;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
        }

        .setting-item input:focus,
        .setting-item select:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        /* KPI Cards */
        .kpi-section {
            display: none;
            margin-bottom: 2rem;
        }

        .kpi-section.visible {
            display: block;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .section-title::before {
            content: '';
            width: 4px;
            height: 24px;
            background: linear-gradient(180deg, var(--accent-cyan), var(--accent-emerald));
            border-radius: 2px;
        }

        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1rem;
        }

        .kpi-card {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.25rem;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .kpi-card:hover {
            border-color: var(--accent-cyan);
            transform: translateY(-2px);
        }

        .kpi-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }

        .kpi-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--accent-cyan);
        }

        .kpi-unit {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-left: 0.25rem;
        }

        /* Charts Section */
        .charts-section {
            display: none;
        }

        .charts-section.visible {
            display: block;
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .chart-grid.full-width {
            grid-template-columns: 1fr;
        }

        .chart-container {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .chart-container.large {
            grid-column: span 2;
        }

        .chart-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .chart-title .badge {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            background: var(--accent-violet);
            border-radius: 4px;
            font-weight: 500;
        }

        .chart-plot {
            width: 100%;
            height: 350px;
        }

        .chart-plot.tall {
            height: 450px;
        }

        .chart-interpretation, .model-interpretation {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            background: rgba(99, 102, 241, 0.1);
            border-left: 3px solid var(--accent-violet);
            border-radius: 0 8px 8px 0;
            font-size: 0.85rem;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .chart-interpretation strong, .model-interpretation strong {
            color: var(--text-primary);
        }

        .interpretation-good {
            border-left-color: var(--accent-emerald);
            background: rgba(16, 185, 129, 0.1);
        }

        .interpretation-moderate {
            border-left-color: var(--accent-amber);
            background: rgba(245, 158, 11, 0.1);
        }

        .interpretation-weak {
            border-left-color: var(--accent-rose);
            background: rgba(244, 63, 94, 0.1);
        }

        .interpretation-highlight {
            display: inline-block;
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
            font-weight: 600;
        }

        .highlight-positive {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-emerald);
        }

        .highlight-negative {
            background: rgba(244, 63, 94, 0.2);
            color: var(--accent-rose);
        }

        .highlight-neutral {
            background: rgba(99, 102, 241, 0.2);
            color: var(--accent-violet);
        }

        /* Regression Panel */
        .regression-section {
            display: none;
            margin-top: 2rem;
        }

        .regression-section.visible {
            display: block;
        }

        .regression-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1.5rem;
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-radius: 16px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 200px;
        }

        .control-group label {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .control-group select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: var(--text-primary);
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.95rem;
            cursor: pointer;
        }

        .control-group select:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .regression-results {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            overflow-x: auto;
            max-width: 100%;
        }

        .result-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 1.25rem;
            border: 1px solid var(--border-color);
            min-width: 0;
            overflow-x: auto;
        }

        .result-card h3 {
            font-size: 1.1rem;
            margin-bottom: 1rem;
            color: var(--accent-cyan);
        }

        .result-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: auto;
        }

        .result-table th,
        .result-table td {
            padding: 0.4rem 0.5rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .result-table th {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .result-table td {
            color: var(--text-primary);
        }

        .stat-highlight {
            color: var(--accent-emerald);
            font-weight: 600;
        }

        .stat-significant {
            color: var(--accent-amber);
        }

        /* Tooltips */
        .tooltip-container {
            position: relative;
            display: inline-block;
        }

        .tooltip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            font-size: 10px;
            color: var(--text-muted);
            cursor: help;
            margin-left: 4px;
        }

        .tooltip-text {
            visibility: hidden;
            position: absolute;
            z-index: 100;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            width: 250px;
            line-height: 1.4;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
        }

        .tooltip-text::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--bg-tertiary);
        }

        .tooltip-container:hover .tooltip-text {
            visibility: visible;
        }

        /* Data Table */
        .data-preview {
            display: none;
            margin-bottom: 2rem;
        }

        .data-preview.visible {
            display: block;
        }

        .data-table-container {
            background: var(--bg-secondary);
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            max-height: 400px;
            overflow-y: auto;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        .data-table th {
            position: sticky;
            top: 0;
            background: var(--bg-tertiary);
            padding: 0.75rem;
            text-align: left;
            color: var(--text-secondary);
            font-weight: 600;
            border-bottom: 2px solid var(--border-color);
        }

        .data-table td {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .data-table tr:hover td {
            background: var(--bg-tertiary);
        }

        /* Loading Spinner */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: var(--text-muted);
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        .tab {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.95rem;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s;
        }

        .tab:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
        }

        .tab.active {
            color: var(--accent-cyan);
            background: var(--bg-secondary);
            font-weight: 600;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .chart-grid {
                grid-template-columns: 1fr;
            }
            .chart-container.large {
                grid-column: span 1;
            }
        }

        @media (max-width: 992px) {
            .regression-results {
                grid-template-columns: 1fr;
            }
            .chart-plot { height: 320px; }
            .chart-plot.tall { height: 400px; }
        }

        @media (max-width: 768px) {
            .drop-zones {
                grid-template-columns: 1fr;
            }
            .container {
                padding: 1rem;
            }
            h1 {
                font-size: 1.75rem;
            }
            .tabs {
                flex-wrap: wrap;
            }
            .tab {
                flex: 1 0 45%;
                text-align: center;
            }
        }

        /* Accessibility: Focus styles */
        .drop-zone:focus,
        .tab:focus,
        button:focus,
        select:focus,
        input:focus {
            outline: 2px solid var(--accent-cyan);
            outline-offset: 2px;
        }

        .tooltip-icon:focus {
            outline: 2px solid var(--accent-cyan);
            outline-offset: 1px;
        }

        /* Screen reader only class */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        /* Export button styles */
        .export-btn {
            background: var(--accent-violet);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-left: 1rem;
        }

        .export-btn:hover {
            background: var(--accent-cyan);
            transform: translateY(-1px);
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;z-index:9999;padding:1rem;background:var(--accent-cyan);color:white;text-decoration:none;font-weight:bold;border-radius:4px;">Skip to main content</a>
    <style>.skip-link:focus{position:fixed;left:50%;transform:translateX(-50%);top:10px;width:auto;height:auto;overflow:visible;}</style>
    <noscript>
        <div style="padding: 2rem; text-align: center; background: #fee2e2; color: #991b1b; font-family: sans-serif;">
            <h2>JavaScript Required</h2>
            <p>The Statistical Analysis tool requires JavaScript to be enabled. Please enable JavaScript in your browser settings and reload the page.</p>
        </div>
    </noscript>
    <div id="main-content" class="container" role="main">
        <header>
            <a href="../index.html" class="home-btn">‚Üê Home</a>
            <h1>‚ö° Sensor Statistical Analysis</h1>
            <p class="subtitle">Drop your data files to begin analysis</p>
            <span style="font-size: 0.75em; opacity: 0.5;">v1.0</span>
        </header>

        <!-- Drop Zones -->
        <div class="drop-zones" role="region" aria-label="File upload area">
            <div class="drop-zone" id="buildDataZone" role="button" tabindex="0" aria-label="Upload build data file with design parameters">
                <div class="drop-zone-icon" aria-hidden="true">üìã</div>
                <div class="drop-zone-title">Build Data</div>
                <div class="drop-zone-subtitle">Design parameters (CSV, XLSX, TXT)</div>
                <div style="font-size: 0.7em; color: var(--text-muted); margin-top: 4px;">Recommended: under 10MB</div>
                <div class="drop-zone-status" id="buildDataStatus" role="status" aria-live="polite"></div>
                <input type="file" id="buildDataFile" accept=".csv,.xlsx,.xls,.txt" aria-label="Build data file input">
            </div>
            <div class="drop-zone" id="sensorDataZone" role="button" tabindex="0" aria-label="Upload sensor response time series data">
                <div class="drop-zone-icon" aria-hidden="true">üìà</div>
                <div class="drop-zone-title">Sensor Response Data</div>
                <div class="drop-zone-subtitle">Time series (Time in col A, sensors in B+)</div>
                <div style="font-size: 0.7em; color: var(--text-muted); margin-top: 4px;">Recommended: under 10MB</div>
                <div class="drop-zone-status" id="sensorDataStatus" role="status" aria-live="polite"></div>
                <input type="file" id="sensorDataFile" accept=".csv,.xlsx,.xls,.txt" aria-label="Sensor data file input">
            </div>
        </div>
        
        <!-- Matching Status -->
        <div id="matchingStatus" style="display: none; background: var(--bg-secondary); border-radius: 12px; padding: 1rem; margin-bottom: 1rem; border: 1px solid var(--border-color);">
            <div style="font-weight: 600; margin-bottom: 0.5rem;">üîó Sensor Matching Status</div>
            <div id="matchingDetails" style="font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; color: var(--text-secondary);"></div>
        </div>

        <!-- Data Report Button -->
        <div id="debugButtonContainer" style="display: none; margin-bottom: 1rem;">
            <button id="generateDebugReportBtn" style="background: var(--accent-amber); color: #000; border: none; padding: 0.75rem 1.5rem; border-radius: 8px; cursor: pointer; font-family: 'Space Grotesk', sans-serif; font-weight: 600;">
                üìä Generate Data Report
            </button>
        </div>

        <!-- Test/Debug Buttons (commented out - uncomment for debugging)
        <div style="display: flex; gap: 1rem; margin-bottom: 1.5rem;">
            <button id="loadTestDataBtn" style="background: var(--accent-violet); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 8px; cursor: pointer; font-family: 'Space Grotesk', sans-serif; font-weight: 600;">
                üß™ Load Test Data
            </button>
            <button id="runDiagnosticsBtn" style="background: var(--accent-amber); color: #000; border: none; padding: 0.75rem 1.5rem; border-radius: 8px; cursor: pointer; font-family: 'Space Grotesk', sans-serif; font-weight: 600; display: none;">
                üîç Run Diagnostics
            </button>
        </div>
        -->
        
        <!-- Diagnostics Report (commented out - uncomment for debugging)
        <div id="diagnosticsReport" style="display: none; background: var(--bg-secondary); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem; border: 1px solid var(--border-color); max-height: 500px; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <div style="font-weight: 600; font-size: 1.1rem;">üìã Diagnostics Report</div>
                <button id="closeDiagnosticsBtn" style="background: transparent; border: 1px solid var(--border-color); color: var(--text-secondary); padding: 0.25rem 0.75rem; border-radius: 4px; cursor: pointer;">Close</button>
            </div>
            <div id="diagnosticsContent" style="font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; white-space: pre-wrap;"></div>
        </div>
        -->

        <!-- Settings Panel -->
        <div class="settings-panel" id="settingsPanel">
            <div class="settings-title">‚öôÔ∏è Analysis Settings</div>
            <div class="settings-grid">
                <div class="setting-item">
                    <label for="baselinePoints">
                        Baseline Points
                        <span class="tooltip-container">
                            <span class="tooltip-icon" tabindex="0" role="button" aria-label="Help: Baseline Points">?</span>
                            <span class="tooltip-text" role="tooltip">Number of initial time points used to calculate baseline mean and standard deviation. These points should be before any stimulus is applied.</span>
                        </span>
                    </label>
                    <input type="number" id="baselinePoints" value="10" min="3" max="50">
                </div>
                <div class="setting-item">
                    <label for="peakWindow">
                        Peak Window (seconds)
                        <span class="tooltip-container">
                            <span class="tooltip-icon" tabindex="0" role="button" aria-label="Help: Peak Window">?</span>
                            <span class="tooltip-text" role="tooltip">Duration after the peak to measure signal stability (Peak StdDev). A 5-second window captures the plateau region around maximum response.</span>
                        </span>
                    </label>
                    <input type="number" id="peakWindow" value="5" min="1" max="20">
                </div>
                <div class="setting-item">
                    <label for="finalAvgPoints">
                        Final Avg Points
                        <span class="tooltip-container">
                            <span class="tooltip-icon" tabindex="0" role="button" aria-label="Help: Final Average Points">?</span>
                            <span class="tooltip-text" role="tooltip">Number of data points at the end of recording to average for the "final value" used in recovery calculations.</span>
                        </span>
                    </label>
                    <input type="number" id="finalAvgPoints" value="5" min="1" max="20">
                </div>
                <div class="setting-item">
                    <label for="responseThreshold">
                        Response Threshold (œÉ)
                        <span class="tooltip-container">
                            <span class="tooltip-icon" tabindex="0" role="button" aria-label="Help: Response Threshold">?</span>
                            <span class="tooltip-text" role="tooltip">Minimum peak height as multiples of baseline standard deviation. Signals below baseline + (threshold √ó œÉ) are marked as non-responsive. Use higher values to filter noise.</span>
                        </span>
                    </label>
                    <input type="number" id="responseThreshold" value="3" min="1" max="100" step="0.5">
                </div>
            </div>
        </div>

        <!-- Tabs -->
        <div class="tabs" id="mainTabs" style="display: none;">
            <button class="tab active" data-tab="overview">Overview</button>
            <button class="tab" data-tab="timeseries">Time Series</button>
            <button class="tab" data-tab="distributions">Distributions</button>
            <button class="tab" data-tab="correlations">Correlations</button>
            <button class="tab" data-tab="regression">Regression</button>
            <button class="tab" data-tab="data">Data Tables</button>
        </div>

        <!-- Overview Tab -->
        <div id="overviewTab" class="tab-content">
            <div class="kpi-section" id="kpiSection">
                <div class="section-header">
                    <h2 class="section-title">Summary Statistics</h2>
                    <button type="button" class="export-btn" onclick="exportKPIsToCSV()" aria-label="Export KPI data to CSV file">üì• Export KPIs (CSV)</button>
                </div>
                <div class="kpi-grid" id="kpiGrid"></div>
            </div>

            <div class="charts-section" id="overviewCharts">
                <div class="chart-grid">
                    <div class="chart-container large">
                        <div class="chart-title">üìä Response Magnitude by Sensor</div>
                        <div class="chart-plot" id="responseMagChart"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">üéØ Response vs Baseline</div>
                        <div class="chart-plot" id="responseVsBaselineChart"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">‚è±Ô∏è Response Timing</div>
                        <div class="chart-plot" id="timingChart"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Time Series Tab -->
        <div id="timeseriesTab" class="tab-content" style="display: none;">
            <div class="charts-section visible">
                <div class="regression-controls" id="timeseriesFilters">
                    <div class="control-group">
                        <label>Material</label>
                        <select id="tsFilterMaterial">
                            <option value="all">All</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Seal Method</label>
                        <select id="tsFilterSeal">
                            <option value="all">All</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Mix Method</label>
                        <select id="tsFilterMix">
                            <option value="all">All</option>
                        </select>
                    </div>
                    <div class="control-group" style="display: flex; align-items: flex-end;">
                        <button id="tsResetFilters" style="background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-secondary); padding: 0.5rem 1rem; border-radius: 8px; cursor: pointer;">Reset Filters</button>
                    </div>
                </div>
                <div class="chart-grid full-width">
                    <div class="chart-container">
                        <div class="chart-title">üìà All Sensor Responses <span class="badge">Interactive</span></div>
                        <div class="chart-plot tall" id="allSensorsChart"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">üî• Heatmap: Sensor Response Over Time</div>
                        <div class="chart-plot tall" id="heatmapChart"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">üìâ Normalized Response Curves</div>
                        <div class="chart-plot tall" id="normalizedChart"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Distributions Tab -->
        <div id="distributionsTab" class="tab-content" style="display: none;">
            <div class="charts-section visible">
                <div class="chart-grid">
                    <div class="chart-container">
                        <div class="chart-title">üìä Response Magnitude Distribution</div>
                        <div class="chart-plot" id="responseHistogram"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">üìä T90 Rise Time Distribution</div>
                        <div class="chart-plot" id="t90Histogram"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">
                            ‚è±Ô∏è T90 Rise by Material
                            <span class="tooltip-container">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltip-text">Time to reach 90% of peak response, grouped by material composition (Carbon/Silver ratio).</span>
                            </span>
                        </div>
                        <div class="chart-plot" id="t90CombinedBoxplot"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">
                            ‚è±Ô∏è T50 Recovery by Material
                            <span class="tooltip-container">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltip-text">Time to recover 50% from peak back toward baseline, grouped by material composition.</span>
                            </span>
                        </div>
                        <div class="chart-plot" id="t50rCombinedBoxplot"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">
                            üìâ Last 30s % Change by Material
                            <span class="tooltip-container">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltip-text">Percent change in signal over the last 30 seconds, normalized to the response magnitude above baseline. Formula: (end - start) / (start - baseline) √ó 100. Indicates drift or continued recovery as a fraction of the response.</span>
                            </span>
                        </div>
                        <div class="chart-plot" id="last30ChangeBoxplot"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">
                            üìä Response by Trace √ó Reference Combination
                            <span class="tooltip-container">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltip-text">Compares all 6 combinations of Trace Type (Carbon, Silver, None) and Reference Location (Center, Side). Helps identify interaction effects between these design choices.</span>
                            </span>
                        </div>
                        <div class="chart-plot" id="combinedBoxplot"></div>
                    </div>
                    <div class="chart-container large">
                        <div class="chart-title">
                            üéª KPI Violin Plots by Trace Type
                            <span class="tooltip-container">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltip-text">Violin plots combine a box plot with a density curve. The width shows how common values are at each level - wider = more sensors have that response. The white dot is the median, thick bar is interquartile range (25th-75th percentile), thin line extends to min/max.</span>
                            </span>
                        </div>
                        <div class="chart-plot tall" id="violinChart"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Correlations Tab -->
        <div id="correlationsTab" class="tab-content" style="display: none;">
            <div class="charts-section visible">
                <div class="chart-grid">
                    <div class="chart-container large">
                        <div class="chart-title">
                            üî• Correlation Heatmap: Design Parameters vs KPIs
                            <span class="tooltip-container">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltip-text">Shows Pearson correlations between design parameters and sensor KPIs. Red = positive correlation, Blue = negative. Categorical encodings: C Ratio = Carbon fraction (1=Carbon, 0=Silver); Seal = seal method (1=Snap, 0=Screw); Mix = mix method (1=FlackTek, 0=Hand). Positive correlation means the "1" category is associated with higher values.</span>
                            </span>
                        </div>
                        <div class="chart-plot tall" id="correlationHeatmap"></div>
                        <div class="chart-interpretation" id="correlationHeatmapInterpretation"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">üìà W:C Ratio vs Response Magnitude</div>
                        <div class="chart-plot" id="wcVsResponseChart"></div>
                        <div class="chart-interpretation" id="wcVsResponseInterpretation"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">üìà W:C Ratio vs T90 Rise</div>
                        <div class="chart-plot" id="wcVsT90Chart"></div>
                        <div class="chart-interpretation" id="wcVsT90Interpretation"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">üìà Working SA vs Response</div>
                        <div class="chart-plot" id="workSaVsResponseChart"></div>
                        <div class="chart-interpretation" id="workSaVsResponseInterpretation"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">üîÆ 3D: W:C √ó W:R √ó Response</div>
                        <div class="chart-plot" id="scatter3dChart"></div>
                        <div class="chart-interpretation" id="scatter3dInterpretation"></div>
                    </div>
                    <div class="chart-container large">
                        <div class="chart-title">üìä Parallel Coordinates: All Parameters</div>
                        <div class="chart-plot tall" id="parallelChart"></div>
                        <div class="chart-interpretation" id="parallelChartInterpretation"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Regression Tab -->
        <div id="regressionTab" class="tab-content" style="display: none;">
            <div class="regression-section visible">
                <h2 class="section-title">Multiple Regression Analysis</h2>
                
                <div class="regression-controls">
                    <div class="control-group">
                        <label>Dependent Variable (Y)</label>
                        <select id="yVariable">
                            <option value="responseMag">Response Magnitude</option>
                            <option value="percentResponse">% Response</option>
                            <option value="t50Rise">T50 Rise (s)</option>
                            <option value="t90Rise">T90 Rise (s)</option>
                            <option value="riseRate">Rise Rate (V/s)</option>
                            <option value="percentRecovery">% Recovery</option>
                            <option value="t50R">T50 Recovery (s)</option>
                            <option value="t10R">T10 Recovery (s)</option>
                            <option value="recoveryRate">Recovery Rate</option>
                            <option value="snr">Signal-to-Noise Ratio</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Primary Predictor (X1)</label>
                        <select id="x1Variable">
                            <option value="wcRatio">W:C Ratio</option>
                            <option value="wrRatio">W:R Ratio</option>
                            <option value="workingSA">Working SA</option>
                            <option value="counterSA">Counter SA</option>
                            <option value="referenceSA">Reference SA</option>
                            <option value="totalSA">Total SA</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Secondary Predictor (X2)</label>
                        <select id="x2Variable">
                            <option value="none">None</option>
                            <option value="wcRatio">W:C Ratio</option>
                            <option value="wrRatio" selected>W:R Ratio</option>
                            <option value="workingSA">Working SA</option>
                            <option value="counterSA">Counter SA</option>
                            <option value="referenceSA">Reference SA</option>
                            <option value="totalSA">Total SA</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Include in Model 3</label>
                        <div style="display: flex; gap: 1rem; flex-wrap: wrap; padding-top: 0.25rem;">
                            <label style="display: flex; align-items: center; gap: 0.4rem; cursor: pointer; font-weight: normal;">
                                <input type="checkbox" id="includeMaterial" checked style="width: 16px; height: 16px; cursor: pointer;">
                                Material
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.4rem; cursor: pointer; font-weight: normal;">
                                <input type="checkbox" id="includeSeal" style="width: 16px; height: 16px; cursor: pointer;">
                                Seal
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.4rem; cursor: pointer; font-weight: normal;">
                                <input type="checkbox" id="includeMix" style="width: 16px; height: 16px; cursor: pointer;">
                                Mix
                            </label>
                        </div>
                    </div>
                </div>

                <div class="chart-grid">
                    <div class="chart-container">
                        <div class="chart-title" id="regressionScatterTitle">üìà Regression: X1 vs Y</div>
                        <div class="chart-plot" id="regressionScatter"></div>
                        <div class="chart-interpretation" id="regressionScatterInterpretation"></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title" id="residualPlotTitle">üìä Residual Plot</div>
                        <div class="chart-plot" id="residualPlot"></div>
                        <div class="chart-interpretation" id="residualPlotInterpretation"></div>
                    </div>
                </div>

                <div class="regression-results" id="regressionResults">
                    <div class="result-card">
                        <h3 id="model1Title">Model 1: Simple Regression</h3>
                        <table class="result-table" id="model1Table">
                            <thead>
                                <tr><th>Term</th><th>Coefficient</th><th>Std Error</th><th>t-stat</th></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <div style="margin-top: 1rem;">
                            <span class="stat-highlight">R¬≤ = <span id="model1R2">--</span></span>
                        </div>
                        <div class="model-interpretation" id="model1Interpretation"></div>
                    </div>
                    <div class="result-card">
                        <h3 id="model2Title">Model 2: Multiple Regression</h3>
                        <table class="result-table" id="model2Table">
                            <thead>
                                <tr><th>Term</th><th>Coefficient</th><th>Std Error</th><th>t-stat</th></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <div style="margin-top: 1rem;">
                            <span class="stat-highlight">R¬≤ = <span id="model2R2">--</span></span>
                            <span style="margin-left: 1rem;">Adj R¬≤ = <span id="model2AdjR2">--</span></span>
                        </div>
                        <div class="model-interpretation" id="model2Interpretation"></div>
                    </div>
                    <div class="result-card" id="model3Card" style="display: none;">
                        <h3 id="model3Title">Model 3: With Categoricals</h3>
                        <table class="result-table" id="model3Table">
                            <thead>
                                <tr><th>Term</th><th>Coefficient</th><th>Std Error</th><th>t-stat</th></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <div style="margin-top: 1rem;">
                            <span class="stat-highlight">R¬≤ = <span id="model3R2">--</span></span>
                            <span style="margin-left: 1rem;">Adj R¬≤ = <span id="model3AdjR2">--</span></span>
                        </div>
                        <div class="model-interpretation" id="model3Interpretation"></div>
                    </div>
                    <div class="result-card" id="vifCard" style="display: none;">
                        <h3>üìä Variance Inflation Factors (VIF)</h3>
                        <table class="result-table" id="vifTable">
                            <thead>
                                <tr><th>Variable</th><th>VIF</th><th>Multicollinearity</th></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <div class="model-interpretation" id="vifInterpretation"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Data Tab -->
        <div id="dataTab" class="tab-content" style="display: none;">
            <div class="data-preview visible">
                <h2 class="section-title">Build Data</h2>
                <div class="data-table-container">
                    <table class="data-table" id="buildDataTable">
                        <thead></thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
            <div class="data-preview visible" style="margin-top: 2rem;">
                <h2 class="section-title">Calculated KPIs</h2>
                <div class="data-table-container">
                    <table class="data-table" id="kpiDataTable">
                        <thead></thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global error handler for unhandled errors
        window.onerror = function(message, source, lineno, colno, error) {
            console.error('Unhandled error:', message, 'at', source, lineno);
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed;top:10px;left:50%;transform:translateX(-50%);background:var(--bg-tertiary);border:2px solid var(--accent-rose);color:var(--accent-rose);padding:1rem;border-radius:8px;z-index:10000;max-width:90%;font-family:inherit;';
            errorDiv.innerHTML = '<strong>An error occurred:</strong> ' + message + '<br><button onclick="this.parentElement.remove()" style="margin-top:0.5rem;padding:4px 12px;cursor:pointer;background:var(--accent-rose);color:white;border:none;border-radius:4px;">Dismiss</button>';
            document.body.appendChild(errorDiv);
            return false;
        };

        // Debug mode flag - set to true to enable debug console output
        const DEBUG = false;

        // Debug logging function - only outputs when DEBUG is true
        function debugLog(...args) {
            if (DEBUG) console.log(...args);
        }

        // Check if libraries loaded
        const loadErrors = [];
        if (typeof Papa === 'undefined') loadErrors.push('PapaParse');
        if (typeof XLSX === 'undefined') loadErrors.push('SheetJS');
        if (typeof Plotly === 'undefined') loadErrors.push('Plotly');
        
        if (loadErrors.length > 0) {
            console.error('Libraries failed to load:', loadErrors);
            document.addEventListener('DOMContentLoaded', function() {
                const header = document.querySelector('header');
                if (header) {
                    const errorDiv = document.createElement('div');
                    errorDiv.style.cssText = 'background: #1a2332; border: 2px solid #f43f5e; border-radius: 16px; padding: 2rem; margin: 2rem 0; text-align: center;';
                    errorDiv.innerHTML = `
                        <h2 style="color: #f43f5e; margin-bottom: 1rem;">‚ö†Ô∏è Libraries Failed to Load</h2>
                        <p style="color: #94a3b8; margin-bottom: 1rem;">Could not load: <strong>${loadErrors.join(', ')}</strong></p>
                        <p style="color: #94a3b8;">Check your internet connection and refresh, or try a local server.</p>
                    `;
                    header.after(errorDiv);
                }
            });
        }
        
        // Safe Plotly wrapper - calls Plotly.newPlot with error handling
        function safePlot(elementId, data, layout, config) {
            if (typeof Plotly === 'undefined') {
                console.error(`Cannot render ${elementId}: Plotly not loaded`);
                const el = document.getElementById(elementId);
                if (el) el.innerHTML = '<div style="color: #f43f5e; padding: 2rem; text-align: center;">Chart library not loaded.</div>';
                return;
            }
            try {
                Plotly.newPlot(elementId, data, layout, config);
            } catch (err) {
                console.error(`Error rendering ${elementId}:`, err);
            }
        }
        
        // Global data stores
        let buildData = null;
        let sensorData = null;
        let kpiData = null;
        let settings = {
            baselinePoints: 10,
            peakWindow: 5,
            finalAvgPoints: 5,
            responseThreshold: 3
        };

        // Plotly dark theme
        const plotlyLayout = {
            paper_bgcolor: '#111827',
            plot_bgcolor: '#111827',
            font: { color: '#f1f5f9', family: 'Space Grotesk' },
            xaxis: { gridcolor: '#1e293b', zerolinecolor: '#1e293b' },
            yaxis: { gridcolor: '#1e293b', zerolinecolor: '#1e293b' },
            margin: { t: 40, r: 20, b: 50, l: 60 }
        };

        const plotlyConfig = { responsive: true, displayModeBar: false };

        // Color palette for sensors
        const sensorColors = [
            '#06b6d4', '#10b981', '#f59e0b', '#f43f5e', '#8b5cf6',
            '#ec4899', '#14b8a6', '#84cc16', '#f97316', '#6366f1',
            '#22d3ee', '#4ade80', '#facc15', '#fb7185', '#a78bfa'
        ];

        // Initialize drop zones
        function initDropZones() {
            const zones = [
                { zone: 'buildDataZone', input: 'buildDataFile', handler: handleBuildData },
                { zone: 'sensorDataZone', input: 'sensorDataFile', handler: handleSensorData }
            ];

            zones.forEach(({ zone, input, handler }) => {
                const dropZone = document.getElementById(zone);
                const fileInput = document.getElementById(input);

                dropZone.addEventListener('click', () => fileInput.click());
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('drag-over');
                });
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('drag-over');
                });
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drag-over');
                    const file = e.dataTransfer.files[0];
                    if (file) handler(file, dropZone);
                });
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) handler(file, dropZone);
                });
            });
        }

        // Parse file (CSV, XLSX, TXT)
        async function parseFile(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            
            if (ext === 'xlsx' || ext === 'xls') {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const workbook = XLSX.read(e.target.result, { type: 'array' });
                        const sheetName = workbook.SheetNames[0];
                        const data = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });
                        resolve(data);
                    };
                    reader.readAsArrayBuffer(file);
                });
            } else {
                return new Promise((resolve) => {
                    Papa.parse(file, {
                        complete: (results) => resolve(results.data),
                        skipEmptyLines: true
                    });
                });
            }
        }

        // Find column index by matching header patterns
        function findColumnIndex(headers, patterns) {
            const normalizedHeaders = headers.map(h => String(h).toLowerCase().replace(/[_\s]+/g, ''));
            for (let i = 0; i < normalizedHeaders.length; i++) {
                const header = normalizedHeaders[i];
                for (const pattern of patterns) {
                    if (typeof pattern === 'string') {
                        if (header.includes(pattern.toLowerCase().replace(/[_\s]+/g, ''))) {
                            return i;
                        }
                    } else if (pattern instanceof RegExp) {
                        if (pattern.test(header)) {
                            return i;
                        }
                    }
                }
            }
            return -1;
        }

        // Handle Build Data upload
        async function handleBuildData(file, dropZone) {
            const status = document.getElementById('buildDataStatus');
            status.textContent = 'Parsing...';

            try {
                const rawData = await parseFile(file);

                debugLog('Build data raw rows:', rawData.length);
                debugLog('First row:', rawData[0]);

                // Find header row (contains "Cell" or "ID")
                let headerRow = 0;
                for (let i = 0; i < Math.min(10, rawData.length); i++) {
                    if (rawData[i] && rawData[i].some(cell => {
                        const cellStr = String(cell).toLowerCase();
                        return cellStr.includes('cell') || cellStr.includes('id');
                    })) {
                        headerRow = i;
                        break;
                    }
                }

                debugLog('Build data header row:', headerRow);
                debugLog('Header row contents:', rawData[headerRow]);

                const headers = rawData[headerRow].map(h => String(h).trim());
                const rows = rawData.slice(headerRow + 1).filter(row => row.length > 0 && row[0]);

                // Flexible column detection using pattern matching
                const colIndices = {
                    cellId: findColumnIndex(headers, ['cellid', 'cell_id', 'cell id', 'sensorid', 'sensor_id']),
                    // Direct Carbon_Ratio column (numeric values)
                    carbonRatio: findColumnIndex(headers, ['carbonratio', 'carbon_ratio']),
                    // Silver/Ag ratio column
                    agRatio: findColumnIndex(headers, ['agratio', 'ag_ratio', 'silverratio', 'silver_ratio']),
                    // Mixed method column (FlackTek, Hand, N/A)
                    mixed: findColumnIndex(headers, ['mixed', 'mixmethod', 'mix_method']),
                    // Sealed method column (Screw, Snap)
                    sealed: findColumnIndex(headers, ['sealed', 'sealmethod', 'seal_method', 'sealtype']),
                    // Legacy trace type column (string values like "Carbon", "Silver", or "1:0")
                    traceType: findColumnIndex(headers, ['tracetype', 'trace_type', 'carbonsilver', 'carbon-silver', 'carbon_silver']),
                    refLocation: findColumnIndex(headers, ['referencelocation', 'reflocation', 'stencilconfig', 'stencil_config', 'config']),
                    workingSA: findColumnIndex(headers, ['workingsa', 'working_sa', 'working sa']),
                    counterSA: findColumnIndex(headers, ['countersa', 'counter_sa', 'counter sa']),
                    referenceSA: findColumnIndex(headers, ['referencesa', 'reference_sa', 'reference sa'])
                };

                // Fall back to positional defaults if headers not found
                if (colIndices.cellId === -1) colIndices.cellId = 0;
                // carbonRatio can be -1 (not found) - we'll handle that in parsing
                if (colIndices.traceType === -1 && colIndices.carbonRatio === -1) colIndices.traceType = 1;
                // refLocation can be -1 (not found) - we'll default to 0 in parsing
                if (colIndices.workingSA === -1) colIndices.workingSA = headers.length >= 4 ? 3 : -1;
                if (colIndices.counterSA === -1) colIndices.counterSA = headers.length >= 5 ? 4 : -1;
                if (colIndices.referenceSA === -1) colIndices.referenceSA = headers.length >= 6 ? 5 : -1;

                debugLog('Detected column indices:', colIndices);
                debugLog('Build data rows:', rows.length);
                debugLog('First data row:', rows[0]);

                // Determine if we have direct Carbon_Ratio column or legacy trace type
                const hasDirectCarbonRatio = colIndices.carbonRatio !== -1;
                debugLog('Has direct Carbon_Ratio column:', hasDirectCarbonRatio);

                buildData = {
                    headers,
                    rows,
                    columnIndices: colIndices,
                    sensors: rows.map(r => String(r[colIndices.cellId]).trim()),
                    traceTypes: rows.map(r => {
                        // If we have direct carbon ratio column, use that value as the "trace type"
                        const colIdx = hasDirectCarbonRatio ? colIndices.carbonRatio : colIndices.traceType;
                        const raw = r[colIdx];
                        if (raw === undefined || raw === null || raw === '') {
                            return 'None';
                        }
                        const val = String(raw).trim().toLowerCase();
                        if (val === '' || val === 'nan' || val === 'undefined' || val === 'null' || val === 'none') {
                            return 'None';
                        }
                        return String(raw).trim();
                    }),
                    refLocations: rows.map(r => {
                        if (colIndices.refLocation === -1) return 'None';
                        const raw = r[colIndices.refLocation];
                        if (raw === undefined || raw === null || raw === '') {
                            return 'None';
                        }
                        const val = String(raw).trim().toLowerCase();
                        if (val === '' || val === 'nan' || val === 'undefined' || val === 'null') {
                            return 'None';
                        }
                        return String(raw).trim();
                    }),
                    workingSA: rows.map(r => colIndices.workingSA !== -1 ? (parseFloat(r[colIndices.workingSA]) || 0) : 0),
                    counterSA: rows.map(r => colIndices.counterSA !== -1 ? (parseFloat(r[colIndices.counterSA]) || 0) : 0),
                    referenceSA: rows.map(r => colIndices.referenceSA !== -1 ? (parseFloat(r[colIndices.referenceSA]) || 0) : 0)
                };
                
                debugLog('Parsed build sensors:', buildData.sensors.slice(0, 5));
                debugLog('Parsed trace types:', buildData.traceTypes.slice(0, 15));
                debugLog('Unique trace types:', [...new Set(buildData.traceTypes)]);
                
                // Calculate ratios
                buildData.wcRatio = buildData.workingSA.map((w, i) => 
                    buildData.counterSA[i] > 0 ? w / buildData.counterSA[i] : 0);
                buildData.wrRatio = buildData.workingSA.map((w, i) => 
                    buildData.referenceSA[i] > 0 ? w / buildData.referenceSA[i] : 0);
                buildData.totalSA = buildData.workingSA.map((w, i) => 
                    w + buildData.counterSA[i] + buildData.referenceSA[i]);
                
                // Create trace material variables
                // Supports: direct numeric (0.0-1.0), ratio format ("1:0", "4:1"), or legacy ("Carbon"/"Silver")
                buildData.traceCarbon = buildData.traceTypes.map(t => {
                    const val = String(t).trim();

                    // Check if it's a direct numeric value (e.g., "1.0", "0.8", "0")
                    const numVal = parseFloat(val);
                    if (!isNaN(numVal) && val.match(/^-?\d*\.?\d+$/)) {
                        return numVal;
                    }

                    // Check for ratio format (e.g., "1:0", "4:1", "1:4")
                    const ratioMatch = val.match(/^(\d+(?:\.\d+)?)\s*:\s*(\d+(?:\.\d+)?)$/);
                    if (ratioMatch) {
                        const carbon = parseFloat(ratioMatch[1]);
                        const silver = parseFloat(ratioMatch[2]);
                        const total = carbon + silver;
                        return total > 0 ? carbon / total : 0;
                    }

                    // Legacy format: check if string contains "carbon"
                    return val.toLowerCase().includes('carbon') ? 1 : 0;
                });
                buildData.traceSilver = buildData.traceTypes.map(t => {
                    const val = String(t).trim();

                    // Check if it's a direct numeric value - silver is 1 - carbon
                    const numVal = parseFloat(val);
                    if (!isNaN(numVal) && val.match(/^-?\d*\.?\d+$/)) {
                        return 1 - numVal;
                    }

                    // Check for ratio format (e.g., "1:0", "4:1", "1:4")
                    const ratioMatch = val.match(/^(\d+(?:\.\d+)?)\s*:\s*(\d+(?:\.\d+)?)$/);
                    if (ratioMatch) {
                        const carbon = parseFloat(ratioMatch[1]);
                        const silver = parseFloat(ratioMatch[2]);
                        const total = carbon + silver;
                        return total > 0 ? silver / total : 0;
                    }

                    // Legacy format: check if string contains "silver"
                    return val.toLowerCase().includes('silver') ? 1 : 0;
                });
                // Stencil config / reference side - handle various formats or missing column
                buildData.refSide = buildData.refLocations.map(r => {
                    const val = String(r).trim().toLowerCase();
                    // Check for numeric value first
                    const numVal = parseFloat(val);
                    if (!isNaN(numVal) && val.match(/^-?\d*\.?\d+$/)) {
                        return numVal;
                    }
                    // Check for "side" in the value
                    if (val.includes('side')) return 1;
                    // Check for common stencil config patterns (e.g., "wrc" vs "Wrc")
                    if (val.includes('wrc') || val.includes('w') && val.includes('c')) return 1;
                    return 0;
                });

                // Mixed method column (FlackTek, Hand, N/A)
                buildData.mixedMethod = rows.map(r => {
                    if (colIndices.mixed === -1) return 'N/A';
                    const raw = r[colIndices.mixed];
                    if (raw === undefined || raw === null || raw === '') return 'N/A';
                    const val = String(raw).trim();
                    if (val.toLowerCase() === 'n/a' || val.toLowerCase() === 'na' || val.toLowerCase() === 'none') return 'N/A';
                    return val;
                });
                // Create dummy variables for mixed method
                buildData.isMixedFlackTek = buildData.mixedMethod.map(m =>
                    m.toLowerCase().includes('flacktek') ? 1 : 0);
                buildData.isMixedHand = buildData.mixedMethod.map(m =>
                    m.toLowerCase().includes('hand') ? 1 : 0);

                // Sealed method column (Screw, Snap)
                buildData.sealedMethod = rows.map(r => {
                    if (colIndices.sealed === -1) return 'N/A';
                    const raw = r[colIndices.sealed];
                    if (raw === undefined || raw === null || raw === '') return 'N/A';
                    const val = String(raw).trim();
                    if (val.toLowerCase() === 'n/a' || val.toLowerCase() === 'na' || val.toLowerCase() === 'none') return 'N/A';
                    return val;
                });
                // Create dummy variable for sealed method (1 = Snap, 0 = Screw/other)
                buildData.isSealedSnap = buildData.sealedMethod.map(s =>
                    s.toLowerCase().includes('snap') ? 1 : 0);

                debugLog('Mixed methods:', [...new Set(buildData.mixedMethod)]);
                debugLog('Sealed methods:', [...new Set(buildData.sealedMethod)]);

                status.textContent = `‚úì Loaded ${rows.length} sensors`;
                dropZone.classList.add('loaded');
                
                updateBuildDataTable();
                checkDataReady();
            } catch (err) {
                status.textContent = `Error: ${err.message}`;
                console.error(err);
            }
        }

        // Handle Sensor Data upload
        async function handleSensorData(file, dropZone) {
            const status = document.getElementById('sensorDataStatus');
            status.textContent = 'Parsing...';
            
            try {
                const rawData = await parseFile(file);
                
                // Find header row - look for "Time" in first column
                let headerRow = 0;
                for (let i = 0; i < Math.min(50, rawData.length); i++) {
                    if (rawData[i] && rawData[i][0]) {
                        const firstCell = String(rawData[i][0]).toLowerCase();
                        if (firstCell.includes('time')) {
                            headerRow = i;
                            break;
                        }
                    }
                }
                
                debugLog('Sensor data header row:', headerRow);
                debugLog('Header row contents:', rawData[headerRow]?.slice(0, 5));
                
                const headers = rawData[headerRow].map(h => String(h).trim());
                const rows = rawData.slice(headerRow + 1).filter(row => {
                    // Only keep rows where first column is a number (time value)
                    return row.length > 1 && !isNaN(parseFloat(row[0]));
                });
                
                sensorData = {
                    headers,
                    time: rows.map(r => parseFloat(r[0]) || 0),
                    sensors: {}
                };
                
                // Extract each sensor's data
                for (let i = 1; i < headers.length; i++) {
                    const sensorName = headers[i];
                    if (sensorName && sensorName.toLowerCase() !== 'time') {
                        sensorData.sensors[sensorName] = rows.map(r => parseFloat(r[i]) || 0);
                    }
                }
                
                debugLog('Parsed sensor names:', Object.keys(sensorData.sensors).slice(0, 5));
                
                status.textContent = `‚úì ${Object.keys(sensorData.sensors).length} sensors, ${rows.length} time points`;
                dropZone.classList.add('loaded');
                
                document.getElementById('settingsPanel').classList.add('visible');
                checkDataReady();
            } catch (err) {
                status.textContent = `Error: ${err.message}`;
                console.error(err);
            }
        }

        // Check if both datasets are loaded
        function checkDataReady() {
            if (buildData && sensorData) {
                // Debug: Log sensor names to help diagnose matching issues
                debugLog('=== SENSOR MATCHING DEBUG ===');
                debugLog('Build Data sensors (first 5):', buildData.sensors.slice(0, 5));
                debugLog('Sensor Data keys (first 5):', Object.keys(sensorData.sensors).slice(0, 5));
                
                // Normalize function
                const normalize = s => String(s).toLowerCase().replace(/[^a-z0-9]/g, '');
                
                // Show matching status in UI
                const buildNormalized = buildData.sensors.map(normalize);
                const kpiNormalized = Object.keys(sensorData.sensors).map(normalize);
                const buildSet = new Set(buildNormalized);
                const kpiSet = new Set(kpiNormalized);
                
                const matchedFromBuild = buildNormalized.filter(s => kpiSet.has(s)).length;
                const matchedFromKpi = kpiNormalized.filter(s => buildSet.has(s)).length;
                
                debugLog(`Build sensors matched: ${matchedFromBuild}/${buildData.sensors.length}`);
                debugLog(`KPI sensors matched: ${matchedFromKpi}/${Object.keys(sensorData.sensors).length}`);
                
                // Show in UI
                const statusDiv = document.getElementById('matchingStatus');
                const detailsDiv = document.getElementById('matchingDetails');
                statusDiv.style.display = 'block';
                
                if (matchedFromBuild > 0) {
                    statusDiv.style.borderColor = 'var(--accent-emerald)';
                    detailsDiv.innerHTML = `‚úÖ Matched <strong>${matchedFromBuild}</strong> of ${buildData.sensors.length} build sensors with ${Object.keys(sensorData.sensors).length} response sensors`;
                } else {
                    statusDiv.style.borderColor = 'var(--accent-rose)';
                    detailsDiv.innerHTML = `‚ùå No sensors matched!<br>
                        Build Data: ${buildData.sensors.slice(0,3).join(', ')}...<br>
                        Sensor Data: ${Object.keys(sensorData.sensors).slice(0,3).join(', ')}...<br>
                        <em>Ensure sensor names match between files.</em>`;
                }

                // Show data report button
                document.getElementById('debugButtonContainer').style.display = 'block';

                calculateKPIs();
                document.getElementById('mainTabs').style.display = 'flex';
                showTab('overview');
            }
        }

        // Calculate KPIs for all sensors
        function calculateKPIs() {
            settings.baselinePoints = parseInt(document.getElementById('baselinePoints').value);
            settings.peakWindow = parseInt(document.getElementById('peakWindow').value);
            settings.finalAvgPoints = parseInt(document.getElementById('finalAvgPoints').value);
            settings.responseThreshold = parseFloat(document.getElementById('responseThreshold').value);
            
            kpiData = {};
            const sensorNames = Object.keys(sensorData.sensors);
            
            sensorNames.forEach(sensor => {
                const values = sensorData.sensors[sensor];
                const time = sensorData.time;
                const n = settings.baselinePoints;
                
                // Baseline stats
                const baseline = values.slice(0, n);
                const baselineMean = mean(baseline);
                const baselineStd = std(baseline) || 0.0001; // Prevent division by zero
                
                // Peak detection
                const peakValue = Math.max(...values.filter(v => !isNaN(v)));
                const peakIndex = values.indexOf(peakValue);
                const peakTime = time[peakIndex];
                
                // Response magnitude
                const responseMag = peakValue - baselineMean;
                
                // Check if signal exceeds threshold
                const threshold = baselineMean + settings.responseThreshold * baselineStd;
                const isSignificant = peakValue > threshold;
                
                const percentResponse = baselineMean > 0 ? (responseMag / baselineMean) * 100 : 0;
                
                // Find response start time (when signal first rises significantly)
                // Use either 10% of response OR baseline + 3œÉ, whichever is larger
                const minResponseThreshold = baselineMean + Math.max(baselineStd * 3, responseMag * 0.1);
                let responseStartTime = peakTime; // Default to peak time if no clear start found
                let responseStartIndex = peakIndex;
                
                for (let i = n; i < peakIndex; i++) {
                    if (values[i] > minResponseThreshold) {
                        responseStartTime = time[i];
                        responseStartIndex = i;
                        break;
                    }
                }
                
                // Rise times (T50, T90) - calculate absolute times first
                const t50Target = baselineMean + 0.5 * responseMag;
                const t90Target = baselineMean + 0.9 * responseMag;
                const t50RiseAbs = findTimeAtValue(time, values, t50Target, 0, peakIndex, 1);
                const t90RiseAbs = findTimeAtValue(time, values, t90Target, 0, peakIndex, 1);
                
                // Relative times (from response start)
                const t50Rise = Math.max(0, t50RiseAbs - responseStartTime);
                const t90Rise = Math.max(0, t90RiseAbs - responseStartTime);
                
                const riseRate = (t90Rise - t50Rise) > 0 ? (0.4 * responseMag) / (t90Rise - t50Rise) : 0;
                
                // Peak stability
                const peakWindowEnd = Math.min(peakIndex + settings.peakWindow, values.length);
                const peakRegion = values.slice(peakIndex, peakWindowEnd);
                const peakStd = std(peakRegion);
                
                // Final value & recovery
                const finalRegion = values.slice(-settings.finalAvgPoints);
                const finalValue = mean(finalRegion);
                const recoveryMag = peakValue - finalValue;
                const percentRecovery = responseMag > 0 ? (recoveryMag / responseMag) * 100 : 0;

                // Recovery times (absolute values)
                const t50RecTarget = peakValue - 0.5 * recoveryMag;
                const t10RecTarget = peakValue - 0.9 * recoveryMag;
                const t50Recovery = findTimeAtValue(time, values, t50RecTarget, peakIndex, values.length, -1);
                const t10Recovery = findTimeAtValue(time, values, t10RecTarget, peakIndex, values.length, -1);

                // Relative recovery times from peak (T50R, T10R)
                const t50R = Math.max(0, t50Recovery - peakTime);  // Time to 50% recovery
                const t10R = Math.max(0, t10Recovery - peakTime);  // Time to 90% recovery (10% remaining)

                const recoveryRate = (t10Recovery - peakTime) > 0 ? recoveryMag / (t10Recovery - peakTime) : 0;

                // Percent change over last 30 seconds
                const maxTime = Math.max(...time);
                const last30Start = maxTime - 30;
                const last30StartIndex = time.findIndex(t => t >= last30Start);
                const last30EndIndex = time.length - 1;

                let last30PercentChange = 0;
                if (last30StartIndex >= 0 && last30StartIndex < last30EndIndex) {
                    const startValue = values[last30StartIndex];
                    const endValue = values[last30EndIndex];
                    const responseAtStart = startValue - baselineMean;
                    if (Math.abs(responseAtStart) > 0.0001) {
                        last30PercentChange = ((endValue - startValue) / responseAtStart) * 100;
                    }
                }

                // SNR
                const snr = baselineStd > 0 ? responseMag / baselineStd : 0;
                const responseNoise = peakStd > 0 ? responseMag / peakStd : 0;
                
                kpiData[sensor] = {
                    baselineMean, baselineStd, peakValue, peakTime,
                    responseMag, percentResponse, responseStartTime,
                    t50Rise, t90Rise, t50RiseAbs, t90RiseAbs, riseRate,
                    peakStd, finalValue, recoveryMag, percentRecovery,
                    t50Recovery, t10Recovery, t50R, t10R, recoveryRate,
                    last30PercentChange, snr, responseNoise,
                    isSignificant, threshold
                };
            });
            
            updateAllVisualizations();
        }

        // Helper functions
        function mean(arr) {
            const valid = arr.filter(v => !isNaN(v) && isFinite(v));
            return valid.length > 0 ? valid.reduce((a, b) => a + b, 0) / valid.length : 0;
        }

        function std(arr) {
            const m = mean(arr);
            const valid = arr.filter(v => !isNaN(v) && isFinite(v));
            if (valid.length < 2) return 0;
            const variance = valid.reduce((sum, v) => sum + Math.pow(v - m, 2), 0) / (valid.length - 1);
            return Math.sqrt(variance);
        }

        function median(arr) {
            const valid = arr.filter(v => !isNaN(v) && isFinite(v)).sort((a, b) => a - b);
            if (valid.length === 0) return 0;
            const mid = Math.floor(valid.length / 2);
            return valid.length % 2 ? valid[mid] : (valid[mid - 1] + valid[mid]) / 2;
        }

        function findTimeAtValue(time, values, target, startIdx, endIdx, direction) {
            if (direction === 1) {
                for (let i = startIdx; i < endIdx; i++) {
                    if (!isNaN(values[i]) && values[i] >= target) return time[i];
                }
            } else {
                for (let i = startIdx; i < endIdx; i++) {
                    if (!isNaN(values[i]) && values[i] <= target) return time[i];
                }
            }
            return time[Math.min(endIdx - 1, time.length - 1)] || 0;
        }

        // Linear regression
        function linearRegression(x, y) {
            const n = x.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
            
            for (let i = 0; i < n; i++) {
                sumX += x[i];
                sumY += y[i];
                sumXY += x[i] * y[i];
                sumX2 += x[i] * x[i];
                sumY2 += y[i] * y[i];
            }
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // R-squared
            const yMean = sumY / n;
            let ssTotal = 0, ssResidual = 0;
            for (let i = 0; i < n; i++) {
                const predicted = slope * x[i] + intercept;
                ssTotal += Math.pow(y[i] - yMean, 2);
                ssResidual += Math.pow(y[i] - predicted, 2);
            }
            const r2 = 1 - (ssResidual / ssTotal);
            
            // Standard errors
            const mse = ssResidual / (n - 2);
            const seSlope = Math.sqrt(mse / (sumX2 - sumX * sumX / n));
            const seIntercept = Math.sqrt(mse * (1/n + Math.pow(sumX/n, 2) / (sumX2 - sumX * sumX / n)));
            
            return { slope, intercept, r2, seSlope, seIntercept, residuals: y.map((yi, i) => yi - (slope * x[i] + intercept)) };
        }

        // Multiple regression using normal equations
        function multipleRegression(X, y) {
            // X is array of arrays (each row is [1, x1, x2, ...])
            // Returns coefficients, R2, standard errors
            const n = X.length;
            const p = X[0].length;
            
            // Add intercept column if not present
            const Xmat = X[0][0] === 1 ? X : X.map(row => [1, ...row]);
            const pAdj = Xmat[0].length;
            
            // X'X
            const XtX = [];
            for (let i = 0; i < pAdj; i++) {
                XtX[i] = [];
                for (let j = 0; j < pAdj; j++) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += Xmat[k][i] * Xmat[k][j];
                    }
                    XtX[i][j] = sum;
                }
            }
            
            // X'y
            const Xty = [];
            for (let i = 0; i < pAdj; i++) {
                let sum = 0;
                for (let k = 0; k < n; k++) {
                    sum += Xmat[k][i] * y[k];
                }
                Xty[i] = sum;
            }
            
            // Solve (X'X)^-1 * X'y using Gaussian elimination
            const coeffs = solveLinearSystem(XtX, Xty);
            
            // Calculate R2
            const yMean = mean(y);
            let ssTotal = 0, ssResidual = 0;
            const residuals = [];
            for (let i = 0; i < n; i++) {
                let predicted = 0;
                for (let j = 0; j < pAdj; j++) {
                    predicted += coeffs[j] * Xmat[i][j];
                }
                ssTotal += Math.pow(y[i] - yMean, 2);
                ssResidual += Math.pow(y[i] - predicted, 2);
                residuals.push(y[i] - predicted);
            }
            
            const r2 = 1 - (ssResidual / ssTotal);
            const adjR2 = 1 - ((1 - r2) * (n - 1) / (n - pAdj));
            
            // Standard errors (simplified)
            const mse = ssResidual / (n - pAdj);
            const XtXinv = invertMatrix(XtX);
            const stdErrors = XtXinv ? XtXinv.map((row, i) => Math.sqrt(mse * row[i])) : coeffs.map(() => 0);
            
            return { coeffs, r2, adjR2, stdErrors, residuals };
        }

        function solveLinearSystem(A, b) {
            const n = A.length;
            const aug = A.map((row, i) => [...row, b[i]]);
            
            // Forward elimination
            for (let i = 0; i < n; i++) {
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) maxRow = k;
                }
                [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];
                
                for (let k = i + 1; k < n; k++) {
                    const factor = aug[k][i] / aug[i][i];
                    for (let j = i; j <= n; j++) {
                        aug[k][j] -= factor * aug[i][j];
                    }
                }
            }
            
            // Back substitution
            const x = new Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = aug[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= aug[i][j] * x[j];
                }
                x[i] /= aug[i][i];
            }
            
            return x;
        }

        function invertMatrix(A) {
            const n = A.length;
            const aug = A.map((row, i) => [...row, ...Array(n).fill(0).map((_, j) => i === j ? 1 : 0)]);
            
            // Forward elimination
            for (let i = 0; i < n; i++) {
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) maxRow = k;
                }
                [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];
                
                if (Math.abs(aug[i][i]) < 1e-10) return null;
                
                const pivot = aug[i][i];
                for (let j = 0; j < 2 * n; j++) aug[i][j] /= pivot;
                
                for (let k = 0; k < n; k++) {
                    if (k !== i) {
                        const factor = aug[k][i];
                        for (let j = 0; j < 2 * n; j++) {
                            aug[k][j] -= factor * aug[i][j];
                        }
                    }
                }
            }
            
            return aug.map(row => row.slice(n));
        }

        // Calculate Variance Inflation Factors (VIF) for multicollinearity detection
        // VIF_j = 1 / (1 - R¬≤_j) where R¬≤_j is from regressing predictor j on all other predictors
        function calculateVIF(X, labels) {
            const n = X.length;
            const p = X[0].length;
            const vifs = [];

            for (let j = 0; j < p; j++) {
                // Get the j-th predictor as the response
                const yj = X.map(row => row[j]);

                // Get all other predictors as X matrix
                const Xothers = X.map(row => row.filter((_, idx) => idx !== j));

                if (Xothers[0].length === 0) {
                    // Only one predictor, VIF is 1
                    vifs.push({ variable: labels[j], vif: 1.0 });
                    continue;
                }

                // Calculate R¬≤ for regressing j on others
                const reg = multipleRegression(Xothers, yj);
                const r2 = reg.r2;

                // VIF = 1 / (1 - R¬≤)
                const vif = r2 >= 0.9999 ? Infinity : 1 / (1 - r2);
                vifs.push({ variable: labels[j], vif: isNaN(vif) ? 1.0 : vif });
            }

            return vifs;
        }

        // Interpret VIF value
        function interpretVIF(vif) {
            if (vif < 5) return { level: 'low', text: 'Low', class: 'good' };
            if (vif < 10) return { level: 'moderate', text: 'Moderate', class: 'warning' };
            return { level: 'high', text: 'High', class: 'danger' };
        }

        // Correlation coefficient
        function correlation(x, y) {
            const n = x.length;
            const mx = mean(x), my = mean(y);
            let num = 0, dx = 0, dy = 0;
            for (let i = 0; i < n; i++) {
                num += (x[i] - mx) * (y[i] - my);
                dx += Math.pow(x[i] - mx, 2);
                dy += Math.pow(y[i] - my, 2);
            }
            return num / Math.sqrt(dx * dy);
        }

        // One-way ANOVA
        function oneWayANOVA(groups) {
            // groups is an object: { groupName: [values], ... }
            const groupNames = Object.keys(groups);
            const k = groupNames.length; // number of groups

            // Calculate overall mean and group statistics
            const allValues = [];
            const groupStats = {};

            groupNames.forEach(name => {
                const values = groups[name].filter(v => !isNaN(v) && isFinite(v));
                groupStats[name] = {
                    n: values.length,
                    mean: mean(values),
                    values: values
                };
                allValues.push(...values);
            });

            const N = allValues.length; // total observations
            const grandMean = mean(allValues);

            // Sum of Squares Between (SSB)
            let ssb = 0;
            groupNames.forEach(name => {
                const gs = groupStats[name];
                ssb += gs.n * Math.pow(gs.mean - grandMean, 2);
            });

            // Sum of Squares Within (SSW)
            let ssw = 0;
            groupNames.forEach(name => {
                const gs = groupStats[name];
                gs.values.forEach(v => {
                    ssw += Math.pow(v - gs.mean, 2);
                });
            });

            // Total Sum of Squares (SST)
            const sst = ssb + ssw;

            // Degrees of freedom
            const dfBetween = k - 1;
            const dfWithin = N - k;
            const dfTotal = N - 1;

            // Mean Squares
            const msb = ssb / dfBetween;
            const msw = ssw / dfWithin;

            // F-statistic
            const F = msb / msw;

            // P-value approximation using F-distribution
            // Using approximation: p ‚âà exp(-0.5 * F) for quick estimation
            // For more accurate p-values, would need F-distribution CDF
            const pValue = fDistPValue(F, dfBetween, dfWithin);

            // Effect size: eta-squared (Œ∑¬≤) = SSB / SST
            const etaSquared = ssb / sst;

            return {
                ssb, ssw, sst,
                dfBetween, dfWithin, dfTotal,
                msb, msw,
                F, pValue,
                etaSquared,
                groupStats,
                grandMean,
                N, k
            };
        }

        // Approximate p-value for F-distribution
        function fDistPValue(F, df1, df2) {
            if (F <= 0) return 1;
            if (!isFinite(F)) return 0;

            // Use beta incomplete function approximation
            const x = df2 / (df2 + df1 * F);

            // Simple approximation using normal distribution for large df
            if (df1 > 1 && df2 > 100) {
                const z = Math.pow(F, 1/3) * (1 - 2/(9*df2)) - (1 - 2/(9*df1));
                const se = Math.sqrt(2/(9*df1) + 2/(9*df2) * Math.pow(F, 2/3));
                return 1 - normalCDF(z / se);
            }

            // For smaller df, use a rough approximation
            // This gives reasonable estimates for typical ANOVA scenarios
            const logP = -0.5 * F * df1 / Math.max(df2, 1);
            return Math.min(1, Math.max(0, Math.exp(logP)));
        }

        // Standard normal CDF approximation
        function normalCDF(x) {
            const a1 =  0.254829592;
            const a2 = -0.284496736;
            const a3 =  1.421413741;
            const a4 = -1.453152027;
            const a5 =  1.061405429;
            const p  =  0.3275911;

            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x) / Math.sqrt(2);

            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);

            return 0.5 * (1.0 + sign * y);
        }

        // Format p-value for display
        function formatPValue(p) {
            if (p < 0.001) return '< 0.001 ***';
            if (p < 0.01) return p.toFixed(3) + ' **';
            if (p < 0.05) return p.toFixed(3) + ' *';
            if (p < 0.1) return p.toFixed(3) + ' .';
            return p.toFixed(3);
        }

        // Tab switching
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');
            
            document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');
            document.getElementById(`${tabName}Tab`).style.display = 'block';
            
            // Trigger resize for Plotly charts
            setTimeout(() => window.dispatchEvent(new Event('resize')), 100);
        }

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => showTab(tab.dataset.tab));
        });

        // Update all visualizations
        function updateAllVisualizations() {
            updateKPICards();
            updateOverviewCharts();
            updateTimeSeriesCharts();
            updateDistributionCharts();
            updateCorrelationCharts();
            updateRegressionAnalysis();
            updateKPIDataTable();
            
            document.getElementById('kpiSection').classList.add('visible');
            document.getElementById('overviewCharts').classList.add('visible');

            // Populate time series filters if build data available
            populateTimeSeriesFilters();
        }

        // Helper to get material label from trace type or carbon ratio
        function getMaterialLabel(traceValue, carbonRatioValue) {
            const val = String(traceValue || '').trim();
            const valLower = val.toLowerCase();

            // Check if it's a direct numeric carbon ratio
            const numVal = parseFloat(val);
            if (!isNaN(numVal) && val.match(/^-?\d*\.?\d+$/)) {
                if (numVal >= 0.99) return 'Carbon';
                if (numVal <= 0.01) return 'Silver';
                if (numVal >= 0.75) return 'C:Ag 4:1';
                if (numVal <= 0.25) return 'C:Ag 1:4';
                return 'C:Ag 1:1';
            }

            // Check for ratio format (e.g., "1:0", "4:1")
            const ratioMatch = val.match(/^(\d+(?:\.\d+)?)\s*:\s*(\d+(?:\.\d+)?)$/);
            if (ratioMatch) {
                const carbon = parseFloat(ratioMatch[1]);
                const silver = parseFloat(ratioMatch[2]);
                if (silver === 0) return 'Carbon';
                if (carbon === 0) return 'Silver';
                return `C:Ag ${Math.round(carbon)}:${Math.round(silver)}`;
            }

            // Legacy string format
            if (valLower.includes('carbon')) return 'Carbon';
            if (valLower.includes('silver')) return 'Silver';

            // If we have a carbonRatioValue from buildData.traceCarbon, use it
            if (carbonRatioValue !== undefined && !isNaN(carbonRatioValue)) {
                if (carbonRatioValue >= 0.99) return 'Carbon';
                if (carbonRatioValue <= 0.01) return 'Silver';
                if (carbonRatioValue >= 0.75) return 'C:Ag 4:1';
                if (carbonRatioValue <= 0.25) return 'C:Ag 1:4';
                return 'C:Ag 1:1';
            }

            return 'Unknown';
        }

        // Populate Time Series Filters
        function populateTimeSeriesFilters() {
            if (!buildData) return;

            const materialSelect = document.getElementById('tsFilterMaterial');
            const sealSelect = document.getElementById('tsFilterSeal');
            const mixSelect = document.getElementById('tsFilterMix');

            // Get unique values
            const materials = [...new Set(buildData.sensors.map((s, i) => {
                const carbonRatio = buildData.traceCarbon ? buildData.traceCarbon[i] : undefined;
                const traceType = buildData.traceTypes ? buildData.traceTypes[i] : undefined;
                return getMaterialLabel(traceType, carbonRatio);
            }))].filter(m => m && m !== 'Unknown').sort();

            const sealMethods = [...new Set(buildData.sealedMethod || [])].filter(s => s && s !== 'N/A').sort();
            const mixMethods = [...new Set(buildData.mixedMethod || [])].filter(m => m && m !== 'N/A').sort();

            // Populate material dropdown
            materialSelect.innerHTML = '<option value="all">All</option>' +
                materials.map(m => `<option value="${m}">${m}</option>`).join('');

            // Populate seal dropdown
            sealSelect.innerHTML = '<option value="all">All</option>' +
                sealMethods.map(s => `<option value="${s}">${s}</option>`).join('');

            // Populate mix dropdown
            mixSelect.innerHTML = '<option value="all">All</option>' +
                mixMethods.map(m => `<option value="${m}">${m}</option>`).join('');
        }

        // Get filtered sensors for time series
        function getFilteredSensors() {
            const allSensors = Object.keys(sensorData.sensors);
            if (!buildData) return allSensors;

            const materialFilter = document.getElementById('tsFilterMaterial')?.value || 'all';
            const sealFilter = document.getElementById('tsFilterSeal')?.value || 'all';
            const mixFilter = document.getElementById('tsFilterMix')?.value || 'all';

            // If all filters are 'all', return all sensors
            if (materialFilter === 'all' && sealFilter === 'all' && mixFilter === 'all') {
                return allSensors;
            }

            // Create lookup for build data by sensor name
            function normalizeName(name) {
                return String(name).toLowerCase().replace(/[^a-z0-9]/g, '');
            }

            const buildLookup = {};
            buildData.sensors.forEach((sensor, idx) => {
                const carbonRatio = buildData.traceCarbon ? buildData.traceCarbon[idx] : undefined;
                const traceType = buildData.traceTypes ? buildData.traceTypes[idx] : undefined;
                buildLookup[normalizeName(sensor)] = {
                    material: getMaterialLabel(traceType, carbonRatio),
                    seal: buildData.sealedMethod ? buildData.sealedMethod[idx] : 'N/A',
                    mix: buildData.mixedMethod ? buildData.mixedMethod[idx] : 'N/A'
                };
            });

            // Filter sensors
            return allSensors.filter(sensor => {
                const normalized = normalizeName(sensor);
                const info = buildLookup[normalized];
                if (!info) return true; // Include if no build data match

                if (materialFilter !== 'all' && info.material !== materialFilter) return false;
                if (sealFilter !== 'all' && info.seal !== sealFilter) return false;
                if (mixFilter !== 'all' && info.mix !== mixFilter) return false;

                return true;
            });
        }

        // KPI Summary Cards
        function updateKPICards() {
            const grid = document.getElementById('kpiGrid');
            const sensors = Object.keys(kpiData);
            
            const significantSensors = sensors.filter(s => kpiData[s].isSignificant);
            const avgResponse = mean(sensors.map(s => kpiData[s].responseMag));
            const avgT90 = mean(sensors.map(s => kpiData[s].t90Rise));
            const avgT90Abs = mean(sensors.map(s => kpiData[s].t90RiseAbs));
            const avgResponseStart = mean(sensors.map(s => kpiData[s].responseStartTime));
            const avgRecovery = mean(sensors.map(s => kpiData[s].percentRecovery));
            const medianSNR = median(sensors.map(s => kpiData[s].snr));
            const avgRiseRate = mean(sensors.map(s => kpiData[s].riseRate));
            const avgBaselineStd = mean(sensors.map(s => kpiData[s].baselineStd));
            
            grid.innerHTML = `
                <div class="kpi-card">
                    <div class="kpi-label">Sensors Analyzed</div>
                    <div class="kpi-value">${sensors.length}</div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-label">
                        Significant Responses
                        <span class="tooltip-container">
                            <span class="tooltip-icon">?</span>
                            <span class="tooltip-text">Sensors where peak exceeds baseline + (threshold &times; &sigma;). Non-significant sensors may have noise-level responses.</span>
                        </span>
                    </div>
                    <div class="kpi-value">${significantSensors.length}<span class="kpi-unit">/ ${sensors.length}</span></div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-label">
                        Avg Response
                        <span class="tooltip-container">
                            <span class="tooltip-icon">?</span>
                            <span class="tooltip-text">Mean response magnitude (Peak Value &minus; Baseline Mean) across all sensors.</span>
                        </span>
                    </div>
                    <div class="kpi-value">${avgResponse.toFixed(4)}<span class="kpi-unit">V</span></div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-label">
                        Avg T90 Rise
                        <span class="tooltip-container">
                            <span class="tooltip-icon">?</span>
                            <span class="tooltip-text">Mean time to reach 90% of peak response. Absolute time: ${avgT90Abs.toFixed(1)}s. Response starts at: ${avgResponseStart.toFixed(1)}s.</span>
                        </span>
                    </div>
                    <div class="kpi-value">${avgT90.toFixed(1)}<span class="kpi-unit">s</span></div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-label">
                        Avg Recovery
                        <span class="tooltip-container">
                            <span class="tooltip-icon">?</span>
                            <span class="tooltip-text">Mean percent recovery: (Peak &minus; Final) / (Peak &minus; Baseline) &times; 100. Higher = more complete return toward baseline.</span>
                        </span>
                    </div>
                    <div class="kpi-value">${avgRecovery.toFixed(1)}<span class="kpi-unit">%</span></div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-label">
                        Median SNR
                        <span class="tooltip-container">
                            <span class="tooltip-icon">?</span>
                            <span class="tooltip-text">Median signal-to-noise ratio (Response &divide; Baseline StdDev). Median used to reduce outlier impact.</span>
                        </span>
                    </div>
                    <div class="kpi-value">${medianSNR.toFixed(1)}</div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-label">
                        Avg Rise Rate
                        <span class="tooltip-container">
                            <span class="tooltip-icon">?</span>
                            <span class="tooltip-text">Mean rate of signal increase from T50 to T90: (0.4 &times; Response) / (T90 &minus; T50). Higher = faster response.</span>
                        </span>
                    </div>
                    <div class="kpi-value">${avgRiseRate.toFixed(4)}<span class="kpi-unit">V/s</span></div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-label">
                        Avg Baseline &sigma;
                        <span class="tooltip-container">
                            <span class="tooltip-icon">?</span>
                            <span class="tooltip-text">Mean standard deviation of baseline signal. Lower = more stable baseline, better for detecting small responses.</span>
                        </span>
                    </div>
                    <div class="kpi-value">${avgBaselineStd.toFixed(5)}<span class="kpi-unit">V</span></div>
                </div>
            `;
        }

        // Overview Charts
        function updateOverviewCharts() {
            const sensors = Object.keys(kpiData);
            
            // Response Magnitude Bar Chart
            safePlot('responseMagChart', [{
                x: sensors,
                y: sensors.map(s => kpiData[s].responseMag),
                type: 'bar',
                marker: {
                    color: sensors.map((_, i) => sensorColors[i % sensorColors.length]),
                    line: { width: 0 }
                },
                hovertemplate: '%{x}<br>Response: %{y:.4f} V<extra></extra>'
            }], {
                ...plotlyLayout,
                xaxis: { ...plotlyLayout.xaxis, tickangle: -45, title: 'Sensor' },
                yaxis: { ...plotlyLayout.yaxis, title: 'Response Magnitude (V)' }
            }, plotlyConfig);
            
            // Response vs Baseline Scatter
            safePlot('responseVsBaselineChart', [{
                x: sensors.map(s => kpiData[s].baselineMean),
                y: sensors.map(s => kpiData[s].responseMag),
                mode: 'markers',
                type: 'scatter',
                marker: {
                    color: sensorColors[0],
                    size: 10,
                    opacity: 0.7
                },
                text: sensors,
                hovertemplate: '%{text}<br>Baseline: %{x:.4f}<br>Response: %{y:.4f}<extra></extra>'
            }], {
                ...plotlyLayout,
                xaxis: { ...plotlyLayout.xaxis, title: 'Baseline Mean (V)' },
                yaxis: { ...plotlyLayout.yaxis, title: 'Response Magnitude (V)' }
            }, plotlyConfig);
            
            // Timing Chart (T50 vs T90)
            safePlot('timingChart', [{
                x: sensors.map(s => kpiData[s].t50Rise),
                y: sensors.map(s => kpiData[s].t90Rise),
                mode: 'markers',
                type: 'scatter',
                marker: {
                    color: sensors.map(s => kpiData[s].responseMag),
                    colorscale: 'Viridis',
                    size: 12,
                    showscale: true,
                    colorbar: { title: 'Response' }
                },
                text: sensors,
                hovertemplate: '%{text}<br>T50: %{x:.1f}s<br>T90: %{y:.1f}s<extra></extra>'
            }], {
                ...plotlyLayout,
                xaxis: { ...plotlyLayout.xaxis, title: 'T50 Rise (s)' },
                yaxis: { ...plotlyLayout.yaxis, title: 'T90 Rise (s)' }
            }, plotlyConfig);
        }

        // Time Series Charts
        function updateTimeSeriesCharts() {
            const sensors = getFilteredSensors().filter(s => sensorData.sensors[s] && kpiData[s]);
            const time = sensorData.time;

            // Show filter count
            const totalSensors = Object.keys(sensorData.sensors).length;
            const filterInfo = sensors.length < totalSensors ?
                ` (${sensors.length}/${totalSensors} shown)` : '';

            // All sensors overlay
            const traces = sensors.map((sensor, i) => ({
                x: time,
                y: sensorData.sensors[sensor],
                type: 'scatter',
                mode: 'lines',
                name: sensor,
                line: { color: sensorColors[i % sensorColors.length], width: 1.5 },
                hovertemplate: `${sensor}<br>Time: %{x:.1f}s<br>Value: %{y:.4f} V<extra></extra>`
            }));

            safePlot('allSensorsChart', traces, {
                ...plotlyLayout,
                title: sensors.length === 0 ? 'No sensors match filters' : '',
                xaxis: { ...plotlyLayout.xaxis, title: 'Time (s)' },
                yaxis: { ...plotlyLayout.yaxis, title: 'Voltage (V)' },
                showlegend: true,
                legend: { orientation: 'h', y: -0.2 }
            }, plotlyConfig);

            // Heatmap
            const zData = sensors.map(s => sensorData.sensors[s]);
            safePlot('heatmapChart', [{
                z: zData,
                x: time,
                y: sensors,
                type: 'heatmap',
                colorscale: 'Viridis',
                hovertemplate: 'Sensor: %{y}<br>Time: %{x:.1f}s<br>Value: %{z:.4f} V<extra></extra>'
            }], {
                ...plotlyLayout,
                xaxis: { ...plotlyLayout.xaxis, title: 'Time (s)' },
                yaxis: { ...plotlyLayout.yaxis, title: 'Sensor' }
            }, plotlyConfig);

            // Normalized curves
            const normTraces = sensors.map((sensor, i) => {
                const values = sensorData.sensors[sensor];
                const baseline = kpiData[sensor].baselineMean;
                const response = kpiData[sensor].responseMag;
                const normalized = values.map(v => response > 0 ? (v - baseline) / response : 0);
                return {
                    x: time,
                    y: normalized,
                    type: 'scatter',
                    mode: 'lines',
                    name: sensor,
                    line: { color: sensorColors[i % sensorColors.length], width: 1 },
                    opacity: 0.6
                };
            });

            safePlot('normalizedChart', normTraces, {
                ...plotlyLayout,
                xaxis: { ...plotlyLayout.xaxis, title: 'Time (s)' },
                yaxis: { ...plotlyLayout.yaxis, title: 'Normalized Response' },
                showlegend: false
            }, plotlyConfig);
        }

        // Distribution Charts
        function updateDistributionCharts() {
            const sensors = Object.keys(kpiData);
            const responseMags = sensors.map(s => kpiData[s].responseMag);
            const t90Values = sensors.map(s => kpiData[s].t90Rise);

            // Calculate optimal bin size for histograms
            const numBins = Math.max(8, Math.min(20, Math.ceil(Math.sqrt(sensors.length))));

            // Calculate bin sizes based on data range
            const respMin = Math.min(...responseMags);
            const respMax = Math.max(...responseMags);
            const respBinSize = (respMax - respMin) / numBins || 0.1;

            const t90Min = Math.min(...t90Values);
            const t90Max = Math.max(...t90Values);
            const t90Range = t90Max - t90Min;
            // Ensure minimum range for visual clarity (at least 10% of mean or 5s minimum)
            const t90Mean = t90Values.reduce((a, b) => a + b, 0) / t90Values.length;
            const t90MinRange = Math.max(5, t90Mean * 0.1);
            const t90BinSize = Math.max(t90Range, t90MinRange) / numBins || 1;
            const t90Padding = t90Range < t90MinRange ? (t90MinRange - t90Range) / 2 : 0;

            // Response Histogram
            safePlot('responseHistogram', [{
                x: responseMags,
                type: 'histogram',
                marker: { color: sensorColors[0], line: { color: '#fff', width: 1 } },
                xbins: { start: respMin, end: respMax, size: respBinSize },
                hovertemplate: 'Range: %{x}<br>Count: %{y}<extra></extra>'
            }], {
                ...plotlyLayout,
                xaxis: { ...plotlyLayout.xaxis, title: 'Response Magnitude (V)' },
                yaxis: { ...plotlyLayout.yaxis, title: 'Count' }
            }, plotlyConfig);

            // T90 Histogram
            safePlot('t90Histogram', [{
                x: t90Values,
                type: 'histogram',
                marker: { color: sensorColors[1], line: { color: '#fff', width: 1 } },
                xbins: { start: t90Min - t90Padding, end: t90Max + t90Padding, size: t90BinSize },
                hovertemplate: 'Range: %{x}<br>Count: %{y}<extra></extra>'
            }], {
                ...plotlyLayout,
                xaxis: { ...plotlyLayout.xaxis, title: 'T90 Rise Time (s)', range: [t90Min - t90Padding - t90BinSize, t90Max + t90Padding + t90BinSize] },
                yaxis: { ...plotlyLayout.yaxis, title: 'Count' }
            }, plotlyConfig);
            
            // Box plots by Trace Type and Reference Location
            if (buildData) {
                // Robust normalization - strip ALL non-alphanumeric and convert to lowercase
                function normalize(name) {
                    return String(name).toLowerCase().replace(/[^a-z0-9]/g, '');
                }

                // Create lookup from KPI data
                const kpiLookup = {};
                Object.keys(kpiData).forEach(s => {
                    const norm = normalize(s);
                    kpiLookup[norm] = kpiData[s];
                    debugLog(`KPI lookup: "${s}" -> "${norm}"`);
                });
                
                // Match build data sensors to KPI data
                const matchedIndices = [];
                buildData.sensors.forEach((sensor, idx) => {
                    const norm = normalize(sensor);
                    const kpi = kpiLookup[norm];
                    if (kpi) {
                        matchedIndices.push({ idx, sensor, kpi });
                    } else {
                        debugLog(`No match for build sensor: "${sensor}" -> "${norm}"`);
                    }
                });
                
                debugLog('Distribution charts - matched sensors:', matchedIndices.length);
                
                if (matchedIndices.length === 0) {
                    console.warn('No sensors matched for distribution charts!');
                    // Show available keys for debugging
                    debugLog('KPI lookup keys:', Object.keys(kpiLookup).slice(0, 5));
                    debugLog('Build normalized:', buildData.sensors.slice(0, 5).map(normalize));
                    return;
                }
                
                // T90 Rise by Material
                const t90CombinedGroups = {};

                matchedIndices.forEach(({ idx, kpi }) => {
                    const trace = String(buildData.traceTypes[idx] || '');
                    const carbonRatio = buildData.traceCarbon ? buildData.traceCarbon[idx] : undefined;
                    const traceClean = getMaterialLabel(trace, carbonRatio);

                    if (!t90CombinedGroups[traceClean]) t90CombinedGroups[traceClean] = [];
                    t90CombinedGroups[traceClean].push(kpi.t90Rise);
                });

                // Dynamic group order based on what's present
                const t90GroupOrder = Object.keys(t90CombinedGroups).sort();
                
                const t90CombinedColors = ['#06b6d4', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#14b8a6'];
                const t90CombinedTraces = t90GroupOrder
                    .filter(g => t90CombinedGroups[g] && t90CombinedGroups[g].length > 0)
                    .map((group, i) => ({
                        y: t90CombinedGroups[group],
                        type: 'box',
                        name: group,
                        marker: { color: t90CombinedColors[i % t90CombinedColors.length] },
                        boxpoints: 'all',
                        jitter: 0.3,
                        pointpos: -1.5
                    }));
                
                safePlot('t90CombinedBoxplot', t90CombinedTraces, {
                    ...plotlyLayout,
                    yaxis: { ...plotlyLayout.yaxis, title: 'T90 Rise Time (s)' },
                    showlegend: false
                }, plotlyConfig);
                
                // T50 Recovery by Material
                const t50rCombinedGroups = {};

                matchedIndices.forEach(({ idx, kpi }) => {
                    const trace = String(buildData.traceTypes[idx] || '');
                    const carbonRatio = buildData.traceCarbon ? buildData.traceCarbon[idx] : undefined;
                    const traceClean = getMaterialLabel(trace, carbonRatio);

                    if (!t50rCombinedGroups[traceClean]) t50rCombinedGroups[traceClean] = [];
                    t50rCombinedGroups[traceClean].push(kpi.t50R);
                });

                // Dynamic group order based on what's present
                const t50rGroupOrder = Object.keys(t50rCombinedGroups).sort();
                
                const t50rCombinedColors = ['#06b6d4', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#14b8a6'];
                const t50rCombinedTraces = t50rGroupOrder
                    .filter(g => t50rCombinedGroups[g] && t50rCombinedGroups[g].length > 0)
                    .map((group, i) => ({
                        y: t50rCombinedGroups[group],
                        type: 'box',
                        name: group,
                        marker: { color: t50rCombinedColors[i % t50rCombinedColors.length] },
                        boxpoints: 'all',
                        jitter: 0.3,
                        pointpos: -1.5
                    }));
                
                safePlot('t50rCombinedBoxplot', t50rCombinedTraces, {
                    ...plotlyLayout,
                    yaxis: { ...plotlyLayout.yaxis, title: 'T50 Recovery Time (s)' },
                    showlegend: false
                }, plotlyConfig);

                // Last 30 seconds percent change by Material
                const last30Groups = {};

                matchedIndices.forEach(({ idx, kpi }) => {
                    const trace = String(buildData.traceTypes[idx] || '');
                    const carbonRatio = buildData.traceCarbon ? buildData.traceCarbon[idx] : undefined;
                    const traceClean = getMaterialLabel(trace, carbonRatio);

                    if (!last30Groups[traceClean]) last30Groups[traceClean] = [];
                    last30Groups[traceClean].push(kpi.last30PercentChange);
                });

                const last30GroupOrder = Object.keys(last30Groups).sort();

                const last30Colors = ['#06b6d4', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#14b8a6'];
                const last30Traces = last30GroupOrder
                    .filter(g => last30Groups[g] && last30Groups[g].length > 0)
                    .map((group, i) => ({
                        y: last30Groups[group],
                        type: 'box',
                        name: group,
                        marker: { color: last30Colors[i % last30Colors.length] },
                        boxpoints: 'all',
                        jitter: 0.3,
                        pointpos: -1.5
                    }));

                safePlot('last30ChangeBoxplot', last30Traces, {
                    ...plotlyLayout,
                    yaxis: { ...plotlyLayout.yaxis, title: 'Last 30s % Change' },
                    showlegend: false
                }, plotlyConfig);

                // Combined Trace √ó Reference box plot
                const combinedGroups = {};

                matchedIndices.forEach(({ idx, kpi }) => {
                    const trace = String(buildData.traceTypes[idx] || '');
                    const ref = String(buildData.refLocations[idx] || '');
                    const carbonRatio = buildData.traceCarbon ? buildData.traceCarbon[idx] : undefined;

                    const refShort = ref.toLowerCase().includes('side') ? 'Side' : 'Center';
                    const traceClean = getMaterialLabel(trace, carbonRatio);

                    const groupName = `${refShort}/${traceClean}`;

                    if (!combinedGroups[groupName]) combinedGroups[groupName] = [];
                    combinedGroups[groupName].push(kpi.responseMag);
                });

                // Dynamic group order based on what's present
                const groupOrder = Object.keys(combinedGroups).sort();
                
                debugLog('Combined groups:', Object.entries(combinedGroups).map(([k, v]) => `${k}: ${v.length}`));
                
                const combinedColors = ['#06b6d4', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#14b8a6'];
                const combinedTraces = groupOrder
                    .filter(g => combinedGroups[g] && combinedGroups[g].length > 0)
                    .map((group, i) => ({
                        y: combinedGroups[group],
                        type: 'box',
                        name: group,
                        marker: { color: combinedColors[i % combinedColors.length] },
                        boxpoints: 'all',
                        jitter: 0.3,
                        pointpos: -1.5
                    }));
                
                safePlot('combinedBoxplot', combinedTraces, {
                    ...plotlyLayout,
                    yaxis: { ...plotlyLayout.yaxis, title: 'Response Magnitude (V)' },
                    showlegend: false
                }, plotlyConfig);
                
                // Violin plot - use carbon ratio for grouping
                const violinGroups = {};
                matchedIndices.forEach(({ idx, kpi }) => {
                    const trace = String(buildData.traceTypes[idx] || '');
                    const carbonRatio = buildData.traceCarbon ? buildData.traceCarbon[idx] : undefined;
                    const traceClean = getMaterialLabel(trace, carbonRatio);

                    if (!violinGroups[traceClean]) violinGroups[traceClean] = [];
                    violinGroups[traceClean].push(kpi.responseMag);
                });

                // Dynamic order based on what's present
                const violinOrder = Object.keys(violinGroups).sort();
                const violinTraces = violinOrder
                    .filter(t => violinGroups[t] && violinGroups[t].length > 0)
                    .map((trace, i) => ({
                        type: 'violin',
                        y: violinGroups[trace],
                        name: trace,
                        box: { visible: true },
                        meanline: { visible: true },
                        fillcolor: sensorColors[i % sensorColors.length],
                        line: { color: sensorColors[i % sensorColors.length] },
                        opacity: 0.7
                    }));
                
                safePlot('violinChart', violinTraces, {
                    ...plotlyLayout,
                    yaxis: { ...plotlyLayout.yaxis, title: 'Response Magnitude (V)' }
                }, plotlyConfig);
            }
        }

        // Correlation Charts
        function updateCorrelationCharts() {
            if (!buildData || !kpiData) {
                console.warn('Missing buildData or kpiData for correlations');
                return;
            }
            
            // Normalize sensor names for matching
            function normalizeName(name) {
                return String(name).toLowerCase().replace(/[^a-z0-9]/g, '');
            }
            
            const kpiLookup = {};
            Object.keys(kpiData).forEach(s => {
                kpiLookup[normalizeName(s)] = kpiData[s];
            });
            
            // Create matched arrays
            const matchedData = [];
            buildData.sensors.forEach((sensor, idx) => {
                const normalized = normalizeName(sensor);
                const kpi = kpiLookup[normalized];
                if (kpi) {
                    matchedData.push({
                        sensor,
                        wcRatio: buildData.wcRatio[idx],
                        wrRatio: buildData.wrRatio[idx],
                        workingSA: buildData.workingSA[idx],
                        counterSA: buildData.counterSA[idx],
                        referenceSA: buildData.referenceSA[idx],
                        totalSA: buildData.totalSA[idx],
                        traceCarbon: buildData.traceCarbon[idx],
                        traceSilver: buildData.traceSilver[idx],
                        refSide: buildData.refSide[idx],
                        isSealedSnap: buildData.isSealedSnap ? buildData.isSealedSnap[idx] : 0,
                        isMixedFlackTek: buildData.isMixedFlackTek ? buildData.isMixedFlackTek[idx] : 0,
                        ...kpi
                    });
                }
            });
            
            debugLog('Correlation matched sensors:', matchedData.length);
            
            if (matchedData.length === 0) {
                console.warn('No sensors matched for correlations!');
                debugLog('Build sensors sample:', buildData.sensors.slice(0, 3));
                debugLog('KPI sensors sample:', Object.keys(kpiData).slice(0, 3));
                return;
            }
            
            const sensors = matchedData.map(d => d.sensor);
            const kpiList = ['responseMag', 'percentResponse', 't90Rise', 't90RiseAbs', 'riseRate',
                            'percentRecovery', 't50R', 't10R', 'recoveryRate', 'snr', 'baselineStd'];
            const kpiLabels = ['Response', '% Resp', 'T90 (rel)', 'T90 (abs)', 'Rise Rate',
                              '% Recov', 'T50R', 'T10R', 'Recov Rate', 'SNR', 'Baseline œÉ'];
            const designParams = ['traceCarbon', 'isSealedSnap', 'isMixedFlackTek', 'wcRatio', 'wrRatio', 'workingSA', 'counterSA', 'referenceSA', 'totalSA'];
            const designLabels = ['C Ratio', 'Seal', 'Mix', 'W:C', 'W:R', 'Work SA', 'Cntr SA', 'Ref SA', 'Total SA'];

            // Build correlation matrix
            const corrMatrix = [];
            kpiList.forEach(kpi => {
                const row = [];
                designParams.forEach(param => {
                    const x = matchedData.map(d => d[param]);
                    const y = matchedData.map(d => d[kpi]);
                    const r = correlation(x, y);
                    row.push(isNaN(r) ? 0 : r);
                });
                corrMatrix.push(row);
            });

            debugLog('Correlation matrix computed:', corrMatrix.length, 'x', corrMatrix[0]?.length);

            // Find strongest correlations for interpretation
            let strongestCorr = { r: 0, kpi: '', param: '' };
            let strongestNeg = { r: 0, kpi: '', param: '' };
            corrMatrix.forEach((row, i) => {
                row.forEach((r, j) => {
                    if (r > strongestCorr.r) {
                        strongestCorr = { r, kpi: kpiLabels[i], param: designLabels[j] };
                    }
                    if (r < strongestNeg.r) {
                        strongestNeg = { r, kpi: kpiLabels[i], param: designLabels[j] };
                    }
                });
            });

            // Heatmap interpretation
            let heatmapInterp = `This heatmap shows Pearson correlations between design parameters (columns) and sensor KPIs (rows). `;
            heatmapInterp += `<strong style="color: #ef5350;">Red = positive correlation</strong> (both increase together), <strong style="color: #42a5f5;">Blue = negative</strong> (one increases as other decreases). `;
            if (strongestCorr.r > 0.5) {
                heatmapInterp += `Strongest positive: <span class="interpretation-highlight" style="background: rgba(239, 83, 80, 0.2); color: #ef5350;">${strongestCorr.param} ‚Üí ${strongestCorr.kpi} (r=${strongestCorr.r.toFixed(2)})</span>. `;
            }
            if (strongestNeg.r < -0.5) {
                heatmapInterp += `Strongest negative: <span class="interpretation-highlight" style="background: rgba(66, 165, 245, 0.2); color: #42a5f5;">${strongestNeg.param} ‚Üí ${strongestNeg.kpi} (r=${strongestNeg.r.toFixed(2)})</span>. `;
            }
            if (Math.abs(strongestCorr.r) < 0.3 && Math.abs(strongestNeg.r) < 0.3) {
                heatmapInterp += `No strong correlations found ‚Äî design parameters may have limited influence on sensor performance.`;
            }
            document.getElementById('correlationHeatmapInterpretation').innerHTML = heatmapInterp;

            // Heatmap
            safePlot('correlationHeatmap', [{
                z: corrMatrix,
                x: designLabels,
                y: kpiLabels,
                type: 'heatmap',
                colorscale: 'RdBu',
                zmid: 0,
                zmin: -1,
                zmax: 1,
                hovertemplate: '%{y} vs %{x}<br>r = %{z:.3f}<extra></extra>'
            }], {
                ...plotlyLayout,
                margin: { ...plotlyLayout.margin, l: 80 },
                xaxis: { ...plotlyLayout.xaxis, title: '' },
                yaxis: { ...plotlyLayout.yaxis, title: '', tickfont: { size: 11 } }
            }, plotlyConfig);
            
            // Scatter plots
            const wcRatio = matchedData.map(d => d.wcRatio);
            const respMag = matchedData.map(d => d.responseMag);
            const t90 = matchedData.map(d => d.t90Rise);
            const workSA = matchedData.map(d => d.workingSA);
            
            // W:C vs Response with trendline
            const regWcResp = linearRegression(wcRatio, respMag);
            const xLine = [Math.min(...wcRatio), Math.max(...wcRatio)];
            const yLine = xLine.map(x => regWcResp.slope * x + regWcResp.intercept);
            
            safePlot('wcVsResponseChart', [
                {
                    x: wcRatio, y: respMag,
                    mode: 'markers', type: 'scatter',
                    marker: { color: sensorColors[0], size: 10 },
                    text: sensors,
                    hovertemplate: '%{text}<br>W:C: %{x:.3f}<br>Response: %{y:.4f}<extra></extra>',
                    name: 'Data'
                },
                {
                    x: xLine, y: yLine,
                    mode: 'lines', type: 'scatter',
                    line: { color: '#f59e0b', width: 2, dash: 'dash' },
                    name: `R¬≤ = ${regWcResp.r2.toFixed(3)}`
                }
            ], {
                ...plotlyLayout,
                xaxis: { ...plotlyLayout.xaxis, title: 'W:C Ratio', tickformat: '.2f', type: 'linear' },
                yaxis: { ...plotlyLayout.yaxis, title: 'Response Magnitude (V)', type: 'linear' },
                showlegend: true
            }, plotlyConfig);

            // W:C vs Response interpretation
            const wcRespInterp = generateScatterInterpretation(
                'W:C Ratio', 'Response Magnitude', regWcResp.r2, regWcResp.slope,
                'Adjusting the working-to-counter electrode ratio'
            );
            document.getElementById('wcVsResponseInterpretation').innerHTML = wcRespInterp.text;
            document.getElementById('wcVsResponseInterpretation').className = `chart-interpretation interpretation-${wcRespInterp.class}`;

            // W:C vs T90
            const regWcT90 = linearRegression(wcRatio, t90);
            const yLineT90 = xLine.map(x => regWcT90.slope * x + regWcT90.intercept);
            
            safePlot('wcVsT90Chart', [
                {
                    x: wcRatio, y: t90,
                    mode: 'markers', type: 'scatter',
                    marker: { color: sensorColors[1], size: 10 },
                    text: sensors,
                    name: 'Data'
                },
                {
                    x: xLine, y: yLineT90,
                    mode: 'lines', type: 'scatter',
                    line: { color: '#f59e0b', width: 2, dash: 'dash' },
                    name: `R¬≤ = ${regWcT90.r2.toFixed(3)}`
                }
            ], {
                ...plotlyLayout,
                xaxis: { ...plotlyLayout.xaxis, title: 'W:C Ratio', tickformat: '.2f', type: 'linear' },
                yaxis: { ...plotlyLayout.yaxis, title: 'T90 Rise (s from response start)', type: 'linear' },
                showlegend: true
            }, plotlyConfig);

            // W:C vs T90 interpretation
            const wcT90Interp = generateScatterInterpretation(
                'W:C Ratio', 'T90 Rise Time', regWcT90.r2, regWcT90.slope,
                'Modifying the working-to-counter ratio'
            );
            document.getElementById('wcVsT90Interpretation').innerHTML = wcT90Interp.text;
            document.getElementById('wcVsT90Interpretation').className = `chart-interpretation interpretation-${wcT90Interp.class}`;

            // Working SA vs Response
            const regWorkResp = linearRegression(workSA, respMag);
            const xLineWork = [Math.min(...workSA), Math.max(...workSA)];
            const yLineWork = xLineWork.map(x => regWorkResp.slope * x + regWorkResp.intercept);
            
            safePlot('workSaVsResponseChart', [
                {
                    x: workSA, y: respMag,
                    mode: 'markers', type: 'scatter',
                    marker: { color: sensorColors[2], size: 10 },
                    text: sensors,
                    name: 'Data'
                },
                {
                    x: xLineWork, y: yLineWork,
                    mode: 'lines', type: 'scatter',
                    line: { color: '#f59e0b', width: 2, dash: 'dash' },
                    name: `R¬≤ = ${regWorkResp.r2.toFixed(3)}`
                }
            ], {
                ...plotlyLayout,
                xaxis: { ...plotlyLayout.xaxis, title: 'Working SA (mm¬≤)', tickformat: '.1f', type: 'linear' },
                yaxis: { ...plotlyLayout.yaxis, title: 'Response Magnitude (V)', type: 'linear' },
                showlegend: true
            }, plotlyConfig);

            // Working SA vs Response interpretation
            const workRespInterp = generateScatterInterpretation(
                'Working Electrode Surface Area', 'Response Magnitude', regWorkResp.r2, regWorkResp.slope,
                'Increasing the working electrode surface area'
            );
            document.getElementById('workSaVsResponseInterpretation').innerHTML = workRespInterp.text;
            document.getElementById('workSaVsResponseInterpretation').className = `chart-interpretation interpretation-${workRespInterp.class}`;

            // 3D Scatter
            safePlot('scatter3dChart', [{
                x: wcRatio,
                y: matchedData.map(d => d.wrRatio),
                z: respMag,
                mode: 'markers',
                type: 'scatter3d',
                marker: {
                    size: 6,
                    color: respMag,
                    colorscale: 'Viridis',
                    opacity: 0.8
                },
                text: sensors,
                hovertemplate: '%{text}<br>W:C: %{x:.2f}<br>W:R: %{y:.2f}<br>Response: %{z:.4f}<extra></extra>'
            }], {
                ...plotlyLayout,
                scene: {
                    xaxis: { title: 'W:C Ratio', gridcolor: '#1e293b' },
                    yaxis: { title: 'W:R Ratio', gridcolor: '#1e293b' },
                    zaxis: { title: 'Response (V)', gridcolor: '#1e293b' },
                    bgcolor: '#111827'
                }
            }, plotlyConfig);

            // 3D Scatter interpretation
            let scatter3dInterp = `This 3D plot visualizes how <strong>W:C Ratio</strong> and <strong>W:R Ratio</strong> together influence <strong>Response Magnitude</strong>. `;
            scatter3dInterp += `Color intensity indicates response strength (brighter = higher). `;
            scatter3dInterp += `<strong>Rotate</strong> the plot by dragging to explore the relationship from different angles. `;
            scatter3dInterp += `Look for clusters or patterns ‚Äî sensors with similar ratios should have similar responses if the relationship is strong.`;
            document.getElementById('scatter3dInterpretation').innerHTML = scatter3dInterp;

            // Parallel Coordinates
            // Format large SNR values for display
            const snrValues = matchedData.map(d => d.snr);
            const maxSNR = Math.max(...snrValues);
            
            // If SNR values are very large, use log scale or cap display
            const snrForDisplay = maxSNR > 1000 
                ? snrValues.map(v => Math.log10(Math.max(v, 1)))  // Log scale for large values
                : snrValues;
            const snrLabel = maxSNR > 1000 ? 'log‚ÇÅ‚ÇÄ(SNR)' : 'SNR';
            
            safePlot('parallelChart', [{
                type: 'parcoords',
                line: {
                    color: respMag,
                    colorscale: 'Viridis',
                    showscale: true,
                    colorbar: { title: 'Response' }
                },
                dimensions: [
                    { label: 'W:C Ratio', values: wcRatio },
                    { label: 'W:R Ratio', values: matchedData.map(d => d.wrRatio) },
                    { label: 'Work SA', values: workSA },
                    { label: 'Response', values: respMag },
                    { label: 'T90 Rise', values: t90 },
                    { label: '% Recovery', values: matchedData.map(d => d.percentRecovery) },
                    { label: snrLabel, values: snrForDisplay }
                ]
            }], {
                ...plotlyLayout,
                margin: { t: 50, r: 50, b: 30, l: 50 }
            }, plotlyConfig);

            // Parallel Coordinates interpretation
            let parallelInterp = `This parallel coordinates plot shows each sensor as a line crossing multiple axes. `;
            parallelInterp += `<strong>Drag on any axis</strong> to filter and highlight sensors within a range. `;
            parallelInterp += `Lines that stay together across axes indicate correlated parameters. `;
            parallelInterp += `Color represents Response Magnitude ‚Äî look for patterns in how high-response sensors (bright) differ from low-response sensors (dark).`;
            document.getElementById('parallelChartInterpretation').innerHTML = parallelInterp;

            // Store matched data for regression
            window.matchedData = matchedData;
        }

        // Helper function to generate scatter plot interpretations
        function generateScatterInterpretation(xName, yName, r2, slope, actionPhrase) {
            let strengthClass, strengthText;
            if (r2 >= 0.7) {
                strengthClass = 'good';
                strengthText = 'strong';
            } else if (r2 >= 0.4) {
                strengthClass = 'moderate';
                strengthText = 'moderate';
            } else if (r2 >= 0.2) {
                strengthClass = 'weak';
                strengthText = 'weak';
            } else {
                strengthClass = 'weak';
                strengthText = 'very weak';
            }

            const direction = slope >= 0 ? 'increases' : 'decreases';
            const directionWord = slope >= 0 ? 'positive' : 'negative';

            let text = `<strong>${xName}</strong> shows a <strong>${strengthText} ${directionWord}</strong> correlation with <strong>${yName}</strong> `;
            text += `(R¬≤ = ${(r2 * 100).toFixed(1)}%). `;

            if (r2 >= 0.4) {
                text += `${actionPhrase} ${direction} ${yName.toLowerCase()}. `;
                if (r2 >= 0.7) {
                    text += `This is a <span class="interpretation-highlight highlight-positive">key design lever</span> for optimizing sensor performance.`;
                } else {
                    text += `Consider this alongside other factors for optimization.`;
                }
            } else if (r2 >= 0.2) {
                text += `There may be a trend, but other factors likely have more influence on ${yName.toLowerCase()}.`;
            } else {
                text += `${xName} alone does not meaningfully predict ${yName.toLowerCase()} ‚Äî other variables may be more important.`;
            }

            return { text, class: strengthClass };
        }

        // Regression Analysis
        function updateRegressionAnalysis() {
            if (!buildData || !kpiData) return;

            const yVar = document.getElementById('yVariable').value;
            const x1Var = document.getElementById('x1Variable').value;
            const x2Var = document.getElementById('x2Variable').value;

            // Get individual category selections
            const includeMaterial = document.getElementById('includeMaterial').checked;
            const includeSeal = document.getElementById('includeSeal').checked;
            const includeMix = document.getElementById('includeMix').checked;
            const includeCat = includeMaterial || includeSeal || includeMix;

            // Normalize sensor names for matching between build data and KPI data
            function normalizeName(name) {
                return String(name).toLowerCase().replace(/[^a-z0-9]/g, '');
            }

            // Create lookup dictionary with normalized keys
            const kpiLookup = {};
            Object.keys(kpiData).forEach(s => {
                kpiLookup[normalizeName(s)] = kpiData[s];
            });

            // Match build data sensors to KPI data and filter to only matched sensors
            const matchedIndices = [];
            const matchedSensors = [];
            buildData.sensors.forEach((sensor, idx) => {
                const kpi = kpiLookup[normalizeName(sensor)];
                if (kpi) {
                    matchedIndices.push(idx);
                    matchedSensors.push(sensor);
                }
            });

            if (matchedIndices.length === 0) {
                console.warn('No sensors matched for regression analysis!');
                return;
            }

            // Build matched arrays using only matched sensors
            const sensors = matchedSensors;
            const y = sensors.map((s, i) => {
                const kpi = kpiLookup[normalizeName(s)];
                return kpi?.[yVar] || 0;
            });
            const x1 = matchedIndices.map(idx => buildData[x1Var][idx]);
            const x2 = x2Var !== 'none' ? matchedIndices.map(idx => buildData[x2Var][idx]) : null;
            
            // Helper function for friendly variable names
            const varLabels = {
                'responseMag': 'Response Magnitude',
                'percentResponse': '% Response',
                't50Rise': 'T50 Rise Time',
                't90Rise': 'T90 Rise Time',
                'riseRate': 'Rise Rate',
                'percentRecovery': '% Recovery',
                't50R': 'T50 Recovery Time',
                't10R': 'T10 Recovery Time',
                'recoveryRate': 'Recovery Rate',
                'snr': 'Signal-to-Noise Ratio',
                'wcRatio': 'W:C Ratio',
                'wrRatio': 'W:R Ratio',
                'workingSA': 'Working SA',
                'counterSA': 'Counter SA',
                'referenceSA': 'Reference SA',
                'totalSA': 'Total SA'
            };
            const getLabel = (v) => varLabels[v] || v;
            const yLabel = getLabel(yVar);
            const x1Label = getLabel(x1Var);
            const x2Label = x2Var !== 'none' ? getLabel(x2Var) : null;

            // Helper to interpret R¬≤ strength
            const interpretR2 = (r2) => {
                if (r2 >= 0.7) return { text: 'strong', class: 'good' };
                if (r2 >= 0.4) return { text: 'moderate', class: 'moderate' };
                if (r2 >= 0.2) return { text: 'weak', class: 'weak' };
                return { text: 'very weak', class: 'weak' };
            };

            // Helper to interpret coefficient direction
            const interpretSlope = (slope, xName, yName) => {
                if (Math.abs(slope) < 0.0001) return `${xName} has no meaningful effect on ${yName}`;
                const direction = slope > 0 ? 'increases' : 'decreases';
                return `As ${xName} increases, ${yName} ${direction}`;
            };

            // Model 1: Simple regression
            const reg1 = linearRegression(x1, y);
            updateRegressionTable('model1Table', [
                { term: x1Var, coef: reg1.slope, se: reg1.seSlope },
                { term: 'Intercept', coef: reg1.intercept, se: reg1.seIntercept }
            ]);
            document.getElementById('model1R2').textContent = reg1.r2.toFixed(4);
            
            // Model 2: Multiple regression
            let reg2;
            if (x2) {
                const X2 = sensors.map((_, i) => [x1[i], x2[i]]);
                reg2 = multipleRegression(X2, y);
                updateRegressionTable('model2Table', [
                    { term: x1Var, coef: reg2.coeffs[1], se: reg2.stdErrors[1] },
                    { term: x2Var, coef: reg2.coeffs[2], se: reg2.stdErrors[2] },
                    { term: 'Intercept', coef: reg2.coeffs[0], se: reg2.stdErrors[0] }
                ]);
            } else {
                reg2 = reg1;
                updateRegressionTable('model2Table', [
                    { term: x1Var, coef: reg1.slope, se: reg1.seSlope },
                    { term: 'Intercept', coef: reg1.intercept, se: reg1.seIntercept }
                ]);
            }
            document.getElementById('model2R2').textContent = (reg2.r2 || reg1.r2).toFixed(4);
            document.getElementById('model2AdjR2').textContent = (reg2.adjR2 || reg1.r2).toFixed(4);
            
            // Model 3: With selected categoricals
            // Dynamically include Material, Seal, and/or Mix based on checkbox selections
            document.getElementById('model3Card').style.display = includeCat ? 'block' : 'none';
            if (includeCat) {
                // Get categorical values for each option
                const carbonValues = matchedIndices.map(i => buildData.traceCarbon[i]);
                const sealValues = matchedIndices.map(i => buildData.isSealedSnap ? buildData.isSealedSnap[i] : 0);
                const mixValues = matchedIndices.map(i => buildData.isMixedFlackTek ? buildData.isMixedFlackTek[i] : 0);

                // Check which have variation
                const carbonHasVariation = new Set(carbonValues).size > 1;
                const sealHasVariation = new Set(sealValues).size > 1;
                const mixHasVariation = new Set(mixValues).size > 1;

                debugLog('Carbon variation:', carbonHasVariation, 'Seal variation:', sealHasVariation, 'Mix variation:', mixHasVariation);

                // Build list of variables to include (selected AND has variation)
                const catVars = [];
                const catLabels = [];
                const catValues = [];

                if (includeMaterial && carbonHasVariation) {
                    catVars.push('Carbon_Ratio');
                    catLabels.push('Material');
                    catValues.push(carbonValues);
                }
                if (includeSeal && sealHasVariation) {
                    catVars.push('Sealed (Snap)');
                    catLabels.push('Seal');
                    catValues.push(sealValues);
                }
                if (includeMix && mixHasVariation) {
                    catVars.push('Mixed (FlackTek)');
                    catLabels.push('Mix');
                    catValues.push(mixValues);
                }

                // Track excluded variables (selected but no variation)
                const excluded = [];
                if (includeMaterial && !carbonHasVariation) excluded.push('Material');
                if (includeSeal && !sealHasVariation) excluded.push('Seal');
                if (includeMix && !mixHasVariation) excluded.push('Mix');

                if (catVars.length > 0) {
                    // Build X matrix: [x1, cat1, cat2, ...]
                    const X3 = sensors.map((_, i) => {
                        const row = [x1[i]];
                        catValues.forEach(vals => row.push(vals[i]));
                        return row;
                    });

                    const reg3 = multipleRegression(X3, y);

                    // Build table rows
                    const tableRows = [{ term: x1Var, coef: reg3.coeffs[1], se: reg3.stdErrors[1] }];
                    catVars.forEach((varName, idx) => {
                        tableRows.push({ term: varName, coef: reg3.coeffs[idx + 2], se: reg3.stdErrors[idx + 2] });
                    });
                    tableRows.push({ term: 'Intercept', coef: reg3.coeffs[0], se: reg3.stdErrors[0] });

                    updateRegressionTable('model3Table', tableRows);
                    document.getElementById('model3R2').textContent = reg3.r2.toFixed(4);
                    document.getElementById('model3AdjR2').textContent = reg3.adjR2.toFixed(4);

                    // Find significant terms
                    const r2Interp3 = interpretR2(reg3.r2);
                    const sigTerms3 = [];
                    if (Math.abs(reg3.stdErrors[1] > 0 ? reg3.coeffs[1] / reg3.stdErrors[1] : 0) > 2) sigTerms3.push(x1Label);
                    catVars.forEach((varName, idx) => {
                        const tStat = reg3.stdErrors[idx + 2] > 0 ? reg3.coeffs[idx + 2] / reg3.stdErrors[idx + 2] : 0;
                        if (Math.abs(tStat) > 2) sigTerms3.push(varName);
                    });

                    // Build interpretation
                    let model3Interp = `This model adds ${catLabels.join(', ')} as categorical variable${catLabels.length > 1 ? 's' : ''}`;
                    if (excluded.length > 0) {
                        model3Interp += ` (${excluded.join(', ')} excluded - no variation)`;
                    }
                    model3Interp += `. R¬≤ of <strong>${(reg3.r2 * 100).toFixed(1)}%</strong> shows <strong>${r2Interp3.text}</strong> explanatory power. `;
                    if (sigTerms3.length > 0) {
                        model3Interp += `<strong>${sigTerms3.join(', ')}</strong> ${sigTerms3.length === 1 ? 'is' : 'are'} statistically significant (|t| > 2). `;
                    } else {
                        model3Interp += `No terms reach statistical significance. `;
                    }
                    const r2Improvement = reg3.r2 - reg1.r2;
                    if (r2Improvement > 0.05) {
                        model3Interp += `Adding categoricals improved R¬≤ by <span class="interpretation-highlight highlight-positive">+${(r2Improvement * 100).toFixed(1)}%</span>.`;
                    } else {
                        model3Interp += `Categoricals add minimal predictive value beyond ${x1Label}.`;
                    }
                    document.getElementById('model3Interpretation').innerHTML = model3Interp;
                    document.getElementById('model3Interpretation').className = `model-interpretation interpretation-${r2Interp3.class}`;
                } else {
                    // No categorical variation in selected variables
                    const tableRows = [
                        { term: x1Var, coef: reg1.slope, se: reg1.seSlope },
                        { term: 'Intercept', coef: reg1.intercept, se: reg1.seIntercept }
                    ];
                    updateRegressionTable('model3Table', tableRows);
                    document.getElementById('model3R2').textContent = reg1.r2.toFixed(4);
                    document.getElementById('model3AdjR2').textContent = reg1.r2.toFixed(4);
                    const excludedMsg = excluded.length > 0 ? `Selected variables (${excluded.join(', ')}) have no variation. ` : '';
                    document.getElementById('model3Interpretation').innerHTML = `${excludedMsg}Model 3 is equivalent to Model 1.`;
                    document.getElementById('model3Interpretation').className = 'model-interpretation interpretation-weak';
                }
            }

            // Update model titles
            document.getElementById('model1Title').textContent = `Model 1: ${yLabel} ~ ${x1Label}`;
            document.getElementById('model2Title').textContent = x2Label
                ? `Model 2: ${yLabel} ~ ${x1Label} + ${x2Label}`
                : `Model 2: ${yLabel} ~ ${x1Label}`;
            const selectedCats = [];
            if (includeMaterial) selectedCats.push('Material');
            if (includeSeal) selectedCats.push('Seal');
            if (includeMix) selectedCats.push('Mix');
            const catSuffix = selectedCats.length > 0 ? selectedCats.join(' + ') : 'Categoricals';
            document.getElementById('model3Title').textContent = `Model 3: ${yLabel} ~ ${x1Label} + ${catSuffix}`;

            // Model 1 interpretation
            const r2Interp1 = interpretR2(reg1.r2);
            const tStat1 = reg1.seSlope > 0 ? reg1.slope / reg1.seSlope : 0;
            const isSignificant1 = Math.abs(tStat1) > 2;
            let model1Interp = `<strong>${x1Label}</strong> explains <strong>${(reg1.r2 * 100).toFixed(1)}%</strong> of variance in <strong>${yLabel}</strong> ‚Äî a <strong>${r2Interp1.text}</strong> relationship. `;
            model1Interp += interpretSlope(reg1.slope, x1Label, yLabel) + `. `;
            if (isSignificant1) {
                model1Interp += `The coefficient is <span class="interpretation-highlight highlight-positive">statistically significant</span> (t=${tStat1.toFixed(2)}).`;
            } else {
                model1Interp += `The coefficient is <span class="interpretation-highlight highlight-neutral">not statistically significant</span> (t=${tStat1.toFixed(2)}).`;
            }
            document.getElementById('model1Interpretation').innerHTML = model1Interp;
            document.getElementById('model1Interpretation').className = `model-interpretation interpretation-${r2Interp1.class}`;

            // Model 2 interpretation
            const r2_2 = reg2.r2 || reg1.r2;
            const r2Interp2 = interpretR2(r2_2);
            let model2Interp = '';
            if (x2Label) {
                const tStat2_1 = reg2.stdErrors[1] > 0 ? reg2.coeffs[1] / reg2.stdErrors[1] : 0;
                const tStat2_2 = reg2.stdErrors[2] > 0 ? reg2.coeffs[2] / reg2.stdErrors[2] : 0;
                const sig1 = Math.abs(tStat2_1) > 2;
                const sig2 = Math.abs(tStat2_2) > 2;
                model2Interp = `Adding <strong>${x2Label}</strong> as a second predictor explains <strong>${(r2_2 * 100).toFixed(1)}%</strong> of variance (${r2Interp2.text}). `;
                const r2Gain = r2_2 - reg1.r2;
                if (r2Gain > 0.05) {
                    model2Interp += `This improves R¬≤ by <span class="interpretation-highlight highlight-positive">+${(r2Gain * 100).toFixed(1)}%</span>. `;
                } else if (r2Gain > 0) {
                    model2Interp += `Modest improvement of +${(r2Gain * 100).toFixed(1)}% over Model 1. `;
                } else {
                    model2Interp += `No improvement over the simpler model. `;
                }
                if (sig1 && sig2) {
                    model2Interp += `Both predictors are significant.`;
                } else if (sig1) {
                    model2Interp += `Only <strong>${x1Label}</strong> is significant; ${x2Label} may be redundant.`;
                } else if (sig2) {
                    model2Interp += `Only <strong>${x2Label}</strong> is significant when both are included.`;
                } else {
                    model2Interp += `Neither predictor reaches significance in this model.`;
                }
            } else {
                model2Interp = `Same as Model 1 (no secondary predictor selected). Select a secondary predictor (X2) to compare models.`;
            }
            document.getElementById('model2Interpretation').innerHTML = model2Interp;
            document.getElementById('model2Interpretation').className = `model-interpretation interpretation-${r2Interp2.class}`;

            // Calculate and display VIF for multicollinearity detection
            const vifCard = document.getElementById('vifCard');
            const vifTableBody = document.getElementById('vifTable').querySelector('tbody');
            vifTableBody.innerHTML = '';

            // Build X matrix with all available design parameters for VIF calculation
            const vifVariables = [];
            const vifLabels = [];
            const vifData = [];

            // Add X1 variable
            vifLabels.push(x1Label);
            vifData.push(x1);

            // Add X2 if selected
            if (x2 && x2Label) {
                vifLabels.push(x2Label);
                vifData.push(x2);
            }

            // Add categorical variables if they have variation
            if (includeCat) {
                const carbonValues = matchedIndices.map(i => buildData.traceCarbon[i]);
                if (new Set(carbonValues).size > 1) {
                    vifLabels.push('Carbon Ratio');
                    vifData.push(carbonValues);
                }

                // Add Mixed and Sealed if available and have variation
                if (buildData.isMixedFlackTek) {
                    const mixedValues = matchedIndices.map(i => buildData.isMixedFlackTek[i]);
                    if (new Set(mixedValues).size > 1) {
                        vifLabels.push('Mixed (FlackTek)');
                        vifData.push(mixedValues);
                    }
                }
                if (buildData.isSealedSnap) {
                    const sealedValues = matchedIndices.map(i => buildData.isSealedSnap[i]);
                    if (new Set(sealedValues).size > 1) {
                        vifLabels.push('Sealed (Snap)');
                        vifData.push(sealedValues);
                    }
                }
            }

            // Only calculate VIF if we have 2+ predictors
            if (vifData.length >= 2) {
                vifCard.style.display = 'block';

                // Transpose data for VIF calculation
                const XforVIF = vifData[0].map((_, i) => vifData.map(col => col[i]));

                const vifs = calculateVIF(XforVIF, vifLabels);
                let hasHighVIF = false;
                let highVIFVars = [];

                vifs.forEach(({ variable, vif }) => {
                    const interp = interpretVIF(vif);
                    const vifDisplay = vif === Infinity ? '‚àû' : vif.toFixed(2);
                    let colorClass = '';
                    if (interp.level === 'high') {
                        colorClass = 'color: #ef5350;';
                        hasHighVIF = true;
                        highVIFVars.push(variable);
                    } else if (interp.level === 'moderate') {
                        colorClass = 'color: #ffa726;';
                    } else {
                        colorClass = 'color: #66bb6a;';
                    }

                    vifTableBody.innerHTML += `
                        <tr>
                            <td>${variable}</td>
                            <td style="${colorClass} font-weight: bold;">${vifDisplay}</td>
                            <td style="${colorClass}">${interp.text}</td>
                        </tr>
                    `;
                });

                // VIF interpretation
                let vifInterp = `<strong>VIF measures multicollinearity</strong> between predictors. `;
                vifInterp += `VIF < 5: low concern, 5-10: moderate, > 10: high multicollinearity. `;
                if (hasHighVIF) {
                    vifInterp += `<span style="color: #ef5350;"><strong>Warning:</strong> ${highVIFVars.join(', ')} show${highVIFVars.length === 1 ? 's' : ''} high multicollinearity. Consider removing redundant predictors.</span>`;
                } else {
                    vifInterp += `<span style="color: #66bb6a;">No concerning multicollinearity detected.</span>`;
                }
                document.getElementById('vifInterpretation').innerHTML = vifInterp;
            } else {
                vifCard.style.display = 'none';
            }

            // Update chart titles
            document.getElementById('regressionScatterTitle').innerHTML = `üìà ${yLabel} vs ${x1Label}`;
            document.getElementById('residualPlotTitle').innerHTML = `üìä Residuals: ${yLabel} ~ ${x1Label}`;

            // Scatter plot interpretation
            const correlation = reg1.slope >= 0 ? 'positive' : 'negative';
            const corrStrength = r2Interp1.text;
            let scatterInterp = `This scatter plot shows the relationship between <strong>${x1Label}</strong> (x-axis) and <strong>${yLabel}</strong> (y-axis). `;
            scatterInterp += `The orange line is the best-fit regression line. `;
            scatterInterp += `The <strong>${correlation}</strong> slope and <strong>${corrStrength}</strong> R¬≤ (${(reg1.r2 * 100).toFixed(1)}%) indicate `;
            if (reg1.r2 >= 0.7) {
                scatterInterp += `that ${x1Label} is a strong predictor of ${yLabel}. Points cluster tightly around the line.`;
            } else if (reg1.r2 >= 0.4) {
                scatterInterp += `a meaningful but imperfect relationship. Other factors also influence ${yLabel}.`;
            } else if (reg1.r2 >= 0.2) {
                scatterInterp += `a weak relationship. ${x1Label} alone does not adequately explain ${yLabel}.`;
            } else {
                scatterInterp += `little to no linear relationship between these variables.`;
            }
            document.getElementById('regressionScatterInterpretation').innerHTML = scatterInterp;
            document.getElementById('regressionScatterInterpretation').className = `chart-interpretation interpretation-${r2Interp1.class}`;

            // Calculate predicted values for plots and interpretation
            const predicted = x1.map(xi => reg1.slope * xi + reg1.intercept);

            // Residual plot interpretation
            const residualMean = mean(reg1.residuals);
            const residualStd = std(reg1.residuals);
            let residualInterp = `Residuals are the differences between actual and predicted values. `;
            residualInterp += `Ideally, they should scatter randomly around zero (dashed line). `;
            if (Math.abs(residualMean) < 0.1 * residualStd) {
                residualInterp += `<span class="interpretation-highlight highlight-positive">Good:</span> Residuals are centered near zero (mean: ${residualMean.toFixed(3)}). `;
            } else {
                residualInterp += `<span class="interpretation-highlight highlight-negative">Warning:</span> Residuals show bias (mean: ${residualMean.toFixed(3)}). `;
            }
            // Check for patterns (simplified)
            const sortedByPred = predicted.map((p, i) => ({ p, r: reg1.residuals[i] })).sort((a, b) => a.p - b.p);
            const firstHalf = sortedByPred.slice(0, Math.floor(sortedByPred.length / 2)).map(d => d.r);
            const secondHalf = sortedByPred.slice(Math.floor(sortedByPred.length / 2)).map(d => d.r);
            const firstMean = mean(firstHalf);
            const secondMean = mean(secondHalf);
            if (Math.abs(firstMean - secondMean) > residualStd) {
                residualInterp += `Pattern detected: residuals differ across prediction range, suggesting non-linearity.`;
            } else {
                residualInterp += `No obvious pattern ‚Äî the linear model appears appropriate.`;
            }
            document.getElementById('residualPlotInterpretation').innerHTML = residualInterp;

            // Regression scatter plot
            const xLine = [Math.min(...x1), Math.max(...x1)];
            const yLine = xLine.map(x => reg1.slope * x + reg1.intercept);

            safePlot('regressionScatter', [
                {
                    x: x1, y: y,
                    mode: 'markers', type: 'scatter',
                    marker: { color: sensorColors[0], size: 10 },
                    text: sensors,
                    name: 'Data'
                },
                {
                    x: xLine, y: yLine,
                    mode: 'lines', type: 'scatter',
                    line: { color: '#f59e0b', width: 3 },
                    name: 'Fit'
                }
            ], {
                ...plotlyLayout,
                xaxis: { ...plotlyLayout.xaxis, title: x1Label, type: 'linear' },
                yaxis: { ...plotlyLayout.yaxis, title: yLabel, type: 'linear' }
            }, plotlyConfig);

            // Residual plot
            safePlot('residualPlot', [{
                x: predicted,
                y: reg1.residuals,
                mode: 'markers',
                type: 'scatter',
                marker: { color: sensorColors[3], size: 8 },
                text: sensors
            }, {
                x: [Math.min(...predicted), Math.max(...predicted)],
                y: [0, 0],
                mode: 'lines',
                type: 'scatter',
                line: { color: '#64748b', width: 1, dash: 'dash' }
            }], {
                ...plotlyLayout,
                xaxis: { ...plotlyLayout.xaxis, title: `Predicted ${yLabel}`, type: 'linear' },
                yaxis: { ...plotlyLayout.yaxis, title: 'Residual', type: 'linear' },
                showlegend: false
            }, plotlyConfig);
        }

        function updateRegressionTable(tableId, data) {
            const tbody = document.querySelector(`#${tableId} tbody`);
            tbody.innerHTML = data.map(row => {
                const tStat = row.se > 0 ? row.coef / row.se : 0;
                const significant = Math.abs(tStat) > 2;
                return `<tr>
                    <td>${row.term}</td>
                    <td>${row.coef.toFixed(6)}</td>
                    <td>${row.se.toFixed(6)}</td>
                    <td class="${significant ? 'stat-significant' : ''}">${tStat.toFixed(2)}</td>
                </tr>`;
            }).join('');
        }

        // Data Tables
        function updateBuildDataTable() {
            if (!buildData) return;
            const table = document.getElementById('buildDataTable');
            table.querySelector('thead').innerHTML = `<tr>${buildData.headers.map(h => `<th>${h}</th>`).join('')}</tr>`;
            table.querySelector('tbody').innerHTML = buildData.rows.map(row => 
                `<tr>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>`
            ).join('');
        }

        function updateKPIDataTable() {
            if (!kpiData) return;
            const table = document.getElementById('kpiDataTable');
            const sensors = Object.keys(kpiData);
            const kpiNames = ['baselineMean', 'baselineStd', 'peakValue', 'peakTime', 'responseMag', 
                             'percentResponse', 't50Rise', 't90Rise', 'riseRate', 'percentRecovery', 'snr'];
            
            table.querySelector('thead').innerHTML = `<tr><th>Sensor</th>${kpiNames.map(k => `<th>${k}</th>`).join('')}</tr>`;
            table.querySelector('tbody').innerHTML = sensors.map(s => {
                const data = kpiData[s];
                return `<tr><td>${s}</td>${kpiNames.map(k => `<td>${data[k]?.toFixed(4) || '--'}</td>`).join('')}</tr>`;
            }).join('');
        }

        // Event listeners for regression controls
        ['yVariable', 'x1Variable', 'x2Variable'].forEach(id => {
            document.getElementById(id).addEventListener('change', updateRegressionAnalysis);
        });

        // Event listeners for categorical checkboxes
        ['includeMaterial', 'includeSeal', 'includeMix'].forEach(id => {
            document.getElementById(id).addEventListener('change', updateRegressionAnalysis);
        });

        // Event listeners for time series filters
        ['tsFilterMaterial', 'tsFilterSeal', 'tsFilterMix'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                if (sensorData && kpiData) updateTimeSeriesCharts();
            });
        });

        // Reset filters button
        document.getElementById('tsResetFilters').addEventListener('click', () => {
            document.getElementById('tsFilterMaterial').value = 'all';
            document.getElementById('tsFilterSeal').value = 'all';
            document.getElementById('tsFilterMix').value = 'all';
            if (sensorData && kpiData) updateTimeSeriesCharts();
        });

        // Settings change listener with localStorage persistence
        ['baselinePoints', 'peakWindow', 'finalAvgPoints', 'responseThreshold'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                saveSettingsToLocalStorage();
                if (sensorData && buildData) calculateKPIs();
            });
        });

        // LocalStorage functions for settings persistence
        function saveSettingsToLocalStorage() {
            const settings = {
                baselinePoints: document.getElementById('baselinePoints').value,
                peakWindow: document.getElementById('peakWindow').value,
                finalAvgPoints: document.getElementById('finalAvgPoints').value,
                responseThreshold: document.getElementById('responseThreshold').value
            };
            try {
                localStorage.setItem('sensorAnalysisSettings', JSON.stringify(settings));
            } catch (e) {
                console.warn('Could not save settings to localStorage:', e);
            }
        }

        function loadSettingsFromLocalStorage() {
            try {
                const saved = localStorage.getItem('sensorAnalysisSettings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    if (settings.baselinePoints) document.getElementById('baselinePoints').value = settings.baselinePoints;
                    if (settings.peakWindow) document.getElementById('peakWindow').value = settings.peakWindow;
                    if (settings.finalAvgPoints) document.getElementById('finalAvgPoints').value = settings.finalAvgPoints;
                    if (settings.responseThreshold) document.getElementById('responseThreshold').value = settings.responseThreshold;
                }
            } catch (e) {
                console.warn('Could not load settings from localStorage:', e);
            }
        }

        // Export functions
        function exportKPIsToCSV() {
            if (!kpiData || Object.keys(kpiData).length === 0) {
                alert('No KPI data to export. Please load data first.');
                return;
            }

            const sensors = Object.keys(kpiData);
            const headers = ['Sensor', 'Baseline Mean', 'Baseline Std', 'Peak Value', 'Peak Time',
                           'Response Magnitude', '% Response', 'T50 Rise', 'T90 Rise', 'Rise Rate',
                           '% Recovery', 'SNR', 'Is Significant'];

            let csv = headers.join(',') + '\n';

            sensors.forEach(sensor => {
                const k = kpiData[sensor];
                const row = [
                    sensor,
                    k.baselineMean.toFixed(6),
                    k.baselineStd.toFixed(6),
                    k.peakValue.toFixed(6),
                    k.peakTime.toFixed(2),
                    k.responseMag.toFixed(6),
                    k.percentResponse.toFixed(2),
                    k.t50Rise.toFixed(2),
                    k.t90Rise.toFixed(2),
                    k.riseRate.toFixed(6),
                    k.percentRecovery.toFixed(2),
                    k.snr.toFixed(2),
                    k.isSignificant ? 'Yes' : 'No'
                ];
                csv += row.join(',') + '\n';
            });

            downloadFile(csv, 'sensor_kpi_export.csv', 'text/csv');
        }

        function exportChartAsPNG(chartId, filename) {
            if (typeof Plotly === 'undefined') {
                alert('Plotly library not available for export.');
                return;
            }
            const chartEl = document.getElementById(chartId);
            if (!chartEl || !chartEl.data) {
                alert('Chart not ready for export.');
                return;
            }
            Plotly.downloadImage(chartEl, {
                format: 'png',
                width: 1200,
                height: 800,
                filename: filename || chartId
            });
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Add keyboard support for drop zones
        function addKeyboardSupport() {
            const dropZones = document.querySelectorAll('.drop-zone');
            dropZones.forEach(zone => {
                zone.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        const input = zone.querySelector('input[type="file"]');
                        if (input) input.click();
                    }
                });
            });

            // Tooltip keyboard support
            const tooltipIcons = document.querySelectorAll('.tooltip-icon');
            tooltipIcons.forEach(icon => {
                icon.addEventListener('focus', () => {
                    const tooltip = icon.nextElementSibling;
                    if (tooltip) tooltip.style.visibility = 'visible';
                });
                icon.addEventListener('blur', () => {
                    const tooltip = icon.nextElementSibling;
                    if (tooltip) tooltip.style.visibility = 'hidden';
                });
            });
        }

        // Initialize
        initDropZones();
        loadSettingsFromLocalStorage();
        addKeyboardSupport();
        
        // ============================================
        // TEST DATA GENERATION AND DIAGNOSTICS
        // ============================================
        
        function generateTestData() {
            debugLog('Generating test data...');
            
            // Create 12 test sensors with known properties
            const testSensors = [];
            const traceTypes = ['Carbon', 'Silver', 'None'];
            const refLocations = ['Planar Center', 'Planar Side'];
            
            for (let i = 0; i < 12; i++) {
                testSensors.push({
                    id: `Test_${String(i + 1).padStart(3, '0')}`,
                    traceType: traceTypes[i % 3],
                    refLocation: refLocations[Math.floor(i / 6)],
                    workingSA: 40 + i * 3,  // 40 to 73
                    counterSA: 20 + (i % 4) * 5,  // 20, 25, 30, 35
                    referenceSA: 10 + (i % 3) * 2,  // 10, 12, 14
                    // Known response characteristics
                    baselineValue: 0.5 + (i % 3) * 0.01,  // 0.50, 0.51, 0.52
                    baselineNoise: 0.005 + (i % 4) * 0.002,  // varying noise
                    peakValue: 1.5 + i * 0.1,  // 1.5 to 2.6
                    peakTime: 100 + i * 5,  // 100 to 155
                    riseTime: 10 + (i % 3) * 5,  // 10, 15, 20 seconds to rise
                    recoveryPercent: 70 + (i % 4) * 10  // 70, 80, 90, 100%
                });
            }
            
            // Generate Build Data
            buildData = {
                headers: ['Cell ID', 'Trace Type', 'Reference Location', 'Working SA (mm¬≤)', 'Counter SA (mm¬≤)', 'Reference SA (mm¬≤)'],
                rows: testSensors.map(s => [s.id, s.traceType, s.refLocation, s.workingSA, s.counterSA, s.referenceSA]),
                sensors: testSensors.map(s => s.id),
                traceTypes: testSensors.map(s => s.traceType),
                refLocations: testSensors.map(s => s.refLocation),
                workingSA: testSensors.map(s => s.workingSA),
                counterSA: testSensors.map(s => s.counterSA),
                referenceSA: testSensors.map(s => s.referenceSA)
            };
            
            // Calculate ratios
            buildData.wcRatio = buildData.workingSA.map((w, i) => w / buildData.counterSA[i]);
            buildData.wrRatio = buildData.workingSA.map((w, i) => w / buildData.referenceSA[i]);
            buildData.totalSA = buildData.workingSA.map((w, i) => w + buildData.counterSA[i] + buildData.referenceSA[i]);
            buildData.traceCarbon = buildData.traceTypes.map(t => {
                const val = String(t).trim();
                const numVal = parseFloat(val);
                if (!isNaN(numVal) && val.match(/^-?\d*\.?\d+$/)) {
                    return numVal;
                }
                const ratioMatch = val.match(/^(\d+(?:\.\d+)?)\s*:\s*(\d+(?:\.\d+)?)$/);
                if (ratioMatch) {
                    const carbon = parseFloat(ratioMatch[1]);
                    const silver = parseFloat(ratioMatch[2]);
                    const total = carbon + silver;
                    return total > 0 ? carbon / total : 0;
                }
                return val.toLowerCase().includes('carbon') ? 1 : 0;
            });
            buildData.traceSilver = buildData.traceTypes.map(t => {
                const val = String(t).trim();
                const numVal = parseFloat(val);
                if (!isNaN(numVal) && val.match(/^-?\d*\.?\d+$/)) {
                    return 1 - numVal;
                }
                const ratioMatch = val.match(/^(\d+(?:\.\d+)?)\s*:\s*(\d+(?:\.\d+)?)$/);
                if (ratioMatch) {
                    const carbon = parseFloat(ratioMatch[1]);
                    const silver = parseFloat(ratioMatch[2]);
                    const total = carbon + silver;
                    return total > 0 ? silver / total : 0;
                }
                return val.toLowerCase().includes('silver') ? 1 : 0;
            });
            buildData.refSide = buildData.refLocations.map(r => r.includes('Side') ? 1 : 0);
            
            // Generate Sensor Response Data (time series)
            const timePoints = 300;  // 300 seconds
            const time = Array.from({length: timePoints}, (_, i) => i);
            
            sensorData = {
                headers: ['Time (s)', ...testSensors.map(s => s.id)],
                time: time,
                sensors: {}
            };
            
            // Generate each sensor's response curve
            testSensors.forEach(sensor => {
                const values = [];
                const baseline = sensor.baselineValue;
                const noise = sensor.baselineNoise;
                const peak = sensor.peakValue;
                const peakT = sensor.peakTime;
                const riseT = sensor.riseTime;
                const recoveryTarget = baseline + (peak - baseline) * (1 - sensor.recoveryPercent / 100);
                
                for (let t = 0; t < timePoints; t++) {
                    let value;
                    
                    if (t < peakT - riseT * 2) {
                        // Baseline period
                        value = baseline + (Math.random() - 0.5) * noise * 2;
                    } else if (t < peakT) {
                        // Rise period (sigmoid)
                        const progress = (t - (peakT - riseT * 2)) / (riseT * 2);
                        const sigmoid = 1 / (1 + Math.exp(-10 * (progress - 0.5)));
                        value = baseline + (peak - baseline) * sigmoid + (Math.random() - 0.5) * noise;
                    } else if (t < peakT + 20) {
                        // Peak plateau
                        value = peak + (Math.random() - 0.5) * noise * 1.5;
                    } else {
                        // Recovery period (exponential decay)
                        const decayProgress = (t - peakT - 20) / 100;
                        value = recoveryTarget + (peak - recoveryTarget) * Math.exp(-decayProgress * 2) + (Math.random() - 0.5) * noise;
                    }
                    
                    values.push(value);
                }
                
                sensorData.sensors[sensor.id] = values;
            });
            
            // Store expected values for diagnostics
            window.testExpectedValues = testSensors.map(s => ({
                id: s.id,
                expectedBaseline: s.baselineValue,
                expectedPeak: s.peakValue,
                expectedPeakTime: s.peakTime,
                expectedResponse: s.peakValue - s.baselineValue,
                expectedRecoveryPct: s.recoveryPercent,
                traceType: s.traceType,
                refLocation: s.refLocation,
                wcRatio: s.workingSA / s.counterSA
            }));
            
            // Update UI
            document.getElementById('buildDataStatus').textContent = `‚úì Test: ${testSensors.length} sensors`;
            document.getElementById('buildDataZone').classList.add('loaded');
            document.getElementById('sensorDataStatus').textContent = `‚úì Test: ${testSensors.length} sensors, ${timePoints} time points`;
            document.getElementById('sensorDataZone').classList.add('loaded');
            document.getElementById('settingsPanel').classList.add('visible');
            const diagBtn = document.getElementById('runDiagnosticsBtn');
            if (diagBtn) diagBtn.style.display = 'inline-block';
            
            updateBuildDataTable();
            checkDataReady();
        }

        // Generate comprehensive data report for trend analysis
        function generateDebugReport() {
            if (!kpiData || !buildData) {
                alert('Please load both sensor data and build data first!');
                return;
            }

            const report = [];
            const timestamp = new Date().toISOString();

            report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            report.push('                    SENSOR STATISTICAL ANALYSIS - DATA REPORT                  ');
            report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            report.push(`Generated: ${timestamp}`);
            report.push('');

            // Section 1: Data Summary
            report.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
            report.push('‚îÇ 1. DATA SUMMARY                                                             ‚îÇ');
            report.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
            const sensors = Object.keys(kpiData);
            report.push(`Total Sensors Analyzed: ${sensors.length}`);
            report.push(`Sensors in Build Data: ${buildData.sensors.length}`);
            report.push(`Time Points: ${sensorData.time.length}`);
            report.push(`Time Range: ${sensorData.time[0]}s to ${sensorData.time[sensorData.time.length-1]}s`);
            report.push(`Exposure Duration: ${(sensorData.time[sensorData.time.length-1] - sensorData.time[0]).toFixed(1)}s`);
            report.push('');

            // Section 2: Build Data Columns & Categories
            report.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
            report.push('‚îÇ 2. BUILD PARAMETERS & CATEGORIES                                            ‚îÇ');
            report.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
            report.push(`Available Headers: ${buildData.headers.join(', ')}`);
            report.push('');
            report.push('Category Breakdown:');
            if (buildData.traceCarbon) {
                const carbonValues = [...new Set(buildData.traceCarbon)].sort((a,b) => a-b);
                report.push(`  Carbon Ratio: ${carbonValues.map(v => v.toFixed(2)).join(', ')} (n=${carbonValues.length} unique)`);
            }
            if (buildData.sealedMethod) {
                const sealCounts = {};
                buildData.sealedMethod.forEach(s => sealCounts[s] = (sealCounts[s] || 0) + 1);
                report.push(`  Seal Method: ${Object.entries(sealCounts).map(([k,v]) => `${k}(n=${v})`).join(', ')}`);
            }
            if (buildData.mixedMethod) {
                const mixCounts = {};
                buildData.mixedMethod.forEach(m => mixCounts[m] = (mixCounts[m] || 0) + 1);
                report.push(`  Mix Method: ${Object.entries(mixCounts).map(([k,v]) => `${k}(n=${v})`).join(', ')}`);
            }
            report.push('');

            // Section 3: Analysis Settings
            report.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
            report.push('‚îÇ 3. ANALYSIS SETTINGS                                                        ‚îÇ');
            report.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
            report.push(`Baseline Points: ${settings.baselinePoints}`);
            report.push(`Peak Window: ${settings.peakWindow}`);
            report.push(`Final Avg Points: ${settings.finalAvgPoints}`);
            report.push(`Response Threshold: ${settings.responseThreshold}œÉ`);
            report.push('');

            // Match sensors for analysis
            const normalize = s => String(s).toLowerCase().replace(/[^a-z0-9]/g, '');
            const kpiLookup = {};
            Object.keys(kpiData).forEach(s => kpiLookup[normalize(s)] = kpiData[s]);

            const matched = [];
            buildData.sensors.forEach((s, i) => {
                const kpi = kpiLookup[normalize(s)];
                if (kpi) {
                    matched.push({
                        sensor: s,
                        responseMag: kpi.responseMag,
                        baselineMean: kpi.baselineMean,
                        peakValue: kpi.peakValue,
                        t90Rise: kpi.t90Rise,
                        t50R: kpi.t50R || 0,
                        percentRecovery: kpi.percentRecovery || 0,
                        last30sChange: kpi.last30sPercentChange || 0,
                        isSignificant: kpi.isSignificant,
                        carbonRatio: buildData.traceCarbon ? buildData.traceCarbon[i] : null,
                        workingSA: buildData.workingSA[i],
                        counterSA: buildData.counterSA[i],
                        referenceSA: buildData.referenceSA[i],
                        wcRatio: buildData.wcRatio[i],
                        wrRatio: buildData.wrRatio[i],
                        sealMethod: buildData.sealedMethod ? buildData.sealedMethod[i] : null,
                        mixMethod: buildData.mixedMethod ? buildData.mixedMethod[i] : null,
                        isSealedSnap: buildData.isSealedSnap ? buildData.isSealedSnap[i] : null,
                        isMixedFlackTek: buildData.isMixedFlackTek ? buildData.isMixedFlackTek[i] : null
                    });
                }
            });

            // Section 4: Complete Sensor Data Table
            report.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
            report.push('‚îÇ 4. COMPLETE SENSOR DATA                                                     ‚îÇ');
            report.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
            report.push('');
            report.push('KPI Metrics:');
            report.push('Sensor          | Baseline | Peak     | Response | T90(s)  | T50R(s) | %Recov | L30s%  | Sig');
            report.push('----------------|----------|----------|----------|---------|---------|--------|--------|----');
            matched.forEach(m => {
                const row = [
                    m.sensor.padEnd(15),
                    m.baselineMean.toFixed(4).padStart(8),
                    m.peakValue.toFixed(4).padStart(8),
                    m.responseMag.toFixed(4).padStart(8),
                    m.t90Rise.toFixed(2).padStart(7),
                    m.t50R.toFixed(2).padStart(7),
                    m.percentRecovery.toFixed(1).padStart(6),
                    m.last30sChange.toFixed(1).padStart(6),
                    m.isSignificant ? 'Y' : 'N'
                ];
                report.push(row.join(' | '));
            });
            report.push('');
            report.push('Build Parameters:');
            report.push('Sensor          | C_Ratio | W_SA    | C_SA    | R_SA    | W:C     | W:R     | Seal     | Mix');
            report.push('----------------|---------|---------|---------|---------|---------|---------|----------|--------');
            matched.forEach(m => {
                const row = [
                    m.sensor.padEnd(15),
                    (m.carbonRatio !== null ? m.carbonRatio.toFixed(2) : 'N/A').padStart(7),
                    (m.workingSA || 0).toFixed(2).padStart(7),
                    (m.counterSA || 0).toFixed(2).padStart(7),
                    (m.referenceSA || 0).toFixed(2).padStart(7),
                    (m.wcRatio || 0).toFixed(3).padStart(7),
                    (m.wrRatio || 0).toFixed(3).padStart(7),
                    (m.sealMethod || 'N/A').padStart(8),
                    (m.mixMethod || 'N/A').padStart(8)
                ];
                report.push(row.join(' | '));
            });
            report.push('');

            // Section 5: Statistical Summary
            report.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
            report.push('‚îÇ 5. STATISTICAL SUMMARY                                                      ‚îÇ');
            report.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
            const responses = matched.map(m => m.responseMag);
            const t90s = matched.map(m => m.t90Rise);
            const t50Rs = matched.map(m => m.t50R);
            const recoveries = matched.map(m => m.percentRecovery);

            report.push('Metric              | Mean      | Std Dev   | Min       | Max       | Median');
            report.push('--------------------|-----------|-----------|-----------|-----------|----------');
            report.push(`Response Mag (V)    | ${mean(responses).toFixed(4).padStart(9)} | ${std(responses).toFixed(4).padStart(9)} | ${Math.min(...responses).toFixed(4).padStart(9)} | ${Math.max(...responses).toFixed(4).padStart(9)} | ${median(responses).toFixed(4).padStart(9)}`);
            report.push(`T90 Rise (s)        | ${mean(t90s).toFixed(2).padStart(9)} | ${std(t90s).toFixed(2).padStart(9)} | ${Math.min(...t90s).toFixed(2).padStart(9)} | ${Math.max(...t90s).toFixed(2).padStart(9)} | ${median(t90s).toFixed(2).padStart(9)}`);
            report.push(`T50 Recovery (s)    | ${mean(t50Rs).toFixed(2).padStart(9)} | ${std(t50Rs).toFixed(2).padStart(9)} | ${Math.min(...t50Rs).toFixed(2).padStart(9)} | ${Math.max(...t50Rs).toFixed(2).padStart(9)} | ${median(t50Rs).toFixed(2).padStart(9)}`);
            report.push(`% Recovery          | ${mean(recoveries).toFixed(1).padStart(9)} | ${std(recoveries).toFixed(1).padStart(9)} | ${Math.min(...recoveries).toFixed(1).padStart(9)} | ${Math.max(...recoveries).toFixed(1).padStart(9)} | ${median(recoveries).toFixed(1).padStart(9)}`);
            report.push('');

            // Section 6: Correlation Matrix
            report.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
            report.push('‚îÇ 6. CORRELATION MATRIX                                                       ‚îÇ');
            report.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
            if (matched.length >= 3) {
                const respMags = matched.map(m => m.responseMag);
                const carbonRatios = matched.map(m => m.carbonRatio || 0);
                const workingSAs = matched.map(m => m.workingSA || 0);
                const wcRatios = matched.map(m => m.wcRatio || 0);
                const wrRatios = matched.map(m => m.wrRatio || 0);
                const t90Values = matched.map(m => m.t90Rise);
                const sealSnap = matched.map(m => m.isSealedSnap || 0);
                const mixFlack = matched.map(m => m.isMixedFlackTek || 0);

                report.push('Correlations with Response Magnitude:');
                report.push(`  Carbon Ratio:     r = ${correlation(carbonRatios, respMags).toFixed(4)}`);
                report.push(`  Working SA:       r = ${correlation(workingSAs, respMags).toFixed(4)}`);
                report.push(`  W:C Ratio:        r = ${correlation(wcRatios, respMags).toFixed(4)}`);
                report.push(`  W:R Ratio:        r = ${correlation(wrRatios, respMags).toFixed(4)}`);
                report.push(`  T90 Rise:         r = ${correlation(t90Values, respMags).toFixed(4)}`);
                if (buildData.sealedMethod) report.push(`  Seal (Snap=1):    r = ${correlation(sealSnap, respMags).toFixed(4)}`);
                if (buildData.mixedMethod) report.push(`  Mix (FlackTek=1): r = ${correlation(mixFlack, respMags).toFixed(4)}`);
                report.push('');

                report.push('Correlations with T90 Rise Time:');
                report.push(`  Carbon Ratio:     r = ${correlation(carbonRatios, t90Values).toFixed(4)}`);
                report.push(`  Working SA:       r = ${correlation(workingSAs, t90Values).toFixed(4)}`);
                report.push(`  Response Mag:     r = ${correlation(respMags, t90Values).toFixed(4)}`);
                report.push('');

                report.push('Predictor Inter-correlations (check for multicollinearity):');
                report.push(`  Carbon vs W:C:    r = ${correlation(carbonRatios, wcRatios).toFixed(4)}`);
                report.push(`  Carbon vs W_SA:   r = ${correlation(carbonRatios, workingSAs).toFixed(4)}`);
                report.push(`  W:C vs W:R:       r = ${correlation(wcRatios, wrRatios).toFixed(4)}`);
            }
            report.push('');

            // Section 7: Group Analysis
            report.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
            report.push('‚îÇ 7. GROUP ANALYSIS                                                           ‚îÇ');
            report.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

            // By Carbon Ratio
            if (matched.some(m => m.carbonRatio !== null)) {
                const carbonGroups = {};
                matched.forEach(m => {
                    if (m.carbonRatio !== null) {
                        const key = m.carbonRatio.toFixed(2);
                        if (!carbonGroups[key]) carbonGroups[key] = [];
                        carbonGroups[key].push(m);
                    }
                });
                report.push('By Carbon Ratio:');
                report.push('C_Ratio | n  | Resp Mean | Resp Std  | T90 Mean | T90 Std');
                report.push('--------|----|-----------|-----------|---------|---------');
                Object.keys(carbonGroups).sort((a,b) => parseFloat(a) - parseFloat(b)).forEach(k => {
                    const g = carbonGroups[k];
                    const resps = g.map(x => x.responseMag);
                    const t90s = g.map(x => x.t90Rise);
                    report.push(`${k.padStart(7)} | ${String(g.length).padStart(2)} | ${mean(resps).toFixed(4).padStart(9)} | ${std(resps).toFixed(4).padStart(9)} | ${mean(t90s).toFixed(2).padStart(7)} | ${std(t90s).toFixed(2).padStart(7)}`);
                });
                report.push('');
            }

            // By Seal Method
            if (matched.some(m => m.sealMethod !== null)) {
                const sealGroups = {};
                matched.forEach(m => {
                    if (m.sealMethod !== null) {
                        if (!sealGroups[m.sealMethod]) sealGroups[m.sealMethod] = [];
                        sealGroups[m.sealMethod].push(m);
                    }
                });
                report.push('By Seal Method:');
                report.push('Seal     | n  | Resp Mean | Resp Std  | T90 Mean | T90 Std');
                report.push('---------|----|-----------|-----------|---------|---------');
                Object.keys(sealGroups).forEach(k => {
                    const g = sealGroups[k];
                    const resps = g.map(x => x.responseMag);
                    const t90s = g.map(x => x.t90Rise);
                    report.push(`${k.padEnd(8)} | ${String(g.length).padStart(2)} | ${mean(resps).toFixed(4).padStart(9)} | ${std(resps).toFixed(4).padStart(9)} | ${mean(t90s).toFixed(2).padStart(7)} | ${std(t90s).toFixed(2).padStart(7)}`);
                });
                report.push('');
            }

            // By Mix Method
            if (matched.some(m => m.mixMethod !== null)) {
                const mixGroups = {};
                matched.forEach(m => {
                    if (m.mixMethod !== null) {
                        if (!mixGroups[m.mixMethod]) mixGroups[m.mixMethod] = [];
                        mixGroups[m.mixMethod].push(m);
                    }
                });
                report.push('By Mix Method:');
                report.push('Mix      | n  | Resp Mean | Resp Std  | T90 Mean | T90 Std');
                report.push('---------|----|-----------|-----------|---------|---------');
                Object.keys(mixGroups).forEach(k => {
                    const g = mixGroups[k];
                    const resps = g.map(x => x.responseMag);
                    const t90s = g.map(x => x.t90Rise);
                    report.push(`${k.padEnd(8)} | ${String(g.length).padStart(2)} | ${mean(resps).toFixed(4).padStart(9)} | ${std(resps).toFixed(4).padStart(9)} | ${mean(t90s).toFixed(2).padStart(7)} | ${std(t90s).toFixed(2).padStart(7)}`);
                });
                report.push('');
            }

            // Section 8: Regression Analysis
            report.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
            report.push('‚îÇ 8. REGRESSION ANALYSIS                                                      ‚îÇ');
            report.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
            if (matched.length >= 3) {
                const respMags = matched.map(m => m.responseMag);

                // Model 1: Response ~ W:C Ratio
                const wcRatios = matched.map(m => m.wcRatio || 0);
                const reg1 = linearRegression(wcRatios, respMags);
                report.push('Model 1: Response ~ W:C Ratio');
                report.push(`  Slope:     ${reg1.slope.toFixed(6)}`);
                report.push(`  Intercept: ${reg1.intercept.toFixed(6)}`);
                report.push(`  R¬≤:        ${reg1.r2.toFixed(4)}`);
                report.push(`  SE(slope): ${reg1.seSlope ? reg1.seSlope.toFixed(6) : 'N/A'}`);
                report.push('');

                // Model 2: Response ~ Carbon Ratio
                if (matched.some(m => m.carbonRatio !== null)) {
                    const carbonRatios = matched.map(m => m.carbonRatio || 0);
                    const reg2 = linearRegression(carbonRatios, respMags);
                    report.push('Model 2: Response ~ Carbon Ratio');
                    report.push(`  Slope:     ${reg2.slope.toFixed(6)}`);
                    report.push(`  Intercept: ${reg2.intercept.toFixed(6)}`);
                    report.push(`  R¬≤:        ${reg2.r2.toFixed(4)}`);
                    report.push(`  SE(slope): ${reg2.seSlope ? reg2.seSlope.toFixed(6) : 'N/A'}`);
                    report.push('');
                }

                // Model 3: Response ~ Working SA
                const workingSAs = matched.map(m => m.workingSA || 0);
                const reg3 = linearRegression(workingSAs, respMags);
                report.push('Model 3: Response ~ Working SA');
                report.push(`  Slope:     ${reg3.slope.toFixed(6)}`);
                report.push(`  Intercept: ${reg3.intercept.toFixed(6)}`);
                report.push(`  R¬≤:        ${reg3.r2.toFixed(4)}`);
                report.push(`  SE(slope): ${reg3.seSlope ? reg3.seSlope.toFixed(6) : 'N/A'}`);
                report.push('');

                // Model 4: Multiple Regression with Interaction
                // Response ~ Working_SA + Seal + Working_SA √ó Seal
                if (matched.some(m => m.isSealedSnap !== null)) {
                    report.push('Model 4: Response ~ Working_SA + Seal + Working_SA √ó Seal (Interaction Model)');
                    const sealVals = matched.map(m => m.isSealedSnap || 0);
                    const interactions = matched.map((m, i) => (m.workingSA || 0) * (m.isSealedSnap || 0));

                    // Build design matrix: [Working_SA, Seal, Working_SA√óSeal]
                    const X = matched.map((m, i) => [
                        m.workingSA || 0,
                        m.isSealedSnap || 0,
                        interactions[i]
                    ]);

                    const reg4 = multipleRegression(X, respMags);
                    const labels = ['Intercept', 'Working_SA', 'Seal (Snap=1)', 'Working_SA √ó Seal'];

                    report.push('  Coefficients:');
                    reg4.coeffs.forEach((c, i) => {
                        const se = reg4.stdErrors[i] || 0;
                        const tStat = se > 0 ? c / se : 0;
                        report.push(`    ${labels[i].padEnd(20)}: ${c.toFixed(6).padStart(12)}  (SE: ${se.toFixed(6)}, t: ${tStat.toFixed(2)})`);
                    });
                    report.push(`  R¬≤:        ${reg4.r2.toFixed(4)}`);
                    report.push(`  Adj R¬≤:    ${reg4.adjR2.toFixed(4)}`);
                    report.push('');
                    report.push('  Interpretation:');
                    report.push('    - Working_SA coefficient: effect of Working SA when Seal=Screw');
                    report.push('    - Seal coefficient: difference for Snap vs Screw at Working_SA=0');
                    report.push('    - Interaction: additional effect of Working_SA for Snap-sealed sensors');
                    if (Math.abs(reg4.coeffs[3]) > 0.001) {
                        const interactionSign = reg4.coeffs[3] > 0 ? 'stronger' : 'weaker';
                        report.push(`    - The interaction term suggests the Working_SA effect is ${interactionSign} for Snap-sealed sensors`);
                    }
                    report.push('');
                }

                // Model 5: Full model with multiple predictors
                report.push('Model 5: Response ~ Working_SA + Carbon_Ratio + Seal (Additive Model)');
                if (matched.some(m => m.carbonRatio !== null && m.isSealedSnap !== null)) {
                    const X5 = matched.map(m => [
                        m.workingSA || 0,
                        m.carbonRatio || 0,
                        m.isSealedSnap || 0
                    ]);

                    const reg5 = multipleRegression(X5, respMags);
                    const labels5 = ['Intercept', 'Working_SA', 'Carbon_Ratio', 'Seal (Snap=1)'];

                    report.push('  Coefficients:');
                    reg5.coeffs.forEach((c, i) => {
                        const se = reg5.stdErrors[i] || 0;
                        const tStat = se > 0 ? c / se : 0;
                        report.push(`    ${labels5[i].padEnd(20)}: ${c.toFixed(6).padStart(12)}  (SE: ${se.toFixed(6)}, t: ${tStat.toFixed(2)})`);
                    });
                    report.push(`  R¬≤:        ${reg5.r2.toFixed(4)}`);
                    report.push(`  Adj R¬≤:    ${reg5.adjR2.toFixed(4)}`);
                    report.push('');
                    report.push('  Note: Controlling for other variables reveals partial effects');
                }
            }
            report.push('');

            // Section 9: ANOVA Tables
            report.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
            report.push('‚îÇ 9. ANOVA TABLES (Group Comparisons)                                         ‚îÇ');
            report.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
            report.push('Significance: *** p<0.001, ** p<0.01, * p<0.05, . p<0.1');
            report.push('');

            // ANOVA by Seal Method
            if (matched.some(m => m.sealMethod !== null)) {
                const sealGroups = {};
                matched.forEach(m => {
                    if (m.sealMethod !== null) {
                        if (!sealGroups[m.sealMethod]) sealGroups[m.sealMethod] = [];
                        sealGroups[m.sealMethod].push(m.responseMag);
                    }
                });

                if (Object.keys(sealGroups).length >= 2) {
                    const anova = oneWayANOVA(sealGroups);
                    report.push('ANOVA: Response by Seal Method');
                    report.push('Source          |    SS      |  df  |     MS     |     F     | p-value');
                    report.push('----------------|------------|------|------------|-----------|------------');
                    report.push(`Between Groups  | ${anova.ssb.toFixed(4).padStart(10)} | ${String(anova.dfBetween).padStart(4)} | ${anova.msb.toFixed(4).padStart(10)} | ${anova.F.toFixed(4).padStart(9)} | ${formatPValue(anova.pValue)}`);
                    report.push(`Within Groups   | ${anova.ssw.toFixed(4).padStart(10)} | ${String(anova.dfWithin).padStart(4)} | ${anova.msw.toFixed(4).padStart(10)} |           |`);
                    report.push(`Total           | ${anova.sst.toFixed(4).padStart(10)} | ${String(anova.dfTotal).padStart(4)} |            |           |`);
                    report.push(`Effect Size (Œ∑¬≤): ${anova.etaSquared.toFixed(4)} (${anova.etaSquared > 0.14 ? 'Large' : anova.etaSquared > 0.06 ? 'Medium' : 'Small'})`);
                    report.push('');
                }
            }

            // ANOVA by Mix Method
            if (matched.some(m => m.mixMethod !== null && m.mixMethod !== 'N/A')) {
                const mixGroups = {};
                matched.forEach(m => {
                    if (m.mixMethod !== null) {
                        if (!mixGroups[m.mixMethod]) mixGroups[m.mixMethod] = [];
                        mixGroups[m.mixMethod].push(m.responseMag);
                    }
                });

                if (Object.keys(mixGroups).length >= 2) {
                    const anova = oneWayANOVA(mixGroups);
                    report.push('ANOVA: Response by Mix Method');
                    report.push('Source          |    SS      |  df  |     MS     |     F     | p-value');
                    report.push('----------------|------------|------|------------|-----------|------------');
                    report.push(`Between Groups  | ${anova.ssb.toFixed(4).padStart(10)} | ${String(anova.dfBetween).padStart(4)} | ${anova.msb.toFixed(4).padStart(10)} | ${anova.F.toFixed(4).padStart(9)} | ${formatPValue(anova.pValue)}`);
                    report.push(`Within Groups   | ${anova.ssw.toFixed(4).padStart(10)} | ${String(anova.dfWithin).padStart(4)} | ${anova.msw.toFixed(4).padStart(10)} |           |`);
                    report.push(`Total           | ${anova.sst.toFixed(4).padStart(10)} | ${String(anova.dfTotal).padStart(4)} |            |           |`);
                    report.push(`Effect Size (Œ∑¬≤): ${anova.etaSquared.toFixed(4)} (${anova.etaSquared > 0.14 ? 'Large' : anova.etaSquared > 0.06 ? 'Medium' : 'Small'})`);
                    report.push('');
                }
            }

            // ANOVA by Carbon Ratio (grouped)
            if (matched.some(m => m.carbonRatio !== null)) {
                const carbonGroups = {};
                matched.forEach(m => {
                    if (m.carbonRatio !== null) {
                        const key = m.carbonRatio.toFixed(2);
                        if (!carbonGroups[key]) carbonGroups[key] = [];
                        carbonGroups[key].push(m.responseMag);
                    }
                });

                if (Object.keys(carbonGroups).length >= 2) {
                    const anova = oneWayANOVA(carbonGroups);
                    report.push('ANOVA: Response by Carbon Ratio');
                    report.push('Source          |    SS      |  df  |     MS     |     F     | p-value');
                    report.push('----------------|------------|------|------------|-----------|------------');
                    report.push(`Between Groups  | ${anova.ssb.toFixed(4).padStart(10)} | ${String(anova.dfBetween).padStart(4)} | ${anova.msb.toFixed(4).padStart(10)} | ${anova.F.toFixed(4).padStart(9)} | ${formatPValue(anova.pValue)}`);
                    report.push(`Within Groups   | ${anova.ssw.toFixed(4).padStart(10)} | ${String(anova.dfWithin).padStart(4)} | ${anova.msw.toFixed(4).padStart(10)} |           |`);
                    report.push(`Total           | ${anova.sst.toFixed(4).padStart(10)} | ${String(anova.dfTotal).padStart(4)} |            |           |`);
                    report.push(`Effect Size (Œ∑¬≤): ${anova.etaSquared.toFixed(4)} (${anova.etaSquared > 0.14 ? 'Large' : anova.etaSquared > 0.06 ? 'Medium' : 'Small'})`);
                    report.push('');
                }
            }

            // ANOVA for T90 by Seal Method
            if (matched.some(m => m.sealMethod !== null)) {
                const sealT90Groups = {};
                matched.forEach(m => {
                    if (m.sealMethod !== null) {
                        if (!sealT90Groups[m.sealMethod]) sealT90Groups[m.sealMethod] = [];
                        sealT90Groups[m.sealMethod].push(m.t90Rise);
                    }
                });

                if (Object.keys(sealT90Groups).length >= 2) {
                    const anova = oneWayANOVA(sealT90Groups);
                    report.push('ANOVA: T90 Rise Time by Seal Method');
                    report.push('Source          |    SS      |  df  |     MS     |     F     | p-value');
                    report.push('----------------|------------|------|------------|-----------|------------');
                    report.push(`Between Groups  | ${anova.ssb.toFixed(2).padStart(10)} | ${String(anova.dfBetween).padStart(4)} | ${anova.msb.toFixed(2).padStart(10)} | ${anova.F.toFixed(4).padStart(9)} | ${formatPValue(anova.pValue)}`);
                    report.push(`Within Groups   | ${anova.ssw.toFixed(2).padStart(10)} | ${String(anova.dfWithin).padStart(4)} | ${anova.msw.toFixed(2).padStart(10)} |           |`);
                    report.push(`Total           | ${anova.sst.toFixed(2).padStart(10)} | ${String(anova.dfTotal).padStart(4)} |            |           |`);
                    report.push(`Effect Size (Œ∑¬≤): ${anova.etaSquared.toFixed(4)} (${anova.etaSquared > 0.14 ? 'Large' : anova.etaSquared > 0.06 ? 'Medium' : 'Small'})`);
                    report.push('');
                }
            }

            // Section 10: Outlier Detection
            report.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
            report.push('‚îÇ 10. OUTLIER DETECTION                                                       ‚îÇ');
            report.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
            const respMean = mean(responses);
            const respStd = std(responses);
            const outliers = matched.filter(m => Math.abs(m.responseMag - respMean) > 2 * respStd);
            if (outliers.length > 0) {
                report.push(`Sensors with Response > 2œÉ from mean (${respMean.toFixed(4)} ¬± ${(2*respStd).toFixed(4)}):`);
                outliers.forEach(o => {
                    const zScore = (o.responseMag - respMean) / respStd;
                    report.push(`  ${o.sensor}: ${o.responseMag.toFixed(4)} (z=${zScore.toFixed(2)})`);
                });
            } else {
                report.push('No outliers detected (all responses within 2œÉ of mean)');
            }
            report.push('');

            // Section 11: Data Quality
            report.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
            report.push('‚îÇ 11. DATA QUALITY & VALIDATION                                               ‚îÇ');
            report.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
            const significantCount = matched.filter(m => m.isSignificant).length;
            report.push(`Significant Responses: ${significantCount}/${matched.length} (${(100*significantCount/matched.length).toFixed(1)}%)`);
            report.push(`Matched Sensors: ${matched.length}/${buildData.sensors.length} from build data`);

            // Check data quality indicators
            const hasNegativeResponses = matched.some(m => m.responseMag < 0);
            const hasZeroResponses = matched.some(m => m.responseMag === 0);
            const hasVeryHighT90 = matched.some(m => m.t90Rise > 300);
            report.push('');
            report.push('Quality Checks:');
            report.push(`  Negative responses: ${hasNegativeResponses ? 'WARNING - Found' : 'OK - None'}`);
            report.push(`  Zero responses: ${hasZeroResponses ? 'WARNING - Found' : 'OK - None'}`);
            report.push(`  T90 > 300s: ${hasVeryHighT90 ? 'WARNING - Found (may indicate no response)' : 'OK - None'}`);
            report.push('');

            // Section 12: Raw Data for Import
            report.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
            report.push('‚îÇ 12. RAW DATA (CSV FORMAT)                                                   ‚îÇ');
            report.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
            report.push('Copy this section for spreadsheet import:');
            report.push('');
            const csvHeaders = ['Sensor','Response','Baseline','Peak','T90','T50R','%Recovery','Last30s%','Significant','CarbonRatio','WorkingSA','CounterSA','RefSA','WC_Ratio','WR_Ratio','Seal','Mix'];
            report.push(csvHeaders.join(','));
            matched.forEach(m => {
                const row = [
                    m.sensor,
                    m.responseMag.toFixed(6),
                    m.baselineMean.toFixed(6),
                    m.peakValue.toFixed(6),
                    m.t90Rise.toFixed(2),
                    m.t50R.toFixed(2),
                    m.percentRecovery.toFixed(2),
                    m.last30sChange.toFixed(2),
                    m.isSignificant ? 1 : 0,
                    m.carbonRatio !== null ? m.carbonRatio.toFixed(4) : '',
                    (m.workingSA || 0).toFixed(4),
                    (m.counterSA || 0).toFixed(4),
                    (m.referenceSA || 0).toFixed(4),
                    (m.wcRatio || 0).toFixed(4),
                    (m.wrRatio || 0).toFixed(4),
                    m.sealMethod || '',
                    m.mixMethod || ''
                ];
                report.push(row.join(','));
            });
            report.push('');

            report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            report.push('                             END OF DATA REPORT                                ');
            report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

            // Open in popup window
            const reportText = report.join('\n');

            const popup = window.open('', 'DataReport', 'width=900,height=800,scrollbars=yes,resizable=yes');
            if (popup) {
                popup.document.write('<!DOCTYPE html><html><head><title>Sensor Analysis Data Report</title>');
                popup.document.write('<style>');
                popup.document.write('body { background: #1a1a2e; color: #e0e0e0; font-family: Consolas, Monaco, "Courier New", monospace; font-size: 12px; padding: 20px; margin: 0; }');
                popup.document.write('.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #444; }');
                popup.document.write('.header h1 { margin: 0; font-size: 18px; color: #4ecdc4; }');
                popup.document.write('.copy-btn { background: #4ecdc4; color: #1a1a2e; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 14px; }');
                popup.document.write('.copy-btn:hover { background: #3dbdb5; }');
                popup.document.write('pre { white-space: pre-wrap; word-wrap: break-word; background: #0d0d1a; padding: 20px; border-radius: 8px; border: 1px solid #333; overflow-x: auto; line-height: 1.4; }');
                popup.document.write('.instructions { background: #2a2a4a; padding: 12px; border-radius: 6px; margin-bottom: 15px; font-size: 13px; }');
                popup.document.write('</style></head><body>');
                popup.document.write('<div class="header"><h1>Sensor Analysis Data Report</h1>');
                popup.document.write('<button class="copy-btn" id="copyBtn">Copy Report</button></div>');
                popup.document.write('<div class="instructions"><strong>Tip:</strong> Click "Copy Report" to copy the full report, then paste it to share for trend analysis. The CSV section at the bottom can be imported directly into spreadsheet software.</div>');
                popup.document.write('<pre id="reportContent"></pre>');
                popup.document.write('</body></html>');
                popup.document.close();

                // Set content safely via textContent (avoids HTML injection issues)
                popup.document.getElementById('reportContent').textContent = reportText;

                // Add copy button handler
                popup.document.getElementById('copyBtn').addEventListener('click', function() {
                    const content = popup.document.getElementById('reportContent').textContent;
                    navigator.clipboard.writeText(content).then(() => {
                        this.textContent = 'Copied!';
                        setTimeout(() => { this.textContent = 'Copy Report'; }, 2000);
                    }).catch(() => {
                        // Fallback for older browsers
                        const textarea = popup.document.createElement('textarea');
                        textarea.value = content;
                        popup.document.body.appendChild(textarea);
                        textarea.select();
                        popup.document.execCommand('copy');
                        popup.document.body.removeChild(textarea);
                        this.textContent = 'Copied!';
                        setTimeout(() => { this.textContent = 'Copy Report'; }, 2000);
                    });
                });
            } else {
                alert('Popup blocked! Please allow popups for this site to view the report.');
            }
        }

        function runDiagnostics() {
            if (!kpiData || !buildData || !window.testExpectedValues) {
                alert('Please load test data first!');
                return;
            }
            
            const report = [];
            let passCount = 0;
            let failCount = 0;
            
            const addResult = (test, expected, actual, tolerance = 0.1) => {
                const passed = Math.abs(expected - actual) <= tolerance * Math.abs(expected) || 
                              (expected === 0 && Math.abs(actual) < 0.01);
                if (passed) passCount++; else failCount++;
                const status = passed ? '‚úÖ PASS' : '‚ùå FAIL';
                report.push(`${status}: ${test}`);
                report.push(`       Expected: ${typeof expected === 'number' ? expected.toFixed(4) : expected}`);
                report.push(`       Actual:   ${typeof actual === 'number' ? actual.toFixed(4) : actual}`);
                if (!passed) report.push(`       Difference: ${Math.abs(expected - actual).toFixed(4)}`);
                report.push('');
            };
            
            report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            report.push('              SENSOR ANALYSIS DIAGNOSTICS              ');
            report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            report.push('');
            
            // Test 1: Data Loading
            report.push('‚îÄ‚îÄ DATA LOADING ‚îÄ‚îÄ');
            addResult('Sensor count', 12, Object.keys(kpiData).length, 0);
            addResult('Build data sensors', 12, buildData.sensors.length, 0);
            report.push('');
            
            // Test 2: Sensor Matching
            report.push('‚îÄ‚îÄ SENSOR MATCHING ‚îÄ‚îÄ');
            const normalize = s => String(s).toLowerCase().replace(/[^a-z0-9]/g, '');
            const kpiNorm = new Set(Object.keys(kpiData).map(normalize));
            const buildNorm = buildData.sensors.map(normalize);
            const matchCount = buildNorm.filter(s => kpiNorm.has(s)).length;
            addResult('Matched sensors', 12, matchCount, 0);
            report.push('');
            
            // Test 3: KPI Calculations for each sensor
            report.push('‚îÄ‚îÄ KPI CALCULATIONS (Sample Sensors) ‚îÄ‚îÄ');
            
            window.testExpectedValues.slice(0, 4).forEach(expected => {
                const kpi = kpiData[expected.id];
                if (!kpi) {
                    report.push(`‚ùå FAIL: Sensor ${expected.id} not found in KPI data`);
                    failCount++;
                    return;
                }
                
                report.push(`\n  Sensor: ${expected.id} (${expected.traceType}, ${expected.refLocation})`);
                addResult(`  ${expected.id} Baseline Mean`, expected.expectedBaseline, kpi.baselineMean, 0.05);
                addResult(`  ${expected.id} Peak Value`, expected.expectedPeak, kpi.peakValue, 0.05);
                addResult(`  ${expected.id} Peak Time`, expected.expectedPeakTime, kpi.peakTime, 0.15);
                addResult(`  ${expected.id} Response Mag`, expected.expectedResponse, kpi.responseMag, 0.1);
            });
            report.push('');
            
            // Test 4: Build Data Parsing
            report.push('‚îÄ‚îÄ BUILD DATA PARSING ‚îÄ‚îÄ');
            const carbonCount = buildData.traceTypes.filter(t => t === 'Carbon').length;
            const silverCount = buildData.traceTypes.filter(t => t === 'Silver').length;
            const noneCount = buildData.traceTypes.filter(t => t === 'None').length;
            addResult('Carbon trace count', 4, carbonCount, 0);
            addResult('Silver trace count', 4, silverCount, 0);
            addResult('None trace count', 4, noneCount, 0);
            
            const centerCount = buildData.refLocations.filter(r => r.includes('Center')).length;
            const sideCount = buildData.refLocations.filter(r => r.includes('Side')).length;
            addResult('Planar Center count', 6, centerCount, 0);
            addResult('Planar Side count', 6, sideCount, 0);
            report.push('');
            
            // Test 5: Ratio Calculations
            report.push('‚îÄ‚îÄ RATIO CALCULATIONS ‚îÄ‚îÄ');
            const firstSensor = window.testExpectedValues[0];
            const firstBuildIdx = buildData.sensors.indexOf(firstSensor.id);
            if (firstBuildIdx >= 0) {
                const expectedWC = buildData.workingSA[firstBuildIdx] / buildData.counterSA[firstBuildIdx];
                addResult('W:C Ratio calculation', expectedWC, buildData.wcRatio[firstBuildIdx], 0.001);
            }
            report.push('');
            
            // Test 6: Statistical Functions
            report.push('‚îÄ‚îÄ STATISTICAL FUNCTIONS ‚îÄ‚îÄ');
            const testArr = [1, 2, 3, 4, 5];
            addResult('mean([1,2,3,4,5])', 3, mean(testArr), 0.001);
            addResult('std([1,2,3,4,5])', 1.5811, std(testArr), 0.01);
            addResult('median([1,2,3,4,5])', 3, median(testArr), 0.001);
            
            const testX = [1, 2, 3, 4, 5];
            const testY = [2, 4, 6, 8, 10];
            addResult('correlation([1..5], [2..10])', 1.0, correlation(testX, testY), 0.001);
            
            const reg = linearRegression(testX, testY);
            addResult('linearRegression slope', 2.0, reg.slope, 0.001);
            addResult('linearRegression intercept', 0.0, reg.intercept, 0.001);
            addResult('linearRegression R¬≤', 1.0, reg.r2, 0.001);
            report.push('');
            
            // Test 7: Chart Data Presence
            report.push('‚îÄ‚îÄ CHART RENDERING ‚îÄ‚îÄ');
            const charts = [
                'responseMagChart', 'responseVsBaselineChart', 'timingChart',
                'allSensorsChart', 'heatmapChart', 'normalizedChart',
                'responseHistogram', 't90Histogram', 't90CombinedBoxplot', 't50rCombinedBoxplot', 'combinedBoxplot',
                'correlationHeatmap', 'wcVsResponseChart', 'scatter3dChart'
            ];
            
            charts.forEach(chartId => {
                const el = document.getElementById(chartId);
                const hasData = el && el.data && el.data.length > 0;
                if (hasData) passCount++; else failCount++;
                report.push(`${hasData ? '‚úÖ' : '‚ùå'} ${chartId}: ${hasData ? 'Has data' : 'EMPTY'}`);
            });
            report.push('');
            
            // Test 8: Significance Detection
            report.push('‚îÄ‚îÄ SIGNIFICANCE DETECTION ‚îÄ‚îÄ');
            const significantCount = Object.values(kpiData).filter(k => k.isSignificant).length;
            addResult('Significant sensors (threshold=' + settings.responseThreshold + 'œÉ)', 12, significantCount, 0);
            report.push('');
            
            // Summary
            report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            report.push(`                    SUMMARY: ${passCount} PASSED, ${failCount} FAILED`);
            report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            if (failCount === 0) {
                report.push('\nüéâ All tests passed! The analysis appears to be working correctly.');
            } else {
                report.push(`\n‚ö†Ô∏è ${failCount} test(s) failed. Review the details above.`);
            }
            
            // Display report
            const reportEl = document.getElementById('diagnosticsReport');
            const contentEl = document.getElementById('diagnosticsContent');
            if (contentEl) contentEl.textContent = report.join('\n');
            if (reportEl) {
                reportEl.style.display = 'block';
                reportEl.scrollTop = 0;
            } else {
                debugLog(report.join('\n'));  // Fallback to console
            }
        }
        
        // Event listeners for test/diagnostics buttons (only if buttons exist)
        const testBtn = document.getElementById('loadTestDataBtn');
        const diagBtn = document.getElementById('runDiagnosticsBtn');
        const closeBtn = document.getElementById('closeDiagnosticsBtn');
        if (testBtn) testBtn.addEventListener('click', generateTestData);
        if (diagBtn) diagBtn.addEventListener('click', runDiagnostics);
        if (closeBtn) closeBtn.addEventListener('click', () => {
            document.getElementById('diagnosticsReport').style.display = 'none';
        });

        // Event listener for data report button (opens popup window)
        const debugBtn = document.getElementById('generateDebugReportBtn');
        if (debugBtn) debugBtn.addEventListener('click', generateDebugReport);
    </script>
</body>
</html>
